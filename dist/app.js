/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/gpu.js/dist/gpu-browser.js":
/*!*************************************************!*\
  !*** ./node_modules/gpu.js/dist/gpu-browser.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * gpu.js
 * http://gpu.rocks/
 *
 * GPU Accelerated JavaScript
 *
 * @version 2.15.2
 * @date Mon Mar 28 2022 10:51:06 GMT-0400 (Eastern Daylight Time)
 *
 * @license MIT
 * The MIT License
 *
 * Copyright (c) 2022 gpu.js Team
 */(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.acorn = {}));
}(this, (function (exports) { 'use strict';


  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };


  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

  var keywords = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };

  var keywordRelationalOperator = /^in(stanceof)?$/;


  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;


  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];

  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];

  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) { return false }
      pos += set[i + 1];
      if (pos >= code) { return true }
    }
  }


  function isIdentifierStart(code, astral) {
    if (code < 65) { return code === 36 }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes)
  }


  function isIdentifierChar(code, astral) {
    if (code < 48) { return code === 36 }
    if (code < 58) { return true }
    if (code < 65) { return false }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
  }





  var TokenType = function TokenType(label, conf) {
    if ( conf === void 0 ) conf = {};

    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };

  function binop(name, prec) {
    return new TokenType(name, {beforeExpr: true, binop: prec})
  }
  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};


  var keywords$1 = {};

  function kw(name, options) {
    if ( options === void 0 ) options = {};

    options.keyword = name;
    return keywords$1[name] = new TokenType(name, options)
  }

  var types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),

    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),


    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {beforeExpr: true}),
    coalesce: binop("??", 1),

    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {isLoop: true, beforeExpr: true}),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {isLoop: true}),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {isLoop: true}),
    _with: kw("with"),
    _new: kw("new", {beforeExpr: true, startsExpr: true}),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {beforeExpr: true, binop: 7}),
    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
  };


  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");

  function isNewLine(code, ecma2019String) {
    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
  }

  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  var ref = Object.prototype;
  var hasOwnProperty = ref.hasOwnProperty;
  var toString = ref.toString;


  function has(obj, propName) {
    return hasOwnProperty.call(obj, propName)
  }

  var isArray = Array.isArray || (function (obj) { return (
    toString.call(obj) === "[object Array]"
  ); });

  function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
  }


  var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
  };

  Position.prototype.offset = function offset (n) {
    return new Position(this.line, this.column + n)
  };

  var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) { this.source = p.sourceFile; }
  };


  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreakG.lastIndex = cur;
      var match = lineBreakG.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else {
        return new Position(line, offset - cur)
      }
    }
  }


  var defaultOptions = {
    ecmaVersion: 10,
    sourceType: "script",
    onInsertedSemicolon: null,
    onTrailingComma: null,
    allowReserved: null,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowAwaitOutsideFunction: false,
    allowHashBang: false,
    locations: false,
    onToken: null,
    onComment: null,
    ranges: false,
    program: null,
    sourceFile: null,
    directSourceFile: null,
    preserveParens: false
  };


  function getOptions(opts) {
    var options = {};

    for (var opt in defaultOptions)
      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

    if (options.ecmaVersion >= 2015)
      { options.ecmaVersion -= 2009; }

    if (options.allowReserved == null)
      { options.allowReserved = options.ecmaVersion < 5; }

    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) { return tokens.push(token); };
    }
    if (isArray(options.onComment))
      { options.onComment = pushComment(options, options.onComment); }

    return options
  }

  function pushComment(options, array) {
    return function(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start: start,
        end: end
      };
      if (options.locations)
        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
      if (options.ranges)
        { comment.range = [start, end]; }
      array.push(comment);
    }
  }

  var
      SCOPE_TOP = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
      SCOPE_ASYNC = 4,
      SCOPE_GENERATOR = 8,
      SCOPE_ARROW = 16,
      SCOPE_SIMPLE_CATCH = 32,
      SCOPE_SUPER = 64,
      SCOPE_DIRECT_SUPER = 128;

  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
  }

  var
      BIND_NONE = 0, 
      BIND_VAR = 1, 
      BIND_LEXICAL = 2, 
      BIND_FUNCTION = 3, 
      BIND_SIMPLE_CATCH = 4, 
      BIND_OUTSIDE = 5; 

  var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
      for (var v = options.ecmaVersion;; v--)
        { if (reserved = reservedWords[v]) { break } }
      if (options.sourceType === "module") { reserved += " await"; }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);

    this.containsEsc = false;


    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    this.type = types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();

    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    this.context = this.initialContext();
    this.exprAllowed = true;

    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);

    this.potentialArrowAt = -1;

    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    this.labels = [];
    this.undefinedExports = {};

    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
      { this.skipLineComment(2); }

    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);

    this.regexpState = null;
  };

  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

  Parser.prototype.parse = function parse () {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node)
  };

  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

  Parser.extend = function extend () {
      var plugins = [], len = arguments.length;
      while ( len-- ) plugins[ len ] = arguments[ len ];

    var cls = this;
    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
    return cls
  };

  Parser.parse = function parse (input, options) {
    return new this(options, input).parse()
  };

  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression()
  };

  Parser.tokenizer = function tokenizer (input, options) {
    return new this(options, input)
  };

  Object.defineProperties( Parser.prototype, prototypeAccessors );

  var pp = Parser.prototype;


  var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
  pp.strictDirective = function(start) {
    for (;;) {
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) { return false }
      if ((match[1] || match[2]) === "use strict") {
        skipWhiteSpace.lastIndex = start + match[0].length;
        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
        var next = this.input.charAt(end);
        return next === ";" || next === "}" ||
          (lineBreak.test(spaceAfter[0]) &&
           !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
      }
      start += match[0].length;

      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";")
        { start++; }
    }
  };


  pp.eat = function(type) {
    if (this.type === type) {
      this.next();
      return true
    } else {
      return false
    }
  };


  pp.isContextual = function(name) {
    return this.type === types.name && this.value === name && !this.containsEsc
  };


  pp.eatContextual = function(name) {
    if (!this.isContextual(name)) { return false }
    this.next();
    return true
  };


  pp.expectContextual = function(name) {
    if (!this.eatContextual(name)) { this.unexpected(); }
  };


  pp.canInsertSemicolon = function() {
    return this.type === types.eof ||
      this.type === types.braceR ||
      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  pp.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon)
        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
      return true
    }
  };


  pp.semicolon = function() {
    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
  };

  pp.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma)
        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
      if (!notNext)
        { this.next(); }
      return true
    }
  };


  pp.expect = function(type) {
    this.eat(type) || this.unexpected();
  };


  pp.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };

  function DestructuringErrors() {
    this.shorthandAssign =
    this.trailingComma =
    this.parenthesizedAssign =
    this.parenthesizedBind =
    this.doubleProto =
      -1;
  }

  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) { return }
    if (refDestructuringErrors.trailingComma > -1)
      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
  };

  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) { return false }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
    if (shorthandAssign >= 0)
      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
    if (doubleProto >= 0)
      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
  };

  pp.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
    if (this.awaitPos)
      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
  };

  pp.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression")
      { return this.isSimpleAssignTarget(expr.expression) }
    return expr.type === "Identifier" || expr.type === "MemberExpression"
  };

  var pp$1 = Parser.prototype;



  pp$1.parseTopLevel = function(node) {
    var exports = {};
    if (!node.body) { node.body = []; }
    while (this.type !== types.eof) {
      var stmt = this.parseStatement(null, true, exports);
      node.body.push(stmt);
    }
    if (this.inModule)
      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
        {
          var name = list[i];

          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
        } }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program")
  };

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  pp$1.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    if (nextCh === 91) { return true } 
    if (context) { return false }

    if (nextCh === 123) { return true } 
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) { return true }
    }
    return false
  };

  pp$1.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      { return false }

    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length;
    return !lineBreak.test(this.input.slice(this.pos, next)) &&
      this.input.slice(next, next + 8) === "function" &&
      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
  };


  pp$1.parseStatement = function(context, topLevel, exports) {
    var starttype = this.type, node = this.startNode(), kind;

    if (this.isLet(context)) {
      starttype = types._var;
      kind = "let";
    }


    switch (starttype) {
    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
    case types._debugger: return this.parseDebuggerStatement(node)
    case types._do: return this.parseDoStatement(node)
    case types._for: return this.parseForStatement(node)
    case types._function:
      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
      return this.parseFunctionStatement(node, false, !context)
    case types._class:
      if (context) { this.unexpected(); }
      return this.parseClass(node, true)
    case types._if: return this.parseIfStatement(node)
    case types._return: return this.parseReturnStatement(node)
    case types._switch: return this.parseSwitchStatement(node)
    case types._throw: return this.parseThrowStatement(node)
    case types._try: return this.parseTryStatement(node)
    case types._const: case types._var:
      kind = kind || this.value;
      if (context && kind !== "var") { this.unexpected(); }
      return this.parseVarStatement(node, kind)
    case types._while: return this.parseWhileStatement(node)
    case types._with: return this.parseWithStatement(node)
    case types.braceL: return this.parseBlock(true, node)
    case types.semi: return this.parseEmptyStatement(node)
    case types._export:
    case types._import:
      if (this.options.ecmaVersion > 10 && starttype === types._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) 
          { return this.parseExpressionStatement(node, this.parseExpression()) }
      }

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel)
          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
        if (!this.inModule)
          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
      }
      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    default:
      if (this.isAsyncFunction()) {
        if (context) { this.unexpected(); }
        this.next();
        return this.parseFunctionStatement(node, true, !context)
      }

      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
        { return this.parseLabeledStatement(node, maybeName, expr, context) }
      else { return this.parseExpressionStatement(node, expr) }
    }
  };

  pp$1.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
    else if (this.type !== types.name) { this.unexpected(); }
    else {
      node.label = this.parseIdent();
      this.semicolon();
    }

    var i = 0;
    for (; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
        if (node.label && isBreak) { break }
      }
    }
    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
  };

  pp$1.parseDebuggerStatement = function(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement")
  };

  pp$1.parseDoStatement = function(node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6)
      { this.eat(types.semi); }
    else
      { this.semicolon(); }
    return this.finishNode(node, "DoWhileStatement")
  };


  pp$1.parseForStatement = function(node) {
    this.next();
    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types.parenL);
    if (this.type === types.semi) {
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, null)
    }
    var isLet = this.isLet();
    if (this.type === types._var || this.type === types._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
          } else { node.await = awaitAt > -1; }
        }
        return this.parseForIn(node, init$1)
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init$1)
    }
    var refDestructuringErrors = new DestructuringErrors;
    var init = this.parseExpression(true, refDestructuringErrors);
    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLVal(init);
      return this.parseForIn(node, init)
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init)
  };

  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
  };

  pp$1.parseIfStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement")
  };

  pp$1.parseReturnStatement = function(node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
      { this.raise(this.start, "'return' outside of function"); }
    this.next();


    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
    else { node.argument = this.parseExpression(); this.semicolon(); }
    return this.finishNode(node, "ReturnStatement")
  };

  pp$1.parseSwitchStatement = function(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);


    var cur;
    for (var sawDefault = false; this.type !== types.braceR;) {
      if (this.type === types._case || this.type === types._default) {
        var isCase = this.type === types._case;
        if (cur) { this.finishNode(cur, "SwitchCase"); }
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types.colon);
      } else {
        if (!cur) { this.unexpected(); }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) { this.finishNode(cur, "SwitchCase"); }
    this.next(); 
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement")
  };

  pp$1.parseThrowStatement = function(node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement")
  };


  var empty = [];

  pp$1.parseTryStatement = function(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types.parenL)) {
        clause.param = this.parseBindingAtom();
        var simple = clause.param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types.parenR);
      } else {
        if (this.options.ecmaVersion < 10) { this.unexpected(); }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer)
      { this.raise(node.start, "Missing catch or finally clause"); }
    return this.finishNode(node, "TryStatement")
  };

  pp$1.parseVarStatement = function(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration")
  };

  pp$1.parseWhileStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement")
  };

  pp$1.parseWithStatement = function(node) {
    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement")
  };

  pp$1.parseEmptyStatement = function(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement")
  };

  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
      {
      var label = list[i$1];

      if (label.name === maybeName)
        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    } }
    var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
    for (var i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart === node.start) {
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else { break }
    }
    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement")
  };

  pp$1.parseExpressionStatement = function(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement")
  };


  pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
    if ( node === void 0 ) node = this.startNode();

    node.body = [];
    this.expect(types.braceL);
    if (createNewLexicalScope) { this.enterScope(0); }
    while (this.type !== types.braceR) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    if (exitStrict) { this.strict = false; }
    this.next();
    if (createNewLexicalScope) { this.exitScope(); }
    return this.finishNode(node, "BlockStatement")
  };


  pp$1.parseFor = function(node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.type === types.semi ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.type === types.parenR ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement")
  };


  pp$1.parseForIn = function(node, init) {
    var isForIn = this.type === types._in;
    this.next();

    if (
      init.type === "VariableDeclaration" &&
      init.declarations[0].init != null &&
      (
        !isForIn ||
        this.options.ecmaVersion < 8 ||
        this.strict ||
        init.kind !== "var" ||
        init.declarations[0].id.type !== "Identifier"
      )
    ) {
      this.raise(
        init.start,
        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
      );
    } else if (init.type === "AssignmentPattern") {
      this.raise(init.start, "Invalid left-hand side in for-loop");
    }
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
  };


  pp$1.parseVar = function(node, isFor, kind) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
        this.unexpected();
      } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types.comma)) { break }
    }
    return node
  };

  pp$1.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };

  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;


  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
        { this.unexpected(); }
      node.generator = this.eat(types.star);
    }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    if (statement & FUNC_STATEMENT) {
      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
    }

    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));

    if (!(statement & FUNC_STATEMENT))
      { node.id = this.type === types.name ? this.parseIdent() : null; }

    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
  };

  pp$1.parseFunctionParams = function(node) {
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };


  pp$1.parseClass = function(node, isStatement) {
    this.next();

    var oldStrict = this.strict;
    this.strict = true;

    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types.braceL);
    while (this.type !== types.braceR) {
      var element = this.parseClassElement(node.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
          hadConstructor = true;
        }
      }
    }
    this.strict = oldStrict;
    this.next();
    node.body = this.finishNode(classBody, "ClassBody");
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
  };

  pp$1.parseClassElement = function(constructorAllowsSuper) {
    var this$1 = this;

    if (this.eat(types.semi)) { return null }

    var method = this.startNode();
    var tryContextual = function (k, noLineBreak) {
      if ( noLineBreak === void 0 ) noLineBreak = false;

      var start = this$1.start, startLoc = this$1.startLoc;
      if (!this$1.eatContextual(k)) { return false }
      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
      if (method.key) { this$1.unexpected(); }
      method.computed = false;
      method.key = this$1.startNodeAt(start, startLoc);
      method.key.name = k;
      this$1.finishNode(method.key, "Identifier");
      return false
    };

    method.kind = "method";
    method.static = tryContextual("static");
    var isGenerator = this.eat(types.star);
    var isAsync = false;
    if (!isGenerator) {
      if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      } else if (tryContextual("get")) {
        method.kind = "get";
      } else if (tryContextual("set")) {
        method.kind = "set";
      }
    }
    if (!method.key) { this.parsePropertyName(method); }
    var key = method.key;
    var allowsDirectSuper = false;
    if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
        key.type === "Literal" && key.value === "constructor")) {
      if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
      method.kind = "constructor";
      allowsDirectSuper = constructorAllowsSuper;
    } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }
    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && method.value.params.length !== 0)
      { this.raiseRecoverable(method.value.start, "getter should have no params"); }
    if (method.kind === "set" && method.value.params.length !== 1)
      { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
    if (method.kind === "set" && method.value.params[0].type === "RestElement")
      { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
    return method
  };

  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    return this.finishNode(method, "MethodDefinition")
  };

  pp$1.parseClassId = function(node, isStatement) {
    if (this.type === types.name) {
      node.id = this.parseIdent();
      if (isStatement)
        { this.checkLVal(node.id, BIND_LEXICAL, false); }
    } else {
      if (isStatement === true)
        { this.unexpected(); }
      node.id = null;
    }
  };

  pp$1.parseClassSuper = function(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
  };


  pp$1.parseExport = function(node, exports) {
    this.next();
    if (this.eat(types.star)) {
      if (this.options.ecmaVersion >= 11) {
        if (this.eatContextual("as")) {
          node.exported = this.parseIdent(true);
          this.checkExport(exports, node.exported.name, this.lastTokStart);
        } else {
          node.exported = null;
        }
      }
      this.expectContextual("from");
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration")
    }
    if (this.eat(types._default)) { 
      this.checkExport(exports, "default", this.lastTokStart);
      var isAsync;
      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) { this.next(); }
        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
      } else if (this.type === types._class) {
        var cNode = this.startNode();
        node.declaration = this.parseClass(cNode, "nullableID");
      } else {
        node.declaration = this.parseMaybeAssign();
        this.semicolon();
      }
      return this.finishNode(node, "ExportDefaultDeclaration")
    }
    if (this.shouldParseExportStatement()) {
      node.declaration = this.parseStatement(null);
      if (node.declaration.type === "VariableDeclaration")
        { this.checkVariableExport(exports, node.declaration.declarations); }
      else
        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
      node.specifiers = [];
      node.source = null;
    } else { 
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers(exports);
      if (this.eatContextual("from")) {
        if (this.type !== types.string) { this.unexpected(); }
        node.source = this.parseExprAtom();
      } else {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          var spec = list[i];

          this.checkUnreserved(spec.local);
          this.checkLocalExport(spec.local);
        }

        node.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration")
  };

  pp$1.checkExport = function(exports, name, pos) {
    if (!exports) { return }
    if (has(exports, name))
      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
    exports[name] = true;
  };

  pp$1.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if (type === "Identifier")
      { this.checkExport(exports, pat.name, pat.start); }
    else if (type === "ObjectPattern")
      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
        {
          var prop = list[i];

          this.checkPatternExport(exports, prop);
        } }
    else if (type === "ArrayPattern")
      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];

          if (elt) { this.checkPatternExport(exports, elt); }
      } }
    else if (type === "Property")
      { this.checkPatternExport(exports, pat.value); }
    else if (type === "AssignmentPattern")
      { this.checkPatternExport(exports, pat.left); }
    else if (type === "RestElement")
      { this.checkPatternExport(exports, pat.argument); }
    else if (type === "ParenthesizedExpression")
      { this.checkPatternExport(exports, pat.expression); }
  };

  pp$1.checkVariableExport = function(exports, decls) {
    if (!exports) { return }
    for (var i = 0, list = decls; i < list.length; i += 1)
      {
      var decl = list[i];

      this.checkPatternExport(exports, decl.id);
    }
  };

  pp$1.shouldParseExportStatement = function() {
    return this.type.keyword === "var" ||
      this.type.keyword === "const" ||
      this.type.keyword === "class" ||
      this.type.keyword === "function" ||
      this.isLet() ||
      this.isAsyncFunction()
  };


  pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node = this.startNode();
      node.local = this.parseIdent(true);
      node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
      this.checkExport(exports, node.exported.name, node.exported.start);
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes
  };


  pp$1.parseImport = function(node) {
    this.next();
    if (this.type === types.string) {
      node.specifiers = empty;
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration")
  };


  pp$1.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types.name) {
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLVal(node.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
      if (!this.eat(types.comma)) { return nodes }
    }
    if (this.type === types.star) {
      var node$1 = this.startNode();
      this.next();
      this.expectContextual("as");
      node$1.local = this.parseIdent();
      this.checkLVal(node$1.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
      return nodes
    }
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node$2 = this.startNode();
      node$2.imported = this.parseIdent(true);
      if (this.eatContextual("as")) {
        node$2.local = this.parseIdent();
      } else {
        this.checkUnreserved(node$2.imported);
        node$2.local = node$2.imported;
      }
      this.checkLVal(node$2.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes
  };

  pp$1.adaptDirectivePrologue = function(statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
      statements[i].directive = statements[i].expression.raw.slice(1, -1);
    }
  };
  pp$1.isDirectiveCandidate = function(statement) {
    return (
      statement.type === "ExpressionStatement" &&
      statement.expression.type === "Literal" &&
      typeof statement.expression.value === "string" &&
      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
    )
  };

  var pp$2 = Parser.prototype;


  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) {
      switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await")
          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
        break

      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break

      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];

        this.toAssignable(prop, isBinding);
          if (
            prop.type === "RestElement" &&
            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
          ) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break

      case "Property":
        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
        this.toAssignable(node.value, isBinding);
        break

      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        this.toAssignableList(node.elements, isBinding);
        break

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern")
          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
        break

      case "AssignmentExpression":
        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);

      case "AssignmentPattern":
        break

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break

      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break

      case "MemberExpression":
        if (!isBinding) { break }

      default:
        this.raise(node.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
    return node
  };


  pp$2.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt) { this.toAssignable(elt, isBinding); }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
        { this.unexpected(last.argument.start); }
    }
    return exprList
  };


  pp$2.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement")
  };

  pp$2.parseRestBinding = function() {
    var node = this.startNode();
    this.next();

    if (this.options.ecmaVersion === 6 && this.type !== types.name)
      { this.unexpected(); }

    node.argument = this.parseBindingAtom();

    return this.finishNode(node, "RestElement")
  };


  pp$2.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
      case types.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern")

      case types.braceL:
        return this.parseObj(true)
      }
    }
    return this.parseIdent()
  };

  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) { first = false; }
      else { this.expect(types.comma); }
      if (allowEmpty && this.type === types.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
        break
      } else if (this.type === types.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        this.expect(close);
        break
      } else {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        elts.push(elem);
      }
    }
    return elts
  };

  pp$2.parseBindingListItem = function(param) {
    return param
  };


  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern")
  };


  pp$2.checkLVal = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    switch (expr.type) {
    case "Identifier":
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
        { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
      if (checkClashes) {
        if (has(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
      break

    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break

    case "MemberExpression":
      if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
      break

    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1)
        {
      var prop = list[i];

      this.checkLVal(prop, bindingType, checkClashes);
    }
      break

    case "Property":
      this.checkLVal(expr.value, bindingType, checkClashes);
      break

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
      }
      break

    case "AssignmentPattern":
      this.checkLVal(expr.left, bindingType, checkClashes);
      break

    case "RestElement":
      this.checkLVal(expr.argument, bindingType, checkClashes);
      break

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, bindingType, checkClashes);
      break

    default:
      this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
    }
  };


  var pp$3 = Parser.prototype;


  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
      { return }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
      { return }
    var key = prop.key;
    var name;
    switch (key.type) {
    case "Identifier": name = key.name; break
    case "Literal": name = String(key.value); break
    default: return
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0)
              { refDestructuringErrors.doubleProto = key.start; }
          } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
        }
        propHash.proto = true;
      }
      return
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition)
        { this.raiseRecoverable(key.start, "Redefinition of property"); }
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };




  pp$3.parseExpression = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
    if (this.type === types.comma) {
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
      return this.finishNode(node, "SequenceExpression")
    }
    return expr
  };


  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) { return this.parseYield(noIn) }
      else { this.exprAllowed = false; }
    }

    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors;
      ownDestructuringErrors = true;
    }

    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types.parenL || this.type === types.name)
      { this.potentialArrowAt = this.start; }
    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
    if (this.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
      if (!ownDestructuringErrors) {
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      }
      if (refDestructuringErrors.shorthandAssign >= node.left.start)
        { refDestructuringErrors.shorthandAssign = -1; } 
      this.checkLVal(left);
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression")
    } else {
      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
    }
    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
    return left
  };


  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(noIn, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    if (this.eat(types.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression")
    }
    return expr
  };


  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
  };


  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.type.binop;
    if (prec != null && (!noIn || this.type !== types._in)) {
      if (prec > minPrec) {
        var logical = this.type === types.logicalOR || this.type === types.logicalAND;
        var coalesce = this.type === types.coalesce;
        if (coalesce) {
          prec = types.logicalAND.binop;
        }
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
        if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {
          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
        }
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
      }
    }
    return left
  };

  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
  };


  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
      expr = this.parseAwait();
      sawUnary = true;
    } else if (this.type.prefix) {
      var node = this.startNode(), update = this.type === types.incDec;
      node.operator = this.value;
      node.prefix = true;
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) { this.checkLVal(node.argument); }
      else if (this.strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
      else { sawUnary = true; }
      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value;
        node$1.prefix = false;
        node$1.argument = expr;
        this.checkLVal(expr);
        this.next();
        expr = this.finishNode(node$1, "UpdateExpression");
      }
    }

    if (!sawUnary && this.eat(types.starstar))
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
    else
      { return expr }
  };


  pp$3.parseExprSubscripts = function(refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
      { return expr }
    var result = this.parseSubscripts(expr, startPos, startLoc);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    }
    return result
  };

  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
        this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
        this.potentialArrowAt === base.start;
    var optionalChained = false;

    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);

      if (element.optional) { optionalChained = true; }
      if (element === base || element.type === "ArrowFunctionExpression") {
        if (optionalChained) {
          var chainNode = this.startNodeAt(startPos, startLoc);
          chainNode.expression = element;
          element = this.finishNode(chainNode, "ChainExpression");
        }
        return element
      }

      base = element;
    }
  };

  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
    var optionalSupported = this.options.ecmaVersion >= 11;
    var optional = optionalSupported && this.eat(types.questionDot);
    if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

    var computed = this.eat(types.bracketL);
    if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
      node.computed = !!computed;
      if (computed) { this.expect(types.bracketR); }
      if (optionalSupported) {
        node.optional = optional;
      }
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0)
          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      if (optionalSupported) {
        node$1.optional = optional;
      }
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types.backQuote) {
      if (optional || optionalChained) {
        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      }
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({isTagged: true});
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base
  };


  pp$3.parseExprAtom = function(refDestructuringErrors) {
    if (this.type === types.slash) { this.readRegexp(); }

    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
    case types._super:
      if (!this.allowSuper)
        { this.raise(this.start, "'super' keyword outside a method"); }
      node = this.startNode();
      this.next();
      if (this.type === types.parenL && !this.allowDirectSuper)
        { this.raise(node.start, "super() call outside constructor of a subclass"); }
      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
        { this.unexpected(); }
      return this.finishNode(node, "Super")

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression")

    case types.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types.arrow))
          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types.arrow))
            { this.unexpected(); }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
        }
      }
      return id

    case types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {pattern: value.pattern, flags: value.flags};
      return node

    case types.num: case types.string:
      return this.parseLiteral(this.value)

    case types._null: case types._true: case types._false:
      node = this.startNode();
      node.value = this.type === types._null ? null : this.type === types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal")

    case types.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
          { refDestructuringErrors.parenthesizedAssign = start; }
        if (refDestructuringErrors.parenthesizedBind < 0)
          { refDestructuringErrors.parenthesizedBind = start; }
      }
      return expr

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression")

    case types.braceL:
      return this.parseObj(false, refDestructuringErrors)

    case types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0)

    case types._class:
      return this.parseClass(this.startNode(), false)

    case types._new:
      return this.parseNew()

    case types.backQuote:
      return this.parseTemplate()

    case types._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport()
      } else {
        return this.unexpected()
      }

    default:
      this.unexpected();
    }
  };

  pp$3.parseExprImport = function() {
    var node = this.startNode();

    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
    var meta = this.parseIdent(true);

    switch (this.type) {
    case types.parenL:
      return this.parseDynamicImport(node)
    case types.dot:
      node.meta = meta;
      return this.parseImportMeta(node)
    default:
      this.unexpected();
    }
  };

  pp$3.parseDynamicImport = function(node) {
    this.next(); 

    node.source = this.parseMaybeAssign();

    if (!this.eat(types.parenR)) {
      var errorPos = this.start;
      if (this.eat(types.comma) && this.eat(types.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }

    return this.finishNode(node, "ImportExpression")
  };

  pp$3.parseImportMeta = function(node) {
    this.next(); 

    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);

    if (node.property.name !== "meta")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
    if (containsEsc)
      { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
    if (this.options.sourceType !== "module")
      { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

    return this.finishNode(node, "MetaProperty")
  };

  pp$3.parseLiteral = function(value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
    this.next();
    return this.finishNode(node, "Literal")
  };

  pp$3.parseParenExpression = function() {
    this.expect(types.parenL);
    var val = this.parseExpression();
    this.expect(types.parenR);
    return val
  };

  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();

      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      while (this.type !== types.parenR) {
        first ? first = false : this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
          lastIsComma = true;
          break
        } else if (this.type === types.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
          break
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.start, innerEndLoc = this.startLoc;
      this.expect(types.parenR);

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList)
      }

      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
      if (spreadStart) { this.unexpected(spreadStart); }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }

    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression")
    } else {
      return val
    }
  };

  pp$3.parseParenItem = function(item) {
    return item
  };

  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
  };


  var empty$1 = [];

  pp$3.parseNew = function() {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
    var node = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
      node.meta = meta;
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "target")
        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
      if (containsEsc)
        { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
      if (!this.inNonArrowFunction())
        { this.raiseRecoverable(node.start, "'new.target' can only be used in functions"); }
      return this.finishNode(node, "MetaProperty")
    }
    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    if (isImport && node.callee.type === "ImportExpression") {
      this.raise(startPos, "Cannot use new with import()");
    }
    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
    else { node.arguments = empty$1; }
    return this.finishNode(node, "NewExpression")
  };


  pp$3.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged;

    var elem = this.startNode();
    if (this.type === types.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value,
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types.backQuote;
    return this.finishNode(elem, "TemplateElement")
  };

  pp$3.parseTemplate = function(ref) {
    if ( ref === void 0 ) ref = {};
    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({isTagged: isTagged});
    node.quasis = [curElt];
    while (!curElt.tail) {
      if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
      this.expect(types.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types.braceR);
      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral")
  };

  pp$3.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };


  pp$3.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = true, propHash = {};
    node.properties = [];
    this.next();
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
      node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
  };

  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement")
      }
      if (this.type === types.parenL && refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0) {
          refDestructuringErrors.parenthesizedAssign = this.start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = this.start;
        }
      }
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      return this.finishNode(prop, "SpreadElement")
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern)
        { isGenerator = this.eat(types.star); }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      this.parsePropertyName(prop, refDestructuringErrors);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property")
  };

  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types.colon)
      { this.unexpected(); }

    if (this.eat(types.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
      if (isPattern) { this.unexpected(); }
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc &&
               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
               (prop.key.name === "get" || prop.key.name === "set") &&
               (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {
      if (isGenerator || isAsync) { this.unexpected(); }
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get")
          { this.raiseRecoverable(start, "getter should have no params"); }
        else
          { this.raiseRecoverable(start, "setter should have exactly one param"); }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
          { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
      }
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) { this.unexpected(); }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = startPos; }
      prop.kind = "init";
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else if (this.type === types.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0)
          { refDestructuringErrors.shorthandAssign = this.start; }
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else {
        prop.value = prop.key;
      }
      prop.shorthand = true;
    } else { this.unexpected(); }
  };

  pp$3.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
        return prop.key
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
  };


  pp$3.initFunction = function(node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
    if (this.options.ecmaVersion >= 8) { node.async = false; }
  };


  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.initFunction(node);
    if (this.options.ecmaVersion >= 6)
      { node.generator = isGenerator; }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression")
  };


  pp$3.parseArrowExpression = function(node, params, isAsync) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;

    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression")
  };


  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
    var isExpression = isArrowFunction && this.type !== types.braceL;
    var oldStrict = this.strict, useStrict = false;

    if (isExpression) {
      node.body = this.parseMaybeAssign();
      node.expression = true;
      this.checkParams(node, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        if (useStrict && nonSimple)
          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
      }
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) { this.strict = true; }

      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
      if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
      node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
      node.expression = false;
      this.adaptDirectivePrologue(node.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();
  };

  pp$3.isSimpleParamList = function(params) {
    for (var i = 0, list = params; i < list.length; i += 1)
      {
      var param = list[i];

      if (param.type !== "Identifier") { return false
    } }
    return true
  };


  pp$3.checkParams = function(node, allowDuplicates) {
    var nameHash = {};
    for (var i = 0, list = node.params; i < list.length; i += 1)
      {
      var param = list[i];

      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };


  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
      } else { first = false; }

      var elt = (void 0);
      if (allowEmpty && this.type === types.comma)
        { elt = null; }
      else if (this.type === types.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
          { refDestructuringErrors.trailingComma = this.start; }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts
  };

  pp$3.checkUnreserved = function(ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;

    if (this.inGenerator && name === "yield")
      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
    if (this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
    if (this.keywords.test(name))
      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
    if (this.options.ecmaVersion < 6 &&
      this.input.slice(start, end).indexOf("\\") !== -1) { return }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
      if (!this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
    }
  };


  pp$3.parseIdent = function(liberal, isBinding) {
    var node = this.startNode();
    if (this.type === types.name) {
      node.name = this.value;
    } else if (this.type.keyword) {
      node.name = this.type.keyword;

      if ((node.name === "class" || node.name === "function") &&
          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
    } else {
      this.unexpected();
    }
    this.next(!!liberal);
    this.finishNode(node, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node);
      if (node.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = node.start; }
    }
    return node
  };


  pp$3.parseYield = function(noIn) {
    if (!this.yieldPos) { this.yieldPos = this.start; }

    var node = this.startNode();
    this.next();
    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types.star);
      node.argument = this.parseMaybeAssign(noIn);
    }
    return this.finishNode(node, "YieldExpression")
  };

  pp$3.parseAwait = function() {
    if (!this.awaitPos) { this.awaitPos = this.start; }

    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, false);
    return this.finishNode(node, "AwaitExpression")
  };

  var pp$4 = Parser.prototype;


  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
    throw err
  };

  pp$4.raiseRecoverable = pp$4.raise;

  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart)
    }
  };

  var pp$5 = Parser.prototype;

  var Scope = function Scope(flags) {
    this.flags = flags;
    this.var = [];
    this.lexical = [];
    this.functions = [];
  };


  pp$5.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  };

  pp$5.exitScope = function() {
    this.scopeStack.pop();
  };

  pp$5.treatFunctionsAsVarInScope = function(scope) {
    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
  };

  pp$5.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      scope.lexical.push(name);
      if (this.inModule && (scope.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$1 = this.currentScope();
      scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar)
        { redeclared = scope$2.lexical.indexOf(name) > -1; }
      else
        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
      scope$2.functions.push(name);
    } else {
      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
          redeclared = true;
          break
        }
        scope$3.var.push(name);
        if (this.inModule && (scope$3.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
        if (scope$3.flags & SCOPE_VAR) { break }
      }
    }
    if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
  };

  pp$5.checkLocalExport = function(id) {
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
        this.scopeStack[0].var.indexOf(id.name) === -1) {
      this.undefinedExports[id.name] = id;
    }
  };

  pp$5.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1]
  };

  pp$5.currentVarScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR) { return scope }
    }
  };

  pp$5.currentThisScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
    }
  };

  var Node = function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations)
      { this.loc = new SourceLocation(parser, loc); }
    if (parser.options.directSourceFile)
      { this.sourceFile = parser.options.directSourceFile; }
    if (parser.options.ranges)
      { this.range = [pos, 0]; }
  };


  var pp$6 = Parser.prototype;

  pp$6.startNode = function() {
    return new Node(this, this.start, this.startLoc)
  };

  pp$6.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc)
  };


  function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    if (this.options.locations)
      { node.loc.end = loc; }
    if (this.options.ranges)
      { node.range[1] = pos; }
    return node
  }

  pp$6.finishNode = function(node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
  };


  pp$6.finishNodeAt = function(node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc)
  };


  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };

  var types$1 = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };

  var pp$7 = Parser.prototype;

  pp$7.initialContext = function() {
    return [types$1.b_stat]
  };

  pp$7.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types$1.f_expr || parent === types$1.f_stat)
      { return true }
    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
      { return !parent.isExpr }

    if (prevType === types._return || prevType === types.name && this.exprAllowed)
      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
      { return true }
    if (prevType === types.braceL)
      { return parent === types$1.b_stat }
    if (prevType === types._var || prevType === types._const || prevType === types.name)
      { return false }
    return !this.exprAllowed
  };

  pp$7.inGeneratorContext = function() {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if (context.token === "function")
        { return context.generator }
    }
    return false
  };

  pp$7.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types.dot)
      { this.exprAllowed = false; }
    else if (update = type.updateContext)
      { update.call(this, prevType); }
    else
      { this.exprAllowed = type.beforeExpr; }
  };


  types.parenR.updateContext = types.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return
    }
    var out = this.context.pop();
    if (out === types$1.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };

  types.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
    this.exprAllowed = true;
  };

  types.dollarBraceL.updateContext = function() {
    this.context.push(types$1.b_tmpl);
    this.exprAllowed = true;
  };

  types.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
    this.exprAllowed = true;
  };

  types.incDec.updateContext = function() {
  };

  types._function.updateContext = types._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
      { this.context.push(types$1.f_expr); }
    else
      { this.context.push(types$1.f_stat); }
    this.exprAllowed = false;
  };

  types.backQuote.updateContext = function() {
    if (this.curContext() === types$1.q_tmpl)
      { this.context.pop(); }
    else
      { this.context.push(types$1.q_tmpl); }
    this.exprAllowed = false;
  };

  types.star.updateContext = function(prevType) {
    if (prevType === types._function) {
      var index = this.context.length - 1;
      if (this.context[index] === types$1.f_expr)
        { this.context[index] = types$1.f_expr_gen; }
      else
        { this.context[index] = types$1.f_gen; }
    }
    this.exprAllowed = true;
  };

  types.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
      if (this.value === "of" && !this.exprAllowed ||
          this.value === "yield" && this.inGeneratorContext())
        { allowed = true; }
    }
    this.exprAllowed = allowed;
  };


  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties
  };

  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

  var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues
  };

  var data = {};
  function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;

    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  buildUnicodeData(9);
  buildUnicodeData(10);
  buildUnicodeData(11);

  var pp$8 = Parser.prototype;

  var RegExpValidationState = function RegExpValidationState(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
  };

  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  };

  RegExpValidationState.prototype.raise = function raise (message) {
    this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
  };

  RegExpValidationState.prototype.at = function at (i, forceU) {
      if ( forceU === void 0 ) forceU = false;

    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return -1
    }
    var c = s.charCodeAt(i);
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
      return c
    }
    var next = s.charCodeAt(i + 1);
    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
  };

  RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
      if ( forceU === void 0 ) forceU = false;

    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return l
    }
    var c = s.charCodeAt(i), next;
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
      return i + 1
    }
    return i + 2
  };

  RegExpValidationState.prototype.current = function current (forceU) {
      if ( forceU === void 0 ) forceU = false;

    return this.at(this.pos, forceU)
  };

  RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
      if ( forceU === void 0 ) forceU = false;

    return this.at(this.nextIndex(this.pos, forceU), forceU)
  };

  RegExpValidationState.prototype.advance = function advance (forceU) {
      if ( forceU === void 0 ) forceU = false;

    this.pos = this.nextIndex(this.pos, forceU);
  };

  RegExpValidationState.prototype.eat = function eat (ch, forceU) {
      if ( forceU === void 0 ) forceU = false;

    if (this.current(forceU) === ch) {
      this.advance(forceU);
      return true
    }
    return false
  };

  function codePointToString(ch) {
    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
    ch -= 0x10000;
    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
  }

  pp$8.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;

    for (var i = 0; i < flags.length; i++) {
      var flag = flags.charAt(i);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
    }
  };

  pp$8.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);

    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };

  pp$8.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;

    this.regexp_disjunction(state);

    if (state.pos !== state.source.length) {
      if (state.eat(0x29 )) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(0x5D ) || state.eat(0x7D )) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
      var name = list[i];

      if (state.groupNames.indexOf(name) === -1) {
        state.raise("Invalid named capture referenced");
      }
    }
  };

  pp$8.regexp_disjunction = function(state) {
    this.regexp_alternative(state);
    while (state.eat(0x7C )) {
      this.regexp_alternative(state);
    }

    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(0x7B )) {
      state.raise("Lone quantifier brackets");
    }
  };

  pp$8.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state))
      { }
  };

  pp$8.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true
    }

    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true
    }

    return false
  };

  pp$8.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;

    if (state.eat(0x5E ) || state.eat(0x24 )) {
      return true
    }

    if (state.eat(0x5C )) {
      if (state.eat(0x42 ) || state.eat(0x62 )) {
        return true
      }
      state.pos = start;
    }

    if (state.eat(0x28 ) && state.eat(0x3F )) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(0x3C );
      }
      if (state.eat(0x3D ) || state.eat(0x21 )) {
        this.regexp_disjunction(state);
        if (!state.eat(0x29 )) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true
      }
    }

    state.pos = start;
    return false
  };

  pp$8.regexp_eatQuantifier = function(state, noError) {
    if ( noError === void 0 ) noError = false;

    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(0x3F );
      return true
    }
    return false
  };

  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
    return (
      state.eat(0x2A ) ||
      state.eat(0x2B ) ||
      state.eat(0x3F ) ||
      this.regexp_eatBracedQuantifier(state, noError)
    )
  };
  pp$8.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(0x7B )) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(0x2C ) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(0x7D )) {
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start;
    }
    return false
  };

  pp$8.regexp_eatAtom = function(state) {
    return (
      this.regexp_eatPatternCharacters(state) ||
      state.eat(0x2E ) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state)
    )
  };
  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(0x5C )) {
      if (this.regexp_eatAtomEscape(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(0x28 )) {
      if (state.eat(0x3F ) && state.eat(0x3A )) {
        this.regexp_disjunction(state);
        if (state.eat(0x29 )) {
          return true
        }
        state.raise("Unterminated group");
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatCapturingGroup = function(state) {
    if (state.eat(0x28 )) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 0x3F ) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(0x29 )) {
        state.numCapturingParens += 1;
        return true
      }
      state.raise("Unterminated group");
    }
    return false
  };

  pp$8.regexp_eatExtendedAtom = function(state) {
    return (
      state.eat(0x2E ) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state) ||
      this.regexp_eatInvalidBracedQuantifier(state) ||
      this.regexp_eatExtendedPatternCharacter(state)
    )
  };

  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false
  };

  pp$8.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }
    return false
  };
  function isSyntaxCharacter(ch) {
    return (
      ch === 0x24  ||
      ch >= 0x28  && ch <= 0x2B  ||
      ch === 0x2E  ||
      ch === 0x3F  ||
      ch >= 0x5B  && ch <= 0x5E  ||
      ch >= 0x7B  && ch <= 0x7D 
    )
  }

  pp$8.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
      state.advance();
    }
    return state.pos !== start
  };

  pp$8.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (
      ch !== -1 &&
      ch !== 0x24  &&
      !(ch >= 0x28  && ch <= 0x2B ) &&
      ch !== 0x2E  &&
      ch !== 0x3F  &&
      ch !== 0x5B  &&
      ch !== 0x5E  &&
      ch !== 0x7C 
    ) {
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_groupSpecifier = function(state) {
    if (state.eat(0x3F )) {
      if (this.regexp_eatGroupName(state)) {
        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
          state.raise("Duplicate capture group name");
        }
        state.groupNames.push(state.lastStringValue);
        return
      }
      state.raise("Invalid group");
    }
  };

  pp$8.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(0x3C )) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E )) {
        return true
      }
      state.raise("Invalid capture group name");
    }
    return false
  };

  pp$8.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true
    }
    return false
  };

  pp$8.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);

    if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 0x24  || ch === 0x5F 
  }

  pp$8.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);

    if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 0x24  || ch === 0x5F  || ch === 0x200C  || ch === 0x200D 
  }

  pp$8.regexp_eatAtomEscape = function(state) {
    if (
      this.regexp_eatBackReference(state) ||
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state) ||
      (state.switchN && this.regexp_eatKGroupName(state))
    ) {
      return true
    }
    if (state.switchU) {
      if (state.current() === 0x63 ) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false
  };
  pp$8.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) {
        if (n > state.maxBackReference) {
          state.maxBackReference = n;
        }
        return true
      }
      if (n <= state.numCapturingParens) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatKGroupName = function(state) {
    if (state.eat(0x6B )) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true
      }
      state.raise("Invalid named reference");
    }
    return false
  };

  pp$8.regexp_eatCharacterEscape = function(state) {
    return (
      this.regexp_eatControlEscape(state) ||
      this.regexp_eatCControlLetter(state) ||
      this.regexp_eatZero(state) ||
      this.regexp_eatHexEscapeSequence(state) ||
      this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
      this.regexp_eatIdentityEscape(state)
    )
  };
  pp$8.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(0x63 )) {
      if (this.regexp_eatControlLetter(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatZero = function(state) {
    if (state.current() === 0x30  && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 0x74 ) {
      state.lastIntValue = 0x09; 
      state.advance();
      return true
    }
    if (ch === 0x6E ) {
      state.lastIntValue = 0x0A; 
      state.advance();
      return true
    }
    if (ch === 0x76 ) {
      state.lastIntValue = 0x0B; 
      state.advance();
      return true
    }
    if (ch === 0x66 ) {
      state.lastIntValue = 0x0C; 
      state.advance();
      return true
    }
    if (ch === 0x72 ) {
      state.lastIntValue = 0x0D; 
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };
  function isControlLetter(ch) {
    return (
      (ch >= 0x41  && ch <= 0x5A ) ||
      (ch >= 0x61  && ch <= 0x7A )
    )
  }

  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
    if ( forceU === void 0 ) forceU = false;

    var start = state.pos;
    var switchU = forceU || state.switchU;

    if (state.eat(0x75 )) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(0x5C ) && state.eat(0x75 ) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 0xDC00 && trail <= 0xDFFF) {
              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
              return true
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true
      }
      if (
        switchU &&
        state.eat(0x7B ) &&
        this.regexp_eatHexDigits(state) &&
        state.eat(0x7D ) &&
        isValidUnicode(state.lastIntValue)
      ) {
        return true
      }
      if (switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start;
    }

    return false
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 0x10FFFF
  }

  pp$8.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true
      }
      if (state.eat(0x2F )) {
        state.lastIntValue = 0x2F; 
        return true
      }
      return false
    }

    var ch = state.current();
    if (ch !== 0x63  && (!state.switchN || ch !== 0x6B )) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  pp$8.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 0x31  && ch <= 0x39 ) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
        state.advance();
      } while ((ch = state.current()) >= 0x30  && ch <= 0x39 )
      return true
    }
    return false
  };

  pp$8.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();

    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return true
    }

    if (
      state.switchU &&
      this.options.ecmaVersion >= 9 &&
      (ch === 0x50  || ch === 0x70 )
    ) {
      state.lastIntValue = -1;
      state.advance();
      if (
        state.eat(0x7B ) &&
        this.regexp_eatUnicodePropertyValueExpression(state) &&
        state.eat(0x7D )
      ) {
        return true
      }
      state.raise("Invalid property name");
    }

    return false
  };
  function isCharacterClassEscape(ch) {
    return (
      ch === 0x64  ||
      ch === 0x44  ||
      ch === 0x73  ||
      ch === 0x53  ||
      ch === 0x77  ||
      ch === 0x57 
    )
  }

  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;

    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D )) {
      var name = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
        return true
      }
    }
    state.pos = start;

    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      return true
    }
    return false
  };
  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
    if (!has(state.unicodeProperties.nonBinary, name))
      { state.raise("Invalid property name"); }
    if (!state.unicodeProperties.nonBinary[name].test(value))
      { state.raise("Invalid property value"); }
  };
  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue))
      { state.raise("Invalid property name"); }
  };

  pp$8.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 0x5F 
  }

  pp$8.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
  }

  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state)
  };

  pp$8.regexp_eatCharacterClass = function(state) {
    if (state.eat(0x5B )) {
      state.eat(0x5E );
      this.regexp_classRanges(state);
      if (state.eat(0x5D )) {
        return true
      }
      state.raise("Unterminated character class");
    }
    return false
  };

  pp$8.regexp_classRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(0x2D ) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };

  pp$8.regexp_eatClassAtom = function(state) {
    var start = state.pos;

    if (state.eat(0x5C )) {
      if (this.regexp_eatClassEscape(state)) {
        return true
      }
      if (state.switchU) {
        var ch$1 = state.current();
        if (ch$1 === 0x63  || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start;
    }

    var ch = state.current();
    if (ch !== 0x5D ) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  pp$8.regexp_eatClassEscape = function(state) {
    var start = state.pos;

    if (state.eat(0x62 )) {
      state.lastIntValue = 0x08; 
      return true
    }

    if (state.switchU && state.eat(0x2D )) {
      state.lastIntValue = 0x2D; 
      return true
    }

    if (!state.switchU && state.eat(0x63 )) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true
      }
      state.pos = start;
    }

    return (
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state)
    )
  };

  pp$8.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 0x5F ) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(0x78 )) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return false
  };

  pp$8.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
      state.advance();
    }
    return state.pos !== start
  };
  function isDecimalDigit(ch) {
    return ch >= 0x30  && ch <= 0x39 
  }

  pp$8.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start
  };
  function isHexDigit(ch) {
    return (
      (ch >= 0x30  && ch <= 0x39 ) ||
      (ch >= 0x41  && ch <= 0x46 ) ||
      (ch >= 0x61  && ch <= 0x66 )
    )
  }
  function hexToInt(ch) {
    if (ch >= 0x41  && ch <= 0x46 ) {
      return 10 + (ch - 0x41 )
    }
    if (ch >= 0x61  && ch <= 0x66 ) {
      return 10 + (ch - 0x61 )
    }
    return ch - 0x30 
  }

  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n1 * 8 + n2;
        }
      } else {
        state.lastIntValue = n1;
      }
      return true
    }
    return false
  };

  pp$8.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 0x30; 
      state.advance();
      return true
    }
    state.lastIntValue = 0;
    return false
  };
  function isOctalDigit(ch) {
    return ch >= 0x30  && ch <= 0x37 
  }

  pp$8.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i = 0; i < length; ++i) {
      var ch = state.current();
      if (!isHexDigit(ch)) {
        state.pos = start;
        return false
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true
  };


  var Token = function Token(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations)
      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
    if (p.options.ranges)
      { this.range = [p.start, p.end]; }
  };


  var pp$9 = Parser.prototype;


  pp$9.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
      { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
    if (this.options.onToken)
      { this.options.onToken(new Token(this)); }

    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };

  pp$9.getToken = function() {
    this.next();
    return new Token(this)
  };

  if (typeof Symbol !== "undefined")
    { pp$9[Symbol.iterator] = function() {
      var this$1 = this;

      return {
        next: function () {
          var token = this$1.getToken();
          return {
            done: token.type === types.eof,
            value: token
          }
        }
      }
    }; }


  pp$9.curContext = function() {
    return this.context[this.context.length - 1]
  };


  pp$9.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

    this.start = this.pos;
    if (this.options.locations) { this.startLoc = this.curPosition(); }
    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

    if (curContext.override) { return curContext.override(this) }
    else { this.readToken(this.fullCharCodeAtPos()); }
  };

  pp$9.readToken = function(code) {
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 )
      { return this.readWord() }

    return this.getTokenFromCode(code)
  };

  pp$9.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 0xd7ff || code >= 0xe000) { return code }
    var next = this.input.charCodeAt(this.pos + 1);
    return (code << 10) + next - 0x35fdc00
  };

  pp$9.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
    this.pos = end + 2;
    if (this.options.locations) {
      lineBreakG.lastIndex = start;
      var match;
      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
        ++this.curLine;
        this.lineStart = match.index + match[0].length;
      }
    }
    if (this.options.onComment)
      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  pp$9.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch)) {
      ch = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment)
      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                             startLoc, this.curPosition()); }
  };


  pp$9.skipSpace = function() {
    loop: while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
      case 32: case 160: 
        ++this.pos;
        break
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10: case 8232: case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break
      case 47: 
        switch (this.input.charCodeAt(this.pos + 1)) {
        case 42: 
          this.skipBlockComment();
          break
        case 47:
          this.skipLineComment(2);
          break
        default:
          break loop
        }
        break
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop
        }
      }
    }
  };


  pp$9.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations) { this.endLoc = this.curPosition(); }
    var prevType = this.type;
    this.type = type;
    this.value = val;

    this.updateContext(prevType);
  };


  pp$9.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) { return this.readNumber(true) }
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { 
      this.pos += 3;
      return this.finishToken(types.ellipsis)
    } else {
      ++this.pos;
      return this.finishToken(types.dot)
    }
  };

  pp$9.readToken_slash = function() { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.slash, 1)
  };

  pp$9.readToken_mult_modulo_exp = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types.star : types.modulo;

    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
      ++size;
      tokentype = types.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }

    if (next === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(tokentype, size)
  };

  pp$9.readToken_pipe_amp = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (this.options.ecmaVersion >= 12) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 === 61) { return this.finishOp(types.assign, 3) }
      }
      return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
  };

  pp$9.readToken_caret = function() { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.bitwiseXOR, 1)
  };

  pp$9.readToken_plus_min = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken()
      }
      return this.finishOp(types.incDec, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.plusMin, 1)
  };

  pp$9.readToken_lt_gt = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
      return this.finishOp(types.bitShift, size)
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
        this.input.charCodeAt(this.pos + 3) === 45) {
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken()
    }
    if (next === 61) { size = 2; }
    return this.finishOp(types.relational, size)
  };

  pp$9.readToken_eq_excl = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { 
      this.pos += 2;
      return this.finishToken(types.arrow)
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
  };

  pp$9.readToken_question = function() { 
    var ecmaVersion = this.options.ecmaVersion;
    if (ecmaVersion >= 11) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 46) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }
      }
      if (next === 63) {
        if (ecmaVersion >= 12) {
          var next2$1 = this.input.charCodeAt(this.pos + 2);
          if (next2$1 === 61) { return this.finishOp(types.assign, 3) }
        }
        return this.finishOp(types.coalesce, 2)
      }
    }
    return this.finishOp(types.question, 1)
  };

  pp$9.getTokenFromCode = function(code) {
    switch (code) {
    case 46: 
      return this.readToken_dot()

    case 40: ++this.pos; return this.finishToken(types.parenL)
    case 41: ++this.pos; return this.finishToken(types.parenR)
    case 59: ++this.pos; return this.finishToken(types.semi)
    case 44: ++this.pos; return this.finishToken(types.comma)
    case 91: ++this.pos; return this.finishToken(types.bracketL)
    case 93: ++this.pos; return this.finishToken(types.bracketR)
    case 123: ++this.pos; return this.finishToken(types.braceL)
    case 125: ++this.pos; return this.finishToken(types.braceR)
    case 58: ++this.pos; return this.finishToken(types.colon)

    case 96: 
      if (this.options.ecmaVersion < 6) { break }
      ++this.pos;
      return this.finishToken(types.backQuote)

    case 48: 
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) { return this.readRadixNumber(16) } 
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) { return this.readRadixNumber(8) } 
        if (next === 98 || next === 66) { return this.readRadixNumber(2) } 
      }

    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: 
      return this.readNumber(false)

    case 34: case 39: 
      return this.readString(code)


    case 47: 
      return this.readToken_slash()

    case 37: case 42: 
      return this.readToken_mult_modulo_exp(code)

    case 124: case 38: 
      return this.readToken_pipe_amp(code)

    case 94: 
      return this.readToken_caret()

    case 43: case 45: 
      return this.readToken_plus_min(code)

    case 60: case 62: 
      return this.readToken_lt_gt(code)

    case 61: case 33: 
      return this.readToken_eq_excl(code)

    case 63: 
      return this.readToken_question()

    case 126: 
      return this.finishOp(types.prefix, 1)
    }

    this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
  };

  pp$9.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str)
  };

  pp$9.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
      if (!escaped) {
        if (ch === "[") { inClass = true; }
        else if (ch === "]" && inClass) { inClass = false; }
        else if (ch === "/" && !inClass) { break }
        escaped = ch === "\\";
      } else { escaped = false; }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) { this.unexpected(flagsStart); }

    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);

    var value = null;
    try {
      value = new RegExp(pattern, flags);
    } catch (e) {
    }

    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
  };


  pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

    var start = this.pos, total = 0, lastCode = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
      var code = this.input.charCodeAt(this.pos), val = (void 0);

      if (allowSeparators && code === 95) {
        if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
        if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
        if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
        lastCode = code;
        continue
      }

      if (code >= 97) { val = code - 97 + 10; } 
      else if (code >= 65) { val = code - 65 + 10; } 
      else if (code >= 48 && code <= 57) { val = code - 48; } 
      else { val = Infinity; }
      if (val >= radix) { break }
      lastCode = code;
      total = total * radix + val;
    }

    if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
    if (this.pos === start || len != null && this.pos - start !== len) { return null }

    return total
  };

  function stringToNumber(str, isLegacyOctalNumericLiteral) {
    if (isLegacyOctalNumericLiteral) {
      return parseInt(str, 8)
    }

    return parseFloat(str.replace(/_/g, ""))
  }

  function stringToBigInt(str) {
    if (typeof BigInt !== "function") {
      return null
    }

    return BigInt(str.replace(/_/g, ""))
  }

  pp$9.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2; 
    var val = this.readInt(radix);
    if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val)
  };


  pp$9.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) { this.raise(start, "Invalid number"); }
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var val$1 = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types.num, val$1)
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
    if (next === 46 && !octal) { 
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) { 
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45) { ++this.pos; } 
      if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

    var val = stringToNumber(this.input.slice(start, this.pos), octal);
    return this.finishToken(types.num, val)
  };


  pp$9.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code;

    if (ch === 123) { 
      if (this.options.ecmaVersion < 6) { this.unexpected(); }
      var codePos = ++this.pos;
      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
    } else {
      code = this.readHexChar(4);
    }
    return code
  };

  function codePointToString$1(code) {
    if (code <= 0xFFFF) { return String.fromCharCode(code) }
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
  }

  pp$9.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) { break }
      if (ch === 92) { 
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else {
        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types.string, out)
  };


  var INVALID_TEMPLATE_ESCAPE_ERROR = {};

  pp$9.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err
      }
    }

    this.inTemplateElement = false;
  };

  pp$9.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR
    } else {
      this.raise(position, message);
    }
  };

  pp$9.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { 
        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types.dollarBraceL)
          } else {
            ++this.pos;
            return this.finishToken(types.backQuote)
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types.template, out)
      }
      if (ch === 92) { 
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
        case 10:
          out += "\n";
          break
        default:
          out += String.fromCharCode(ch);
          break
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };

  pp$9.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break

      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break
        }

      case "`":
        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

      }
    }
    this.raise(this.start, "Unterminated template");
  };


  pp$9.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
    case 110: return "\n" 
    case 114: return "\r" 
    case 120: return String.fromCharCode(this.readHexChar(2)) 
    case 117: return codePointToString$1(this.readCodePoint()) 
    case 116: return "\t" 
    case 98: return "\b" 
    case 118: return "\u000b" 
    case 102: return "\f" 
    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } 
    case 10: 
      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
      return ""
    case 56:
    case 57:
      if (inTemplate) {
        var codePos = this.pos - 1;

        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );

        return null
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate
              ? "Octal literal in template string"
              : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal)
      }
      if (isNewLine(ch)) {
        return ""
      }
      return String.fromCharCode(ch)
    }
  };


  pp$9.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
    return n
  };


  pp$9.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) {
        this.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) { 
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117) 
          { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
          { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
        word += codePointToString$1(esc);
        chunkStart = this.pos;
      } else {
        break
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos)
  };


  pp$9.readWord = function() {
    var word = this.readWord1();
    var type = types.name;
    if (this.keywords.test(word)) {
      type = keywords$1[word];
    }
    return this.finishToken(type, word)
  };


  var version = "7.4.0";

  Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types,
    keywordTypes: keywords$1,
    TokContext: TokContext,
    tokContexts: types$1,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
  };


  function parse(input, options) {
    return Parser.parse(input, options)
  }


  function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options)
  }


  function tokenizer(input, options) {
    return Parser.tokenizer(input, options)
  }

  exports.Node = Node;
  exports.Parser = Parser;
  exports.Position = Position;
  exports.SourceLocation = SourceLocation;
  exports.TokContext = TokContext;
  exports.Token = Token;
  exports.TokenType = TokenType;
  exports.defaultOptions = defaultOptions;
  exports.getLineInfo = getLineInfo;
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierStart = isIdentifierStart;
  exports.isNewLine = isNewLine;
  exports.keywordTypes = keywords$1;
  exports.lineBreak = lineBreak;
  exports.lineBreakG = lineBreakG;
  exports.nonASCIIwhitespace = nonASCIIwhitespace;
  exports.parse = parse;
  exports.parseExpressionAt = parseExpressionAt;
  exports.tokContexts = types$1;
  exports.tokTypes = types;
  exports.tokenizer = tokenizer;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
function glWiretap(gl, options = {}) {
  const {
    contextName = 'gl',
    throwGetError,
    useTrackablePrimitives,
    readPixelsFile,
    recording = [],
    variables = {},
    onReadPixels,
    onUnrecognizedArgumentLookup,
  } = options;
  const proxy = new Proxy(gl, { get: listen });
  const contextVariables = [];
  const entityNames = {};
  let imageCount = 0;
  let indent = '';
  let readPixelsVariableName;
  return proxy;
  function listen(obj, property) {
    switch (property) {
      case 'addComment': return addComment;
      case 'checkThrowError': return checkThrowError;
      case 'getReadPixelsVariableName': return readPixelsVariableName;
      case 'insertVariable': return insertVariable;
      case 'reset': return reset;
      case 'setIndent': return setIndent;
      case 'toString': return toString;
      case 'getContextVariableName': return getContextVariableName;
    }
    if (typeof gl[property] === 'function') {
      return function() { 
        switch (property) {
          case 'getError':
            if (throwGetError) {
              recording.push(`${indent}if (${contextName}.getError() !== ${contextName}.NONE) throw new Error('error');`);
            } else {
              recording.push(`${indent}${contextName}.getError();`); 
            }
            return gl.getError();
          case 'getExtension': {
            const variableName = `${contextName}Variables${contextVariables.length}`;
            recording.push(`${indent}const ${variableName} = ${contextName}.getExtension('${arguments[0]}');`);
            const extension = gl.getExtension(arguments[0]);
            if (extension && typeof extension === 'object') {
              const tappedExtension = glExtensionWiretap(extension, {
                getEntity,
                useTrackablePrimitives,
                recording,
                contextName: variableName,
                contextVariables,
                variables,
                indent,
                onUnrecognizedArgumentLookup,
              });
              contextVariables.push(tappedExtension);
              return tappedExtension;
            } else {
              contextVariables.push(null);
            }
            return extension;
          }
          case 'readPixels':
            const i = contextVariables.indexOf(arguments[6]);
            let targetVariableName;
            if (i === -1) {
              const variableName = getVariableName(arguments[6]);
              if (variableName) {
                targetVariableName = variableName;
                recording.push(`${indent}${variableName}`);
              } else {
                targetVariableName = `${contextName}Variable${contextVariables.length}`;
                contextVariables.push(arguments[6]);
                recording.push(`${indent}const ${targetVariableName} = new ${arguments[6].constructor.name}(${arguments[6].length});`);
              }
            } else {
              targetVariableName = `${contextName}Variable${i}`;
            }
            readPixelsVariableName = targetVariableName;
            const argumentAsStrings = [
              arguments[0],
              arguments[1],
              arguments[2],
              arguments[3],
              getEntity(arguments[4]),
              getEntity(arguments[5]),
              targetVariableName
            ];
            recording.push(`${indent}${contextName}.readPixels(${argumentAsStrings.join(', ')});`);
            if (readPixelsFile) {
              writePPM(arguments[2], arguments[3]);
            }
            if (onReadPixels) {
              onReadPixels(targetVariableName, argumentAsStrings);
            }
            return gl.readPixels.apply(gl, arguments);
          case 'drawBuffers':
            recording.push(`${indent}${contextName}.drawBuffers([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup } )}]);`);
            return gl.drawBuffers(arguments[0]);
        }
        let result = gl[property].apply(gl, arguments);
        switch (typeof result) {
          case 'undefined':
            recording.push(`${indent}${methodCallToString(property, arguments)};`);
            return;
          case 'number':
          case 'boolean':
            if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result = trackablePrimitive(result));
              break;
            }
          default:
            if (result === null) {
              recording.push(`${methodCallToString(property, arguments)};`);
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
            }

            contextVariables.push(result);
        }
        return result;
      }
    }
    entityNames[gl[property]] = property;
    return gl[property];
  }
  function toString() {
    return recording.join('\n');
  }
  function reset() {
    while (recording.length > 0) {
      recording.pop();
    }
  }
  function insertVariable(name, value) {
    variables[name] = value;
  }
  function getEntity(value) {
    const name = entityNames[value];
    if (name) {
      return contextName + '.' + name;
    }
    return value;
  }
  function setIndent(spaces) {
    indent = ' '.repeat(spaces);
  }
  function addVariable(value, source) {
    const variableName = `${contextName}Variable${contextVariables.length}`;
    recording.push(`${indent}const ${variableName} = ${source};`);
    contextVariables.push(value);
    return variableName;
  }
  function writePPM(width, height) {
    const sourceVariable = `${contextName}Variable${contextVariables.length}`;
    const imageVariable = `imageDatum${imageCount}`;
    recording.push(`${indent}let ${imageVariable} = ["P3\\n# ${readPixelsFile}.ppm\\n", ${width}, ' ', ${height}, "\\n255\\n"].join("");`);
    recording.push(`${indent}for (let i = 0; i < ${imageVariable}.length; i += 4) {`);
    recording.push(`${indent}  ${imageVariable} += ${sourceVariable}[i] + ' ' + ${sourceVariable}[i + 1] + ' ' + ${sourceVariable}[i + 2] + ' ';`);
    recording.push(`${indent}}`);
    recording.push(`${indent}if (typeof require !== "undefined") {`);
    recording.push(`${indent}  require('fs').writeFileSync('./${readPixelsFile}.ppm', ${imageVariable});`);
    recording.push(`${indent}}`);
    imageCount++;
  }
  function addComment(value) {
    recording.push(`${indent}// ${value}`);
  }
  function checkThrowError() {
    recording.push(`${indent}(() => {
${indent}const error = ${contextName}.getError();
${indent}if (error !== ${contextName}.NONE) {
${indent}  const names = Object.getOwnPropertyNames(gl);
${indent}  for (let i = 0; i < names.length; i++) {
${indent}    const name = names[i];
${indent}    if (${contextName}[name] === error) {
${indent}      throw new Error('${contextName} threw ' + name);
${indent}    }
${indent}  }
${indent}}
${indent}})();`);
  }
  function methodCallToString(method, args) {
    return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
  }

  function getVariableName(value) {
    if (variables) {
      for (const name in variables) {
        if (variables[name] === value) {
          return name;
        }
      }
    }
    return null;
  }

  function getContextVariableName(value) {
    const i = contextVariables.indexOf(value);
    if (i !== -1) {
      return `${contextName}Variable${i}`;
    }
    return null;
  }
}

function glExtensionWiretap(extension, options) {
  const proxy = new Proxy(extension, { get: listen });
  const extensionEntityNames = {};
  const {
    contextName,
    contextVariables,
    getEntity,
    useTrackablePrimitives,
    recording,
    variables,
    indent,
    onUnrecognizedArgumentLookup,
  } = options;
  return proxy;
  function listen(obj, property) {
    if (typeof obj[property] === 'function') {
      return function() {
        switch (property) {
          case 'drawBuffersWEBGL':
            recording.push(`${indent}${contextName}.drawBuffersWEBGL([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })}]);`);
            return extension.drawBuffersWEBGL(arguments[0]);
        }
        let result = extension[property].apply(extension, arguments);
        switch (typeof result) {
          case 'undefined':
            recording.push(`${indent}${methodCallToString(property, arguments)};`);
            return;
          case 'number':
          case 'boolean':
            if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result = trackablePrimitive(result));
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result);
            }
            break;
          default:
            if (result === null) {
              recording.push(`${methodCallToString(property, arguments)};`);
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
            }
            contextVariables.push(result);
        }
        return result;
      };
    }
    extensionEntityNames[extension[property]] = property;
    return extension[property];
  }

  function getExtensionEntity(value) {
    if (extensionEntityNames.hasOwnProperty(value)) {
      return `${contextName}.${extensionEntityNames[value]}`;
    }
    return getEntity(value);
  }

  function methodCallToString(method, args) {
    return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
  }

  function addVariable(value, source) {
    const variableName = `${contextName}Variable${contextVariables.length}`;
    contextVariables.push(value);
    recording.push(`${indent}const ${variableName} = ${source};`);
    return variableName;
  }
}

function argumentsToString(args, options) {
  const { variables, onUnrecognizedArgumentLookup } = options;
  return (Array.from(args).map((arg) => {
    const variableName = getVariableName(arg);
    if (variableName) {
      return variableName;
    }
    return argumentToString(arg, options);
  }).join(', '));

  function getVariableName(value) {
    if (variables) {
      for (const name in variables) {
        if (!variables.hasOwnProperty(name)) continue;
        if (variables[name] === value) {
          return name;
        }
      }
    }
    if (onUnrecognizedArgumentLookup) {
      return onUnrecognizedArgumentLookup(value);
    }
    return null;
  }
}

function argumentToString(arg, options) {
  const { contextName, contextVariables, getEntity, addVariable, onUnrecognizedArgumentLookup } = options;
  if (typeof arg === 'undefined') {
    return 'undefined';
  }
  if (arg === null) {
    return 'null';
  }
  const i = contextVariables.indexOf(arg);
  if (i > -1) {
    return `${contextName}Variable${i}`;
  }
  switch (arg.constructor.name) {
    case 'String':
      const hasLines = /\n/.test(arg);
      const hasSingleQuotes = /'/.test(arg);
      const hasDoubleQuotes = /"/.test(arg);
      if (hasLines) {
        return '`' + arg + '`';
      } else if (hasSingleQuotes && !hasDoubleQuotes) {
        return '"' + arg + '"';
      } else if (!hasSingleQuotes && hasDoubleQuotes) {
        return "'" + arg + "'";
      } else {
        return '\'' + arg + '\'';
      }
    case 'Number': return getEntity(arg);
    case 'Boolean': return getEntity(arg);
    case 'Array':
      return addVariable(arg, `new ${arg.constructor.name}([${Array.from(arg).join(',')}])`);
    case 'Float32Array':
    case 'Uint8Array':
    case 'Uint16Array':
    case 'Int32Array':
      return addVariable(arg, `new ${arg.constructor.name}(${JSON.stringify(Array.from(arg))})`);
    default:
      if (onUnrecognizedArgumentLookup) {
        const instantiationString = onUnrecognizedArgumentLookup(arg);
        if (instantiationString) {
          return instantiationString;
        }
      }
      throw new Error(`unrecognized argument type ${arg.constructor.name}`);
  }
}

function trackablePrimitive(value) {
  return new value.constructor(value);
}

if (typeof module !== 'undefined') {
  module.exports = { glWiretap, glExtensionWiretap };
}

if (typeof window !== 'undefined') {
  glWiretap.glExtensionWiretap = glExtensionWiretap;
  window.glWiretap = glWiretap;
}

},{}],4:[function(require,module,exports){
function setupArguments(args) {
  const newArguments = new Array(args.length);
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.toArray) {
      newArguments[i] = arg.toArray();
    } else {
      newArguments[i] = arg;
    }
  }
  return newArguments;
}

function mock1D() {
  const args = setupArguments(arguments);
  const row = new Float32Array(this.output.x);
  for (let x = 0; x < this.output.x; x++) {
    this.thread.x = x;
    this.thread.y = 0;
    this.thread.z = 0;
    row[x] = this._fn.apply(this, args);
  }
  return row;
}

function mock2D() {
  const args = setupArguments(arguments);
  const matrix = new Array(this.output.y);
  for (let y = 0; y < this.output.y; y++) {
    const row = new Float32Array(this.output.x);
    for (let x = 0; x < this.output.x; x++) {
      this.thread.x = x;
      this.thread.y = y;
      this.thread.z = 0;
      row[x] = this._fn.apply(this, args);
    }
    matrix[y] = row;
  }
  return matrix;
}

function mock2DGraphical() {
  const args = setupArguments(arguments);
  for (let y = 0; y < this.output.y; y++) {
    for (let x = 0; x < this.output.x; x++) {
      this.thread.x = x;
      this.thread.y = y;
      this.thread.z = 0;
      this._fn.apply(this, args);
    }
  }
}

function mock3D() {
  const args = setupArguments(arguments);
  const cube = new Array(this.output.z);
  for (let z = 0; z < this.output.z; z++) {
    const matrix = new Array(this.output.y);
    for (let y = 0; y < this.output.y; y++) {
      const row = new Float32Array(this.output.x);
      for (let x = 0; x < this.output.x; x++) {
        this.thread.x = x;
        this.thread.y = y;
        this.thread.z = z;
        row[x] = this._fn.apply(this, args);
      }
      matrix[y] = row;
    }
    cube[z] = matrix;
  }
  return cube;
}

function apiDecorate(kernel) {
  kernel.setOutput = (output) => {
    kernel.output = setupOutput(output);
    if (kernel.graphical) {
      setupGraphical(kernel);
    }
  };
  kernel.toJSON = () => {
    throw new Error('Not usable with gpuMock');
  };
  kernel.setConstants = (flag) => {
    kernel.constants = flag;
    return kernel;
  };
  kernel.setGraphical = (flag) => {
    kernel.graphical = flag;
    return kernel;
  };
  kernel.setCanvas = (flag) => {
    kernel.canvas = flag;
    return kernel;
  };
  kernel.setContext = (flag) => {
    kernel.context = flag;
    return kernel;
  };
  kernel.destroy = () => {};
  kernel.validateSettings = () => {};
  if (kernel.graphical && kernel.output) {
    setupGraphical(kernel);
  }
  kernel.exec = function() {
    return new Promise((resolve, reject) => {
      try {
        resolve(kernel.apply(kernel, arguments));
      } catch(e) {
        reject(e);
      }
    });
  };
  kernel.getPixels = (flip) => {
    const {x, y} = kernel.output;
    return flip ? flipPixels(kernel._imageData.data, x, y) : kernel._imageData.data.slice(0);
  };
  kernel.color = function(r, g, b, a) {
    if (typeof a === 'undefined') {
      a = 1;
    }

    r = Math.floor(r * 255);
    g = Math.floor(g * 255);
    b = Math.floor(b * 255);
    a = Math.floor(a * 255);

    const width = kernel.output.x;
    const height = kernel.output.y;

    const x = kernel.thread.x;
    const y = height - kernel.thread.y - 1;

    const index = x + y * width;

    kernel._colorData[index * 4 + 0] = r;
    kernel._colorData[index * 4 + 1] = g;
    kernel._colorData[index * 4 + 2] = b;
    kernel._colorData[index * 4 + 3] = a;
  };

  const mockMethod = () => kernel;
  const methods = [
    'setWarnVarUsage',
    'setArgumentTypes',
    'setTactic',
    'setOptimizeFloatMemory',
    'setDebug',
    'setLoopMaxIterations',
    'setConstantTypes',
    'setFunctions',
    'setNativeFunctions',
    'setInjectedNative',
    'setPipeline',
    'setPrecision',
    'setOutputToTexture',
    'setImmutable',
    'setStrictIntegers',
    'setDynamicOutput',
    'setHardcodeConstants',
    'setDynamicArguments',
    'setUseLegacyEncoder',
    'setWarnVarUsage',
    'addSubKernel',
  ];
  for (let i = 0; i < methods.length; i++) {
    kernel[methods[i]] = mockMethod;
  }
  return kernel;
}

function setupGraphical(kernel) {
  const {x, y} = kernel.output;
  if (kernel.context && kernel.context.createImageData) {
    const data = new Uint8ClampedArray(x * y * 4);
    kernel._imageData = kernel.context.createImageData(x, y);
    kernel._colorData = data;
  } else {
    const data = new Uint8ClampedArray(x * y * 4);
    kernel._imageData = { data };
    kernel._colorData = data;
  }
}

function setupOutput(output) {
  let result = null;
  if (output.length) {
    if (output.length === 3) {
      const [x,y,z] = output;
      result = { x, y, z };
    } else if (output.length === 2) {
      const [x,y] = output;
      result = { x, y };
    } else {
      const [x] = output;
      result = { x };
    }
  } else {
    result = output;
  }
  return result;
}

function gpuMock(fn, settings = {}) {
  const output = settings.output ? setupOutput(settings.output) : null;
  function kernel() {
    if (kernel.output.z) {
      return mock3D.apply(kernel, arguments);
    } else if (kernel.output.y) {
      if (kernel.graphical) {
        return mock2DGraphical.apply(kernel, arguments);
      }
      return mock2D.apply(kernel, arguments);
    } else {
      return mock1D.apply(kernel, arguments);
    }
  }
  kernel._fn = fn;
  kernel.constants = settings.constants || null;
  kernel.context = settings.context || null;
  kernel.canvas = settings.canvas || null;
  kernel.graphical = settings.graphical || false;
  kernel._imageData = null;
  kernel._colorData = null;
  kernel.output = output;
  kernel.thread = {
    x: 0,
    y: 0,
    z: 0
  };
  return apiDecorate(kernel);
}

function flipPixels(pixels, width, height) {
  const halfHeight = height / 2 | 0; 
  const bytesPerRow = width * 4;
  const temp = new Uint8ClampedArray(width * 4);
  const result = pixels.slice(0);
  for (let y = 0; y < halfHeight; ++y) {
    const topOffset = y * bytesPerRow;
    const bottomOffset = (height - y - 1) * bytesPerRow;

    temp.set(result.subarray(topOffset, topOffset + bytesPerRow));

    result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);

    result.set(temp, bottomOffset);
  }
  return result;
}

module.exports = {
  gpuMock
};

},{}],5:[function(require,module,exports){
const { utils } = require('./utils');

function alias(name, source) {
  const fnString = source.toString();
  return new Function(`return function ${ name } (${ utils.getArgumentNamesFromString(fnString).join(', ') }) {
  ${ utils.getFunctionBodyFromString(fnString) }
}`)();
}

module.exports = {
  alias
};
},{"./utils":114}],6:[function(require,module,exports){
const { FunctionNode } = require('../function-node');

class CPUFunctionNode extends FunctionNode {
  astFunction(ast, retArr) {

    if (!this.isRootKernel) {
      retArr.push('function');
      retArr.push(' ');
      retArr.push(this.name);
      retArr.push('(');

      for (let i = 0; i < this.argumentNames.length; ++i) {
        const argumentName = this.argumentNames[i];

        if (i > 0) {
          retArr.push(', ');
        }
        retArr.push('user_');
        retArr.push(argumentName);
      }

      retArr.push(') {\n');
    }

    for (let i = 0; i < ast.body.body.length; ++i) {
      this.astGeneric(ast.body.body[i], retArr);
      retArr.push('\n');
    }

    if (!this.isRootKernel) {
      retArr.push('}\n');
    }
    return retArr;
  }

  astReturnStatement(ast, retArr) {
    const type = this.returnType || this.getType(ast.argument);

    if (!this.returnType) {
      this.returnType = type;
    }

    if (this.isRootKernel) {
      retArr.push(this.leadingReturnStatement);
      this.astGeneric(ast.argument, retArr);
      retArr.push(';\n');
      retArr.push(this.followingReturnStatement);
      retArr.push('continue;\n');
    } else if (this.isSubKernel) {
      retArr.push(`subKernelResult_${ this.name } = `);
      this.astGeneric(ast.argument, retArr);
      retArr.push(';');
      retArr.push(`return subKernelResult_${ this.name };`);
    } else {
      retArr.push('return ');
      this.astGeneric(ast.argument, retArr);
      retArr.push(';');
    }
    return retArr;
  }

  astLiteral(ast, retArr) {

    if (isNaN(ast.value)) {
      throw this.astErrorOutput(
        'Non-numeric literal not supported : ' + ast.value,
        ast
      );
    }

    retArr.push(ast.value);

    return retArr;
  }

  astBinaryExpression(ast, retArr) {
    retArr.push('(');
    this.astGeneric(ast.left, retArr);
    retArr.push(ast.operator);
    this.astGeneric(ast.right, retArr);
    retArr.push(')');
    return retArr;
  }

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput(
        'IdentifierExpression - not an Identifier',
        idtNode
      );
    }

    switch (idtNode.name) {
      case 'Infinity':
        retArr.push('Infinity');
        break;
      default:
        if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {
          retArr.push('constants_' + idtNode.name);
        } else {
          retArr.push('user_' + idtNode.name);
        }
    }

    return retArr;
  }

  astForStatement(forNode, retArr) {
    if (forNode.type !== 'ForStatement') {
      throw this.astErrorOutput('Invalid for statement', forNode);
    }

    const initArr = [];
    const testArr = [];
    const updateArr = [];
    const bodyArr = [];
    let isSafe = null;

    if (forNode.init) {
      this.pushState('in-for-loop-init');
      this.astGeneric(forNode.init, initArr);
      for (let i = 0; i < initArr.length; i++) {
        if (initArr[i].includes && initArr[i].includes(',')) {
          isSafe = false;
        }
      }
      this.popState('in-for-loop-init');
    } else {
      isSafe = false;
    }

    if (forNode.test) {
      this.astGeneric(forNode.test, testArr);
    } else {
      isSafe = false;
    }

    if (forNode.update) {
      this.astGeneric(forNode.update, updateArr);
    } else {
      isSafe = false;
    }

    if (forNode.body) {
      this.pushState('loop-body');
      this.astGeneric(forNode.body, bodyArr);
      this.popState('loop-body');
    }

    if (isSafe === null) {
      isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
    }

    if (isSafe) {
      retArr.push(`for (${initArr.join('')};${testArr.join('')};${updateArr.join('')}){\n`);
      retArr.push(bodyArr.join(''));
      retArr.push('}\n');
    } else {
      const iVariableName = this.getInternalVariableName('safeI');
      if (initArr.length > 0) {
        retArr.push(initArr.join(''), ';\n');
      }
      retArr.push(`for (let ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
      if (testArr.length > 0) {
        retArr.push(`if (!${testArr.join('')}) break;\n`);
      }
      retArr.push(bodyArr.join(''));
      retArr.push(`\n${updateArr.join('')};`);
      retArr.push('}\n');
    }
    return retArr;
  }

  astWhileStatement(whileNode, retArr) {
    if (whileNode.type !== 'WhileStatement') {
      throw this.astErrorOutput(
        'Invalid while statement',
        whileNode
      );
    }

    retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
    retArr.push('if (');
    this.astGeneric(whileNode.test, retArr);
    retArr.push(') {\n');
    this.astGeneric(whileNode.body, retArr);
    retArr.push('} else {\n');
    retArr.push('break;\n');
    retArr.push('}\n');
    retArr.push('}\n');

    return retArr;
  }

  astDoWhileStatement(doWhileNode, retArr) {
    if (doWhileNode.type !== 'DoWhileStatement') {
      throw this.astErrorOutput(
        'Invalid while statement',
        doWhileNode
      );
    }

    retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
    this.astGeneric(doWhileNode.body, retArr);
    retArr.push('if (!');
    this.astGeneric(doWhileNode.test, retArr);
    retArr.push(') {\n');
    retArr.push('break;\n');
    retArr.push('}\n');
    retArr.push('}\n');

    return retArr;

  }

  astAssignmentExpression(assNode, retArr) {
    const declaration = this.getDeclaration(assNode.left);
    if (declaration && !declaration.assignable) {
      throw this.astErrorOutput(`Variable ${assNode.left.name} is not assignable here`, assNode);
    }
    this.astGeneric(assNode.left, retArr);
    retArr.push(assNode.operator);
    this.astGeneric(assNode.right, retArr);
    return retArr;
  }

  astBlockStatement(bNode, retArr) {
    if (this.isState('loop-body')) {
      this.pushState('block-body'); 
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      this.popState('block-body');
    } else {
      retArr.push('{\n');
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      retArr.push('}\n');
    }
    return retArr;
  }

  astVariableDeclaration(varDecNode, retArr) {
    retArr.push(`${varDecNode.kind} `);
    const { declarations } = varDecNode;
    for (let i = 0; i < declarations.length; i++) {
      if (i > 0) {
        retArr.push(',');
      }
      const declaration = declarations[i];
      const info = this.getDeclaration(declaration.id);
      if (!info.valueType) {
        info.valueType = this.getType(declaration.init);
      }
      this.astGeneric(declaration, retArr);
    }
    if (!this.isState('in-for-loop-init')) {
      retArr.push(';');
    }
    return retArr;
  }

  astIfStatement(ifNode, retArr) {
    retArr.push('if (');
    this.astGeneric(ifNode.test, retArr);
    retArr.push(')');
    if (ifNode.consequent.type === 'BlockStatement') {
      this.astGeneric(ifNode.consequent, retArr);
    } else {
      retArr.push(' {\n');
      this.astGeneric(ifNode.consequent, retArr);
      retArr.push('\n}\n');
    }

    if (ifNode.alternate) {
      retArr.push('else ');
      if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
        this.astGeneric(ifNode.alternate, retArr);
      } else {
        retArr.push(' {\n');
        this.astGeneric(ifNode.alternate, retArr);
        retArr.push('\n}\n');
      }
    }
    return retArr;

  }

  astSwitchStatement(ast, retArr) {
    const { discriminant, cases } = ast;
    retArr.push('switch (');
    this.astGeneric(discriminant, retArr);
    retArr.push(') {\n');
    for (let i = 0; i < cases.length; i++) {
      if (cases[i].test === null) {
        retArr.push('default:\n');
        this.astGeneric(cases[i].consequent, retArr);
        if (cases[i].consequent && cases[i].consequent.length > 0) {
          retArr.push('break;\n');
        }
        continue;
      }
      retArr.push('case ');
      this.astGeneric(cases[i].test, retArr);
      retArr.push(':\n');
      if (cases[i].consequent && cases[i].consequent.length > 0) {
        this.astGeneric(cases[i].consequent, retArr);
        retArr.push('break;\n');
      }
    }
    retArr.push('\n}');
  }

  astThisExpression(tNode, retArr) {
    retArr.push('_this');
    return retArr;
  }

  astMemberExpression(mNode, retArr) {
    const {
      signature,
      type,
      property,
      xProperty,
      yProperty,
      zProperty,
      name,
      origin
    } = this.getMemberExpressionDetails(mNode);
    switch (signature) {
      case 'this.thread.value':
        retArr.push(`_this.thread.${ name }`);
        return retArr;
      case 'this.output.value':
        switch (name) {
          case 'x':
            retArr.push('outputX');
            break;
          case 'y':
            retArr.push('outputY');
            break;
          case 'z':
            retArr.push('outputZ');
            break;
          default:
            throw this.astErrorOutput('Unexpected expression', mNode);
        }
        return retArr;
      case 'value':
        throw this.astErrorOutput('Unexpected expression', mNode);
      case 'value[]':
      case 'value[][]':
      case 'value[][][]':
      case 'value.value':
        if (origin === 'Math') {
          retArr.push(Math[name]);
          return retArr;
        }
        switch (property) {
          case 'r':
            retArr.push(`user_${ name }[0]`);
            return retArr;
          case 'g':
            retArr.push(`user_${ name }[1]`);
            return retArr;
          case 'b':
            retArr.push(`user_${ name }[2]`);
            return retArr;
          case 'a':
            retArr.push(`user_${ name }[3]`);
            return retArr;
        }
        break;
      case 'this.constants.value':
      case 'this.constants.value[]':
      case 'this.constants.value[][]':
      case 'this.constants.value[][][]':
        break;
      case 'fn()[]':
        this.astGeneric(mNode.object, retArr);
        retArr.push('[');
        this.astGeneric(mNode.property, retArr);
        retArr.push(']');
        return retArr;
      case 'fn()[][]':
        this.astGeneric(mNode.object.object, retArr);
        retArr.push('[');
        this.astGeneric(mNode.object.property, retArr);
        retArr.push(']');
        retArr.push('[');
        this.astGeneric(mNode.property, retArr);
        retArr.push(']');
        return retArr;
      default:
        throw this.astErrorOutput('Unexpected expression', mNode);
    }

    if (!mNode.computed) {
      switch (type) {
        case 'Number':
        case 'Integer':
        case 'Float':
        case 'Boolean':
          retArr.push(`${origin}_${name}`);
          return retArr;
      }
    }

    const markupName = `${origin}_${name}`;

    switch (type) {
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
      case 'HTMLImageArray':
      case 'ArrayTexture(1)':
      case 'ArrayTexture(2)':
      case 'ArrayTexture(3)':
      case 'ArrayTexture(4)':
      case 'HTMLImage':
      default:
        let size;
        let isInput;
        if (origin === 'constants') {
          const constant = this.constants[name];
          isInput = this.constantTypes[name] === 'Input';
          size = isInput ? constant.size : null;
        } else {
          isInput = this.isInput(name);
          size = isInput ? this.argumentSizes[this.argumentNames.indexOf(name)] : null;
        }
        retArr.push(`${ markupName }`);
        if (zProperty && yProperty) {
          if (isInput) {
            retArr.push('[(');
            this.astGeneric(zProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? '(outputY * outputX)' : size[1] * size[0] })+(`);
            this.astGeneric(yProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          } else {
            retArr.push('[');
            this.astGeneric(zProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(yProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          }
        } else if (yProperty) {
          if (isInput) {
            retArr.push('[(');
            this.astGeneric(yProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          } else {
            retArr.push('[');
            this.astGeneric(yProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          }
        } else if (typeof xProperty !== 'undefined') {
          retArr.push('[');
          this.astGeneric(xProperty, retArr);
          retArr.push(']');
        }
    }
    return retArr;
  }

  astCallExpression(ast, retArr) {
    if (ast.type !== 'CallExpression') {
      throw this.astErrorOutput('Unknown CallExpression', ast);
    }
    let functionName = this.astMemberExpressionUnroll(ast.callee);

    if (this.calledFunctions.indexOf(functionName) < 0) {
      this.calledFunctions.push(functionName);
    }

    const isMathFunction = this.isAstMathFunction(ast);

    if (this.onFunctionCall) {
      this.onFunctionCall(this.name, functionName, ast.arguments);
    }

    retArr.push(functionName);

    retArr.push('(');
    const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
    for (let i = 0; i < ast.arguments.length; ++i) {
      const argument = ast.arguments[i];

      let argumentType = this.getType(argument);
      if (!targetTypes[i]) {
        this.triggerImplyArgumentType(functionName, i, argumentType, this);
      }

      if (i > 0) {
        retArr.push(', ');
      }
      this.astGeneric(argument, retArr);
    }
    retArr.push(')');

    return retArr;
  }

  astArrayExpression(arrNode, retArr) {
    const returnType = this.getType(arrNode);
    const arrLen = arrNode.elements.length;
    const elements = [];
    for (let i = 0; i < arrLen; ++i) {
      const element = [];
      this.astGeneric(arrNode.elements[i], element);
      elements.push(element.join(''));
    }
    switch (returnType) {
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        retArr.push(`[${elements.join(', ')}]`);
        break;
      default:
        retArr.push(`new Float32Array([${elements.join(', ')}])`);
    }
    return retArr;
  }

  astDebuggerStatement(arrNode, retArr) {
    retArr.push('debugger;');
    return retArr;
  }
}

module.exports = {
  CPUFunctionNode
};
},{"../function-node":10}],7:[function(require,module,exports){
const { utils } = require('../../utils');

function constantsToString(constants, types) {
  const results = [];
  for (const name in types) {
    if (!types.hasOwnProperty(name)) continue;
    const type = types[name];
    const constant = constants[name];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
        results.push(`${name}:${constant}`);
        break;
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        results.push(`${name}:new ${constant.constructor.name}(${JSON.stringify(Array.from(constant))})`);
        break;
    }
  }
  return `{ ${ results.join() } }`;
}

function cpuKernelString(cpuKernel, name) {
  const header = [];
  const thisProperties = [];
  const beforeReturn = [];

  const useFunctionKeyword = !/^function/.test(cpuKernel.color.toString());

  header.push(
    '  const { context, canvas, constants: incomingConstants } = settings;',
    `  const output = new Int32Array(${JSON.stringify(Array.from(cpuKernel.output))});`,
    `  const _constantTypes = ${JSON.stringify(cpuKernel.constantTypes)};`,
    `  const _constants = ${constantsToString(cpuKernel.constants, cpuKernel.constantTypes)};`
  );

  thisProperties.push(
    '    constants: _constants,',
    '    context,',
    '    output,',
    '    thread: {x: 0, y: 0, z: 0},'
  );

  if (cpuKernel.graphical) {
    header.push(`  const _imageData = context.createImageData(${cpuKernel.output[0]}, ${cpuKernel.output[1]});`);
    header.push(`  const _colorData = new Uint8ClampedArray(${cpuKernel.output[0]} * ${cpuKernel.output[1]} * 4);`);

    const colorFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.color.toString(), {
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case '_colorData':
            return '_colorData';
          case '_imageData':
            return '_imageData';
          case 'output':
            return 'output';
          case 'thread':
            return 'this.thread';
        }
        return JSON.stringify(cpuKernel[propertyName]);
      },
      findDependency: (object, name) => {
        return null;
      }
    });

    const getPixelsFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.getPixels.toString(), {
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case '_colorData':
            return '_colorData';
          case '_imageData':
            return '_imageData';
          case 'output':
            return 'output';
          case 'thread':
            return 'this.thread';
        }
        return JSON.stringify(cpuKernel[propertyName]);
      },
      findDependency: () => {
        return null;
      }
    });

    thisProperties.push(
      '    _imageData,',
      '    _colorData,',
      `    color: ${colorFn},`
    );

    beforeReturn.push(
      `  kernel.getPixels = ${getPixelsFn};`
    );
  }

  const constantTypes = [];
  const constantKeys = Object.keys(cpuKernel.constantTypes);
  for (let i = 0; i < constantKeys.length; i++) {
    constantTypes.push(cpuKernel.constantTypes[constantKeys]);
  }
  if (cpuKernel.argumentTypes.indexOf('HTMLImageArray') !== -1 || constantTypes.indexOf('HTMLImageArray') !== -1) {
    const flattenedImageTo3DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._imageTo3DArray.toString(), {
      doNotDefine: ['canvas'],
      findDependency: (object, name) => {
        if (object === 'this') {
          return (useFunctionKeyword ? 'function ' : '') + cpuKernel[name].toString();
        }
        return null;
      },
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case 'canvas':
            return;
          case 'context':
            return 'context';
        }
      }
    });
    beforeReturn.push(flattenedImageTo3DArray);
    thisProperties.push(`    _mediaTo2DArray,`);
    thisProperties.push(`    _imageTo3DArray,`);
  } else if (cpuKernel.argumentTypes.indexOf('HTMLImage') !== -1 || constantTypes.indexOf('HTMLImage') !== -1) {
    const flattenedImageTo2DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._mediaTo2DArray.toString(), {
      findDependency: (object, name) => {
        return null;
      },
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case 'canvas':
            return 'settings.canvas';
          case 'context':
            return 'settings.context';
        }
        throw new Error('unhandled thisLookup');
      }
    });
    beforeReturn.push(flattenedImageTo2DArray);
    thisProperties.push(`    _mediaTo2DArray,`);
  }

  return `function(settings) {
${ header.join('\n') }
  for (const p in _constantTypes) {
    if (!_constantTypes.hasOwnProperty(p)) continue;
    const type = _constantTypes[p];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        if (incomingConstants.hasOwnProperty(p)) {
          console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');
        }
        continue;
    }
    if (!incomingConstants.hasOwnProperty(p)) {
      throw new Error('constant ' + p + ' not found');
    }
    _constants[p] = incomingConstants[p];
  }
  const kernel = (function() {
${cpuKernel._kernelString}
  })
    .apply({ ${thisProperties.join('\n')} });
  ${ beforeReturn.join('\n') }
  return kernel;
}`;
}

module.exports = {
  cpuKernelString
};
},{"../../utils":114}],8:[function(require,module,exports){
const { Kernel } = require('../kernel');
const { FunctionBuilder } = require('../function-builder');
const { CPUFunctionNode } = require('./function-node');
const { utils } = require('../../utils');
const { cpuKernelString } = require('./kernel-string');

class CPUKernel extends Kernel {
  static getFeatures() {
    return this.features;
  }
  static get features() {
    return Object.freeze({
      kernelMap: true,
      isIntegerDivisionAccurate: true
    });
  }
  static get isSupported() {
    return true;
  }
  static isContextMatch(context) {
    return false;
  }
  static get mode() {
    return 'cpu';
  }

  static nativeFunctionArguments() {
    return null;
  }

  static nativeFunctionReturnType() {
    throw new Error(`Looking up native function return type not supported on ${this.name}`);
  }

  static combineKernels(combinedKernel) {
    return combinedKernel;
  }

  static getSignature(kernel, argumentTypes) {
    return 'cpu' + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
  }

  constructor(source, settings) {
    super(source, settings);
    this.mergeSettings(source.settings || settings);

    this._imageData = null;
    this._colorData = null;
    this._kernelString = null;
    this._prependedString = [];
    this.thread = {
      x: 0,
      y: 0,
      z: 0
    };
    this.translatedSources = null;
  }

  initCanvas() {
    if (typeof document !== 'undefined') {
      return document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      return new OffscreenCanvas(0, 0);
    }
  }

  initContext() {
    if (!this.canvas) return null;
    return this.canvas.getContext('2d');
  }

  initPlugins(settings) {
    return [];
  }

  validateSettings(args) {
    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      if (argType === 'Array') {
        this.output = utils.getDimensions(argType);
      } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
        this.output = args[0].output;
      } else {
        throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }
    }

    this.checkOutput();
  }

  translateSource() {
    this.leadingReturnStatement = this.output.length > 1 ? 'resultX[x] = ' : 'result[x] = ';
    if (this.subKernels) {
      const followingReturnStatement = [];
      for (let i = 0; i < this.subKernels.length; i++) {
        const {
          name
        } = this.subKernels[i];
        followingReturnStatement.push(this.output.length > 1 ? `resultX_${ name }[x] = subKernelResult_${ name };\n` : `result_${ name }[x] = subKernelResult_${ name };\n`);
      }
      this.followingReturnStatement = followingReturnStatement.join('');
    }
    const functionBuilder = FunctionBuilder.fromKernel(this, CPUFunctionNode);
    this.translatedSources = functionBuilder.getPrototypes('kernel');
    if (!this.graphical && !this.returnType) {
      this.returnType = functionBuilder.getKernelResultType();
    }
  }

  build() {
    if (this.built) return;
    this.setupConstants();
    this.setupArguments(arguments);
    this.validateSettings(arguments);
    this.translateSource();

    if (this.graphical) {
      const {
        canvas,
        output
      } = this;
      if (!canvas) {
        throw new Error('no canvas available for using graphical output');
      }
      const width = output[0];
      const height = output[1] || 1;
      canvas.width = width;
      canvas.height = height;
      this._imageData = this.context.createImageData(width, height);
      this._colorData = new Uint8ClampedArray(width * height * 4);
    }

    const kernelString = this.getKernelString();
    this.kernelString = kernelString;

    if (this.debug) {
      console.log('Function output:');
      console.log(kernelString);
    }

    try {
      this.run = new Function([], kernelString).bind(this)();
    } catch (e) {
      console.error('An error occurred compiling the javascript: ', e);
    }
    this.buildSignature(arguments);
    this.built = true;
  }

  color(r, g, b, a) {
    if (typeof a === 'undefined') {
      a = 1;
    }

    r = Math.floor(r * 255);
    g = Math.floor(g * 255);
    b = Math.floor(b * 255);
    a = Math.floor(a * 255);

    const width = this.output[0];
    const height = this.output[1];

    const x = this.thread.x;
    const y = height - this.thread.y - 1;

    const index = x + y * width;

    this._colorData[index * 4 + 0] = r;
    this._colorData[index * 4 + 1] = g;
    this._colorData[index * 4 + 2] = b;
    this._colorData[index * 4 + 3] = a;
  }

  getKernelString() {
    if (this._kernelString !== null) return this._kernelString;

    let kernelThreadString = null;
    let {
      translatedSources
    } = this;
    if (translatedSources.length > 1) {
      translatedSources = translatedSources.filter(fn => {
        if (/^function/.test(fn)) return fn;
        kernelThreadString = fn;
        return false;
      });
    } else {
      kernelThreadString = translatedSources.shift();
    }
    return this._kernelString = `  const LOOP_MAX = ${ this._getLoopMaxString() };
  ${ this.injectedNative || '' }
  const _this = this;
  ${ this._resultKernelHeader() }
  ${ this._processConstants() }
  return (${ this.argumentNames.map(argumentName => 'user_' + argumentName).join(', ') }) => {
    ${ this._prependedString.join('') }
    ${ this._earlyThrows() }
    ${ this._processArguments() }
    ${ this.graphical ? this._graphicalKernelBody(kernelThreadString) : this._resultKernelBody(kernelThreadString) }
    ${ translatedSources.length > 0 ? translatedSources.join('\n') : '' }
  };`;
  }

  toString() {
    return cpuKernelString(this);
  }

  _getLoopMaxString() {
    return (
      this.loopMaxIterations ?
      ` ${ parseInt(this.loopMaxIterations) };` :
      ' 1000;'
    );
  }

  _processConstants() {
    if (!this.constants) return '';

    const result = [];
    for (let p in this.constants) {
      const type = this.constantTypes[p];
      switch (type) {
        case 'HTMLCanvas':
        case 'OffscreenCanvas':
        case 'HTMLImage':
        case 'ImageBitmap':
        case 'ImageData':
        case 'HTMLVideo':
          result.push(`    const constants_${p} = this._mediaTo2DArray(this.constants.${p});\n`);
          break;
        case 'HTMLImageArray':
          result.push(`    const constants_${p} = this._imageTo3DArray(this.constants.${p});\n`);
          break;
        case 'Input':
          result.push(`    const constants_${p} = this.constants.${p}.value;\n`);
          break;
        default:
          result.push(`    const constants_${p} = this.constants.${p};\n`);
      }
    }
    return result.join('');
  }

  _earlyThrows() {
    if (this.graphical) return '';
    if (this.immutable) return '';
    if (!this.pipeline) return '';
    const arrayArguments = [];
    for (let i = 0; i < this.argumentTypes.length; i++) {
      if (this.argumentTypes[i] === 'Array') {
        arrayArguments.push(this.argumentNames[i]);
      }
    }
    if (arrayArguments.length === 0) return '';
    const checks = [];
    for (let i = 0; i < arrayArguments.length; i++) {
      const argumentName = arrayArguments[i];
      const checkSubKernels = this._mapSubKernels(subKernel => `user_${argumentName} === result_${subKernel.name}`).join(' || ');
      checks.push(`user_${argumentName} === result${checkSubKernels ? ` || ${checkSubKernels}` : ''}`);
    }
    return `if (${checks.join(' || ')}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`;
  }

  _processArguments() {
    const result = [];
    for (let i = 0; i < this.argumentTypes.length; i++) {
      const variableName = `user_${this.argumentNames[i]}`;
      switch (this.argumentTypes[i]) {
        case 'HTMLCanvas':
        case 'OffscreenCanvas':
        case 'HTMLImage':
        case 'ImageBitmap':
        case 'ImageData':
        case 'HTMLVideo':
          result.push(`    ${variableName} = this._mediaTo2DArray(${variableName});\n`);
          break;
        case 'HTMLImageArray':
          result.push(`    ${variableName} = this._imageTo3DArray(${variableName});\n`);
          break;
        case 'Input':
          result.push(`    ${variableName} = ${variableName}.value;\n`);
          break;
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
          result.push(`
    if (${variableName}.toArray) {
      if (!_this.textureCache) {
        _this.textureCache = [];
        _this.arrayCache = [];
      }
      const textureIndex = _this.textureCache.indexOf(${variableName});
      if (textureIndex !== -1) {
        ${variableName} = _this.arrayCache[textureIndex];
      } else {
        _this.textureCache.push(${variableName});
        ${variableName} = ${variableName}.toArray();
        _this.arrayCache.push(${variableName});
      }
    }`);
          break;
      }
    }
    return result.join('');
  }

  _mediaTo2DArray(media) {
    const canvas = this.canvas;
    const width = media.width > 0 ? media.width : media.videoWidth;
    const height = media.height > 0 ? media.height : media.videoHeight;
    if (canvas.width < width) {
      canvas.width = width;
    }
    if (canvas.height < height) {
      canvas.height = height;
    }
    const ctx = this.context;
    let pixelsData;
    if (media.constructor === ImageData) {
      pixelsData = media.data;
    } else {
      ctx.drawImage(media, 0, 0, width, height);
      pixelsData = ctx.getImageData(0, 0, width, height).data;
    }
    const imageArray = new Array(height);
    let index = 0;
    for (let y = height - 1; y >= 0; y--) {
      const row = imageArray[y] = new Array(width);
      for (let x = 0; x < width; x++) {
        const pixel = new Float32Array(4);
        pixel[0] = pixelsData[index++] / 255; 
        pixel[1] = pixelsData[index++] / 255; 
        pixel[2] = pixelsData[index++] / 255; 
        pixel[3] = pixelsData[index++] / 255; 
        row[x] = pixel;
      }
    }
    return imageArray;
  }

  getPixels(flip) {
    const [width, height] = this.output;
    return flip ? utils.flipPixels(this._imageData.data, width, height) : this._imageData.data.slice(0);
  }

  _imageTo3DArray(images) {
    const imagesArray = new Array(images.length);
    for (let i = 0; i < images.length; i++) {
      imagesArray[i] = this._mediaTo2DArray(images[i]);
    }
    return imagesArray;
  }

  _resultKernelHeader() {
    if (this.graphical) return '';
    if (this.immutable) return '';
    if (!this.pipeline) return '';
    switch (this.output.length) {
      case 1:
        return this._mutableKernel1DResults();
      case 2:
        return this._mutableKernel2DResults();
      case 3:
        return this._mutableKernel3DResults();
    }
  }

  _resultKernelBody(kernelString) {
    switch (this.output.length) {
      case 1:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel1DLoop(kernelString) : this._resultImmutableKernel1DLoop(kernelString)) + this._kernelOutput();
      case 2:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(kernelString) : this._resultImmutableKernel2DLoop(kernelString)) + this._kernelOutput();
      case 3:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel3DLoop(kernelString) : this._resultImmutableKernel3DLoop(kernelString)) + this._kernelOutput();
      default:
        throw new Error('unsupported size kernel');
    }
  }

  _graphicalKernelBody(kernelThreadString) {
    switch (this.output.length) {
      case 2:
        return this._graphicalKernel2DLoop(kernelThreadString) + this._graphicalOutput();
      default:
        throw new Error('unsupported size kernel');
    }
  }

  _graphicalOutput() {
    return `
    this._imageData.data.set(this._colorData);
    this.context.putImageData(this._imageData, 0, 0);
    return;`
  }

  _getKernelResultTypeConstructorString() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return 'Float32Array';
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        return 'Array';
      default:
        if (this.graphical) {
          return 'Float32Array';
        }
        throw new Error(`unhandled returnType ${ this.returnType }`);
    }
  }

  _resultImmutableKernel1DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const result = new ${constructorString}(outputX);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${ kernelString }
    }`;
  }

  _mutableKernel1DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const result = new ${constructorString}(outputX);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }`;
  }

  _resultMutableKernel1DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${ kernelString }
    }`;
  }

  _resultImmutableKernel2DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y] = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _mutableKernel2DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < outputY; y++) {
      const resultX = result[y] = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
    }`;
  }

  _resultMutableKernel2DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y];
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _graphicalKernel2DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _resultImmutableKernel3DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z] = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }
    }`;
  }

  _mutableKernel3DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let z = 0; z < outputZ; z++) {
      const resultY = result[z] = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
      for (let y = 0; y < outputY; y++) {
        const resultX = resultY[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
      }
    }`;
  }

  _resultMutableKernel3DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z];
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y];
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }
    }`;
  }

  _kernelOutput() {
    if (!this.subKernels) {
      return '\n    return result;';
    }
    return `\n    return {
      result: result,
      ${ this.subKernels.map(subKernel => `${ subKernel.property }: result_${ subKernel.name }`).join(',\n      ') }
    };`;
  }

  _mapSubKernels(fn) {
    return this.subKernels === null ? [''] :
      this.subKernels.map(fn);
  }

  destroy(removeCanvasReference) {
    if (removeCanvasReference) {
      delete this.canvas;
    }
  }

  static destroyContext(context) {}

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, CPUFunctionNode).toJSON();
    return json;
  }

  setOutput(output) {
    super.setOutput(output);
    const [width, height] = this.output;
    if (this.graphical) {
      this._imageData = this.context.createImageData(width, height);
      this._colorData = new Uint8ClampedArray(width * height * 4);
    }
  }

  prependString(value) {
    if (this._kernelString) throw new Error('Kernel already built');
    this._prependedString.push(value);
  }

  hasPrependString(value) {
    return this._prependedString.indexOf(value) > -1;
  }
}

module.exports = {
  CPUKernel
};
},{"../../utils":114,"../function-builder":9,"../kernel":36,"./function-node":6,"./kernel-string":7}],9:[function(require,module,exports){
class FunctionBuilder {
  static fromKernel(kernel, FunctionNode, extraNodeOptions) {
    const {
      kernelArguments,
      kernelConstants,
      argumentNames,
      argumentSizes,
      argumentBitRatios,
      constants,
      constantBitRatios,
      debug,
      loopMaxIterations,
      nativeFunctions,
      output,
      optimizeFloatMemory,
      precision,
      plugins,
      source,
      subKernels,
      functions,
      leadingReturnStatement,
      followingReturnStatement,
      dynamicArguments,
      dynamicOutput,
    } = kernel;

    const argumentTypes = new Array(kernelArguments.length);
    const constantTypes = {};

    for (let i = 0; i < kernelArguments.length; i++) {
      argumentTypes[i] = kernelArguments[i].type;
    }

    for (let i = 0; i < kernelConstants.length; i++) {
      const kernelConstant = kernelConstants[i];
      constantTypes[kernelConstant.name] = kernelConstant.type;
    }

    const needsArgumentType = (functionName, index) => {
      return functionBuilder.needsArgumentType(functionName, index);
    };

    const assignArgumentType = (functionName, index, type) => {
      functionBuilder.assignArgumentType(functionName, index, type);
    };

    const lookupReturnType = (functionName, ast, requestingNode) => {
      return functionBuilder.lookupReturnType(functionName, ast, requestingNode);
    };

    const lookupFunctionArgumentTypes = (functionName) => {
      return functionBuilder.lookupFunctionArgumentTypes(functionName);
    };

    const lookupFunctionArgumentName = (functionName, argumentIndex) => {
      return functionBuilder.lookupFunctionArgumentName(functionName, argumentIndex);
    };

    const lookupFunctionArgumentBitRatio = (functionName, argumentName) => {
      return functionBuilder.lookupFunctionArgumentBitRatio(functionName, argumentName);
    };

    const triggerImplyArgumentType = (functionName, i, argumentType, requestingNode) => {
      functionBuilder.assignArgumentType(functionName, i, argumentType, requestingNode);
    };

    const triggerImplyArgumentBitRatio = (functionName, argumentName, calleeFunctionName, argumentIndex) => {
      functionBuilder.assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex);
    };

    const onFunctionCall = (functionName, calleeFunctionName, args) => {
      functionBuilder.trackFunctionCall(functionName, calleeFunctionName, args);
    };

    const onNestedFunction = (ast, source) => {
      const argumentNames = [];
      for (let i = 0; i < ast.params.length; i++) {
        argumentNames.push(ast.params[i].name);
      }
      const nestedFunction = new FunctionNode(source, Object.assign({}, nodeOptions, {
        returnType: null,
        ast,
        name: ast.id.name,
        argumentNames,
        lookupReturnType,
        lookupFunctionArgumentTypes,
        lookupFunctionArgumentName,
        lookupFunctionArgumentBitRatio,
        needsArgumentType,
        assignArgumentType,
        triggerImplyArgumentType,
        triggerImplyArgumentBitRatio,
        onFunctionCall,
      }));
      nestedFunction.traceFunctionAST(ast);
      functionBuilder.addFunctionNode(nestedFunction);
    };

    const nodeOptions = Object.assign({
      isRootKernel: false,
      onNestedFunction,
      lookupReturnType,
      lookupFunctionArgumentTypes,
      lookupFunctionArgumentName,
      lookupFunctionArgumentBitRatio,
      needsArgumentType,
      assignArgumentType,
      triggerImplyArgumentType,
      triggerImplyArgumentBitRatio,
      onFunctionCall,
      optimizeFloatMemory,
      precision,
      constants,
      constantTypes,
      constantBitRatios,
      debug,
      loopMaxIterations,
      output,
      plugins,
      dynamicArguments,
      dynamicOutput,
    }, extraNodeOptions || {});

    const rootNodeOptions = Object.assign({}, nodeOptions, {
      isRootKernel: true,
      name: 'kernel',
      argumentNames,
      argumentTypes,
      argumentSizes,
      argumentBitRatios,
      leadingReturnStatement,
      followingReturnStatement,
    });

    if (typeof source === 'object' && source.functionNodes) {
      return new FunctionBuilder().fromJSON(source.functionNodes, FunctionNode);
    }

    const rootNode = new FunctionNode(source, rootNodeOptions);

    let functionNodes = null;
    if (functions) {
      functionNodes = functions.map((fn) => new FunctionNode(fn.source, {
        returnType: fn.returnType,
        argumentTypes: fn.argumentTypes,
        output,
        plugins,
        constants,
        constantTypes,
        constantBitRatios,
        optimizeFloatMemory,
        precision,
        lookupReturnType,
        lookupFunctionArgumentTypes,
        lookupFunctionArgumentName,
        lookupFunctionArgumentBitRatio,
        needsArgumentType,
        assignArgumentType,
        triggerImplyArgumentType,
        triggerImplyArgumentBitRatio,
        onFunctionCall,
        onNestedFunction,
      }));
    }

    let subKernelNodes = null;
    if (subKernels) {
      subKernelNodes = subKernels.map((subKernel) => {
        const { name, source } = subKernel;
        return new FunctionNode(source, Object.assign({}, nodeOptions, {
          name,
          isSubKernel: true,
          isRootKernel: false,
        }));
      });
    }

    const functionBuilder = new FunctionBuilder({
      kernel,
      rootNode,
      functionNodes,
      nativeFunctions,
      subKernelNodes
    });

    return functionBuilder;
  }

  constructor(settings) {
    settings = settings || {};
    this.kernel = settings.kernel;
    this.rootNode = settings.rootNode;
    this.functionNodes = settings.functionNodes || [];
    this.subKernelNodes = settings.subKernelNodes || [];
    this.nativeFunctions = settings.nativeFunctions || [];
    this.functionMap = {};
    this.nativeFunctionNames = [];
    this.lookupChain = [];
    this.functionNodeDependencies = {};
    this.functionCalls = {};

    if (this.rootNode) {
      this.functionMap['kernel'] = this.rootNode;
    }

    if (this.functionNodes) {
      for (let i = 0; i < this.functionNodes.length; i++) {
        this.functionMap[this.functionNodes[i].name] = this.functionNodes[i];
      }
    }

    if (this.subKernelNodes) {
      for (let i = 0; i < this.subKernelNodes.length; i++) {
        this.functionMap[this.subKernelNodes[i].name] = this.subKernelNodes[i];
      }
    }

    if (this.nativeFunctions) {
      for (let i = 0; i < this.nativeFunctions.length; i++) {
        const nativeFunction = this.nativeFunctions[i];
        this.nativeFunctionNames.push(nativeFunction.name);
      }
    }
  }

  addFunctionNode(functionNode) {
    if (!functionNode.name) throw new Error('functionNode.name needs set');
    this.functionMap[functionNode.name] = functionNode;
    if (functionNode.isRootKernel) {
      this.rootNode = functionNode;
    }
  }

  traceFunctionCalls(functionName, retList) {
    functionName = functionName || 'kernel';
    retList = retList || [];

    if (this.nativeFunctionNames.indexOf(functionName) > -1) {
      const nativeFunctionIndex = retList.indexOf(functionName);
      if (nativeFunctionIndex === -1) {
        retList.push(functionName);
      } else {
        const dependantNativeFunctionName = retList.splice(nativeFunctionIndex, 1)[0];
        retList.push(dependantNativeFunctionName);
      }
      return retList;
    }

    const functionNode = this.functionMap[functionName];
    if (functionNode) {
      const functionIndex = retList.indexOf(functionName);
      if (functionIndex === -1) {
        retList.push(functionName);
        functionNode.toString(); 
        for (let i = 0; i < functionNode.calledFunctions.length; ++i) {
          this.traceFunctionCalls(functionNode.calledFunctions[i], retList);
        }
      } else {
        const dependantFunctionName = retList.splice(functionIndex, 1)[0];
        retList.push(dependantFunctionName);
      }
    }

    return retList;
  }

  getPrototypeString(functionName) {
    return this.getPrototypes(functionName).join('\n');
  }

  getPrototypes(functionName) {
    if (this.rootNode) {
      this.rootNode.toString();
    }
    if (functionName) {
      return this.getPrototypesFromFunctionNames(this.traceFunctionCalls(functionName, []).reverse());
    }
    return this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));
  }

  getStringFromFunctionNames(functionList) {
    const ret = [];
    for (let i = 0; i < functionList.length; ++i) {
      const node = this.functionMap[functionList[i]];
      if (node) {
        ret.push(this.functionMap[functionList[i]].toString());
      }
    }
    return ret.join('\n');
  }

  getPrototypesFromFunctionNames(functionList) {
    const ret = [];
    for (let i = 0; i < functionList.length; ++i) {
      const functionName = functionList[i];
      const functionIndex = this.nativeFunctionNames.indexOf(functionName);
      if (functionIndex > -1) {
        ret.push(this.nativeFunctions[functionIndex].source);
        continue;
      }
      const node = this.functionMap[functionName];
      if (node) {
        ret.push(node.toString());
      }
    }
    return ret;
  }

  toJSON() {
    return this.traceFunctionCalls(this.rootNode.name).reverse().map(name => {
      const nativeIndex = this.nativeFunctions.indexOf(name);
      if (nativeIndex > -1) {
        return {
          name,
          source: this.nativeFunctions[nativeIndex].source
        };
      } else if (this.functionMap[name]) {
        return this.functionMap[name].toJSON();
      } else {
        throw new Error(`function ${ name } not found`);
      }
    });
  }

  fromJSON(jsonFunctionNodes, FunctionNode) {
    this.functionMap = {};
    for (let i = 0; i < jsonFunctionNodes.length; i++) {
      const jsonFunctionNode = jsonFunctionNodes[i];
      this.functionMap[jsonFunctionNode.settings.name] = new FunctionNode(jsonFunctionNode.ast, jsonFunctionNode.settings);
    }
    return this;
  }

  getString(functionName) {
    if (functionName) {
      return this.getStringFromFunctionNames(this.traceFunctionCalls(functionName).reverse());
    }
    return this.getStringFromFunctionNames(Object.keys(this.functionMap));
  }

  lookupReturnType(functionName, ast, requestingNode) {
    if (ast.type !== 'CallExpression') {
      throw new Error(`expected ast type of "CallExpression", but is ${ ast.type }`);
    }
    if (this._isNativeFunction(functionName)) {
      return this._lookupNativeFunctionReturnType(functionName);
    } else if (this._isFunction(functionName)) {
      const node = this._getFunction(functionName);
      if (node.returnType) {
        return node.returnType;
      } else {
        for (let i = 0; i < this.lookupChain.length; i++) {
          if (this.lookupChain[i].ast === ast) {
            if (node.argumentTypes.length === 0 && ast.arguments.length > 0) {
              const args = ast.arguments;
              for (let j = 0; j < args.length; j++) {
                this.lookupChain.push({
                  name: requestingNode.name,
                  ast: args[i],
                  requestingNode
                });
                node.argumentTypes[j] = requestingNode.getType(args[j]);
                this.lookupChain.pop();
              }
              return node.returnType = node.getType(node.getJsAST());
            }

            throw new Error('circlical logic detected!');
          }
        }
        this.lookupChain.push({
          name: requestingNode.name,
          ast,
          requestingNode
        });
        const type = node.getType(node.getJsAST());
        this.lookupChain.pop();
        return node.returnType = type;
      }
    }

    return null;
  }

  _getFunction(functionName) {
    if (!this._isFunction(functionName)) {
      new Error(`Function ${functionName} not found`);
    }
    return this.functionMap[functionName];
  }

  _isFunction(functionName) {
    return Boolean(this.functionMap[functionName]);
  }

  _getNativeFunction(functionName) {
    for (let i = 0; i < this.nativeFunctions.length; i++) {
      if (this.nativeFunctions[i].name === functionName) return this.nativeFunctions[i];
    }
    return null;
  }

  _isNativeFunction(functionName) {
    return Boolean(this._getNativeFunction(functionName));
  }

  _lookupNativeFunctionReturnType(functionName) {
    let nativeFunction = this._getNativeFunction(functionName);
    if (nativeFunction) {
      return nativeFunction.returnType;
    }
    throw new Error(`Native function ${ functionName } not found`);
  }

  lookupFunctionArgumentTypes(functionName) {
    if (this._isNativeFunction(functionName)) {
      return this._getNativeFunction(functionName).argumentTypes;
    } else if (this._isFunction(functionName)) {
      return this._getFunction(functionName).argumentTypes;
    }
    return null;
  }

  lookupFunctionArgumentName(functionName, argumentIndex) {
    return this._getFunction(functionName).argumentNames[argumentIndex];
  }

  lookupFunctionArgumentBitRatio(functionName, argumentName) {
    if (!this._isFunction(functionName)) {
      throw new Error('function not found');
    }
    if (this.rootNode.name === functionName) {
      const i = this.rootNode.argumentNames.indexOf(argumentName);
      if (i !== -1) {
        return this.rootNode.argumentBitRatios[i];
      }
    }
    const node = this._getFunction(functionName);
    const i = node.argumentNames.indexOf(argumentName);
    if (i === -1) {
      throw new Error('argument not found');
    }
    const bitRatio = node.argumentBitRatios[i];
    if (typeof bitRatio !== 'number') {
      throw new Error('argument bit ratio not found');
    }
    return bitRatio;
  }

  needsArgumentType(functionName, i) {
    if (!this._isFunction(functionName)) return false;
    const fnNode = this._getFunction(functionName);
    return !fnNode.argumentTypes[i];
  }

  assignArgumentType(functionName, i, argumentType, requestingNode) {
    if (!this._isFunction(functionName)) return;
    const fnNode = this._getFunction(functionName);
    if (!fnNode.argumentTypes[i]) {
      fnNode.argumentTypes[i] = argumentType;
    }
  }

  assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex) {
    const node = this._getFunction(functionName);
    if (this._isNativeFunction(calleeFunctionName)) return null;
    const calleeNode = this._getFunction(calleeFunctionName);
    const i = node.argumentNames.indexOf(argumentName);
    if (i === -1) {
      throw new Error(`Argument ${argumentName} not found in arguments from function ${functionName}`);
    }
    const bitRatio = node.argumentBitRatios[i];
    if (typeof bitRatio !== 'number') {
      throw new Error(`Bit ratio for argument ${argumentName} not found in function ${functionName}`);
    }
    if (!calleeNode.argumentBitRatios) {
      calleeNode.argumentBitRatios = new Array(calleeNode.argumentNames.length);
    }
    const calleeBitRatio = calleeNode.argumentBitRatios[i];
    if (typeof calleeBitRatio === 'number') {
      if (calleeBitRatio !== bitRatio) {
        throw new Error(`Incompatible bit ratio found at function ${functionName} at argument ${argumentName}`);
      }
      return calleeBitRatio;
    }
    calleeNode.argumentBitRatios[i] = bitRatio;
    return bitRatio;
  }

  trackFunctionCall(functionName, calleeFunctionName, args) {
    if (!this.functionNodeDependencies[functionName]) {
      this.functionNodeDependencies[functionName] = new Set();
      this.functionCalls[functionName] = [];
    }
    this.functionNodeDependencies[functionName].add(calleeFunctionName);
    this.functionCalls[functionName].push(args);
  }

  getKernelResultType() {
    return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);
  }

  getSubKernelResultType(index) {
    const subKernelNode = this.subKernelNodes[index];
    let called = false;
    for (let functionCallIndex = 0; functionCallIndex < this.rootNode.functionCalls.length; functionCallIndex++) {
      const functionCall = this.rootNode.functionCalls[functionCallIndex];
      if (functionCall.ast.callee.name === subKernelNode.name) {
        called = true;
      }
    }
    if (!called) {
      throw new Error(`SubKernel ${ subKernelNode.name } never called by kernel`);
    }
    return subKernelNode.returnType || subKernelNode.getType(subKernelNode.getJsAST());
  }

  getReturnTypes() {
    const result = {
      [this.rootNode.name]: this.rootNode.getType(this.rootNode.ast),
    };
    const list = this.traceFunctionCalls(this.rootNode.name);
    for (let i = 0; i < list.length; i++) {
      const functionName = list[i];
      const functionNode = this.functionMap[functionName];
      result[functionName] = functionNode.getType(functionNode.ast);
    }
    return result;
  }
}

module.exports = {
  FunctionBuilder
};
},{}],10:[function(require,module,exports){
const acorn = require('acorn');
const { utils } = require('../utils');
const { FunctionTracer } = require('./function-tracer');

class FunctionNode {
  constructor(source, settings) {
    if (!source && !settings.ast) {
      throw new Error('source parameter is missing');
    }
    settings = settings || {};
    this.source = source;
    this.ast = null;
    this.name = typeof source === 'string' ? settings.isRootKernel ?
      'kernel' :
      (settings.name || utils.getFunctionNameFromString(source)) : null;
    this.calledFunctions = [];
    this.constants = {};
    this.constantTypes = {};
    this.constantBitRatios = {};
    this.isRootKernel = false;
    this.isSubKernel = false;
    this.debug = null;
    this.functions = null;
    this.identifiers = null;
    this.contexts = null;
    this.functionCalls = null;
    this.states = [];
    this.needsArgumentType = null;
    this.assignArgumentType = null;
    this.lookupReturnType = null;
    this.lookupFunctionArgumentTypes = null;
    this.lookupFunctionArgumentBitRatio = null;
    this.triggerImplyArgumentType = null;
    this.triggerImplyArgumentBitRatio = null;
    this.onNestedFunction = null;
    this.onFunctionCall = null;
    this.optimizeFloatMemory = null;
    this.precision = null;
    this.loopMaxIterations = null;
    this.argumentNames = (typeof this.source === 'string' ? utils.getArgumentNamesFromString(this.source) : null);
    this.argumentTypes = [];
    this.argumentSizes = [];
    this.argumentBitRatios = null;
    this.returnType = null;
    this.output = [];
    this.plugins = null;
    this.leadingReturnStatement = null;
    this.followingReturnStatement = null;
    this.dynamicOutput = null;
    this.dynamicArguments = null;
    this.strictTypingChecking = false;
    this.fixIntegerDivisionAccuracy = null;

    if (settings) {
      for (const p in settings) {
        if (!settings.hasOwnProperty(p)) continue;
        if (!this.hasOwnProperty(p)) continue;
        this[p] = settings[p];
      }
    }

    this.literalTypes = {};

    this.validate();
    this._string = null;
    this._internalVariableNames = {};
  }

  validate() {
    if (typeof this.source !== 'string' && !this.ast) {
      throw new Error('this.source not a string');
    }

    if (!this.ast && !utils.isFunctionString(this.source)) {
      throw new Error('this.source not a function string');
    }

    if (!this.name) {
      throw new Error('this.name could not be set');
    }

    if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) {
      throw new Error(`argumentTypes count of ${ this.argumentTypes.length } exceeds ${ this.argumentNames.length }`);
    }

    if (this.output.length < 1) {
      throw new Error('this.output is not big enough');
    }
  }

  isIdentifierConstant(name) {
    if (!this.constants) return false;
    return this.constants.hasOwnProperty(name);
  }

  isInput(argumentName) {
    return this.argumentTypes[this.argumentNames.indexOf(argumentName)] === 'Input';
  }

  pushState(state) {
    this.states.push(state);
  }

  popState(state) {
    if (this.state !== state) {
      throw new Error(`Cannot popState ${ state } when in ${ this.state }`);
    }
    this.states.pop();
  }

  isState(state) {
    return this.state === state;
  }

  get state() {
    return this.states[this.states.length - 1];
  }

  astMemberExpressionUnroll(ast) {
    if (ast.type === 'Identifier') {
      return ast.name;
    } else if (ast.type === 'ThisExpression') {
      return 'this';
    }

    if (ast.type === 'MemberExpression') {
      if (ast.object && ast.property) {
        if (ast.object.hasOwnProperty('name') && ast.object.name !== 'Math') {
          return this.astMemberExpressionUnroll(ast.property);
        }

        return (
          this.astMemberExpressionUnroll(ast.object) +
          '.' +
          this.astMemberExpressionUnroll(ast.property)
        );
      }
    }

    if (ast.hasOwnProperty('expressions')) {
      const firstExpression = ast.expressions[0];
      if (firstExpression.type === 'Literal' && firstExpression.value === 0 && ast.expressions.length === 2) {
        return this.astMemberExpressionUnroll(ast.expressions[1]);
      }
    }

    throw this.astErrorOutput('Unknown astMemberExpressionUnroll', ast);
  }

  getJsAST(inParser) {
    if (this.ast) {
      return this.ast;
    }
    if (typeof this.source === 'object') {
      this.traceFunctionAST(this.source);
      return this.ast = this.source;
    }

    inParser = inParser || acorn;
    if (inParser === null) {
      throw new Error('Missing JS to AST parser');
    }

    const ast = Object.freeze(inParser.parse(`const parser_${ this.name } = ${ this.source };`, {
      locations: true
    }));
    const functionAST = ast.body[0].declarations[0].init;
    this.traceFunctionAST(functionAST);

    if (!ast) {
      throw new Error('Failed to parse JS code');
    }

    return this.ast = functionAST;
  }

  traceFunctionAST(ast) {
    const { contexts, declarations, functions, identifiers, functionCalls } = new FunctionTracer(ast);
    this.contexts = contexts;
    this.identifiers = identifiers;
    this.functionCalls = functionCalls;
    this.functions = functions;
    for (let i = 0; i < declarations.length; i++) {
      const declaration = declarations[i];
      const { ast, inForLoopInit, inForLoopTest } = declaration;
      const { init } = ast;
      const dependencies = this.getDependencies(init);
      let valueType = null;

      if (inForLoopInit && inForLoopTest) {
        valueType = 'Integer';
      } else {
        if (init) {
          const realType = this.getType(init);
          switch (realType) {
            case 'Integer':
            case 'Float':
            case 'Number':
              if (init.type === 'MemberExpression') {
                valueType = realType;
              } else {
                valueType = 'Number';
              }
              break;
            case 'LiteralInteger':
              valueType = 'Number';
              break;
            default:
              valueType = realType;
          }
        }
      }
      declaration.valueType = valueType;
      declaration.dependencies = dependencies;
      declaration.isSafe = this.isSafeDependencies(dependencies);
    }

    for (let i = 0; i < functions.length; i++) {
      this.onNestedFunction(functions[i], this.source);
    }
  }

  getDeclaration(ast) {
    for (let i = 0; i < this.identifiers.length; i++) {
      const identifier = this.identifiers[i];
      if (ast === identifier.ast) {
        return identifier.declaration;
      }
    }
    return null;
  }

  getVariableType(ast) {
    if (ast.type !== 'Identifier') {
      throw new Error(`ast of ${ast.type} not "Identifier"`);
    }
    let type = null;
    const argumentIndex = this.argumentNames.indexOf(ast.name);
    if (argumentIndex === -1) {
      const declaration = this.getDeclaration(ast);
      if (declaration) {
        return declaration.valueType;
      }
    } else {
      const argumentType = this.argumentTypes[argumentIndex];
      if (argumentType) {
        type = argumentType;
      }
    }
    if (!type && this.strictTypingChecking) {
      throw new Error(`Declaration of ${name} not found`);
    }
    return type;
  }

  getLookupType(type) {
    if (!typeLookupMap.hasOwnProperty(type)) {
      throw new Error(`unknown typeLookupMap ${ type }`);
    }
    return typeLookupMap[type];
  }

  getConstantType(constantName) {
    if (this.constantTypes[constantName]) {
      const type = this.constantTypes[constantName];
      if (type === 'Float') {
        return 'Number';
      } else {
        return type;
      }
    }
    throw new Error(`Type for constant "${ constantName }" not declared`);
  }

  toString() {
    if (this._string) return this._string;
    return this._string = this.astGeneric(this.getJsAST(), []).join('').trim();
  }

  toJSON() {
    const settings = {
      source: this.source,
      name: this.name,
      constants: this.constants,
      constantTypes: this.constantTypes,
      isRootKernel: this.isRootKernel,
      isSubKernel: this.isSubKernel,
      debug: this.debug,
      output: this.output,
      loopMaxIterations: this.loopMaxIterations,
      argumentNames: this.argumentNames,
      argumentTypes: this.argumentTypes,
      argumentSizes: this.argumentSizes,
      returnType: this.returnType,
      leadingReturnStatement: this.leadingReturnStatement,
      followingReturnStatement: this.followingReturnStatement,
    };

    return {
      ast: this.ast,
      settings
    };
  }

  getType(ast) {
    if (Array.isArray(ast)) {
      return this.getType(ast[ast.length - 1]);
    }
    switch (ast.type) {
      case 'BlockStatement':
        return this.getType(ast.body);
      case 'ArrayExpression':
        const childType = this.getType(ast.elements[0]);
        switch (childType) {
          case 'Array(2)':
          case 'Array(3)':
          case 'Array(4)':
            return `Matrix(${ast.elements.length})`;
        }
        return `Array(${ ast.elements.length })`;
      case 'Literal':
        const literalKey = this.astKey(ast);
        if (this.literalTypes[literalKey]) {
          return this.literalTypes[literalKey];
        }
        if (Number.isInteger(ast.value)) {
          return 'LiteralInteger';
        } else if (ast.value === true || ast.value === false) {
          return 'Boolean';
        } else {
          return 'Number';
        }
        case 'AssignmentExpression':
          return this.getType(ast.left);
        case 'CallExpression':
          if (this.isAstMathFunction(ast)) {
            return 'Number';
          }
          if (!ast.callee || !ast.callee.name) {
            if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[ast.callee.expressions.length - 1].property.name) {
              const functionName = ast.callee.expressions[ast.callee.expressions.length - 1].property.name;
              this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
              return this.lookupReturnType(functionName, ast, this);
            }
            if (this.getVariableSignature(ast.callee, true) === 'this.color') {
              return null;
            }
            if (ast.callee.type === 'MemberExpression' && ast.callee.object && ast.callee.property && ast.callee.property.name && ast.arguments) {
              const functionName = ast.callee.property.name;
              this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
              return this.lookupReturnType(functionName, ast, this);
            }
            throw this.astErrorOutput('Unknown call expression', ast);
          }
          if (ast.callee && ast.callee.name) {
            const functionName = ast.callee.name;
            this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
            return this.lookupReturnType(functionName, ast, this);
          }
          throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
        case 'LogicalExpression':
          return 'Boolean';
        case 'BinaryExpression':
          switch (ast.operator) {
            case '%':
            case '/':
              if (this.fixIntegerDivisionAccuracy) {
                return 'Number';
              } else {
                break;
              }
              case '>':
              case '<':
                return 'Boolean';
              case '&':
              case '|':
              case '^':
              case '<<':
              case '>>':
              case '>>>':
                return 'Integer';
          }
          const type = this.getType(ast.left);
          if (this.isState('skip-literal-correction')) return type;
          if (type === 'LiteralInteger') {
            const rightType = this.getType(ast.right);
            if (rightType === 'LiteralInteger') {
              if (ast.left.value % 1 === 0) {
                return 'Integer';
              } else {
                return 'Float';
              }
            }
            return rightType;
          }
          return typeLookupMap[type] || type;
        case 'UpdateExpression':
          return this.getType(ast.argument);
        case 'UnaryExpression':
          if (ast.operator === '~') {
            return 'Integer';
          }
          return this.getType(ast.argument);
        case 'VariableDeclaration': {
          const declarations = ast.declarations;
          let lastType;
          for (let i = 0; i < declarations.length; i++) {
            const declaration = declarations[i];
            lastType = this.getType(declaration);
          }
          if (!lastType) {
            throw this.astErrorOutput(`Unable to find type for declaration`, ast);
          }
          return lastType;
        }
        case 'VariableDeclarator':
          const declaration = this.getDeclaration(ast.id);
          if (!declaration) {
            throw this.astErrorOutput(`Unable to find declarator`, ast);
          }

          if (!declaration.valueType) {
            throw this.astErrorOutput(`Unable to find declarator valueType`, ast);
          }

          return declaration.valueType;
        case 'Identifier':
          if (ast.name === 'Infinity') {
            return 'Number';
          }
          if (this.isAstVariable(ast)) {
            const signature = this.getVariableSignature(ast);
            if (signature === 'value') {
              return this.getCheckVariableType(ast);
            }
          }
          const origin = this.findIdentifierOrigin(ast);
          if (origin && origin.init) {
            return this.getType(origin.init);
          }
          return null;
        case 'ReturnStatement':
          return this.getType(ast.argument);
        case 'MemberExpression':
          if (this.isAstMathFunction(ast)) {
            switch (ast.property.name) {
              case 'ceil':
                return 'Integer';
              case 'floor':
                return 'Integer';
              case 'round':
                return 'Integer';
            }
            return 'Number';
          }
          if (this.isAstVariable(ast)) {
            const variableSignature = this.getVariableSignature(ast);
            switch (variableSignature) {
              case 'value[]':
                return this.getLookupType(this.getCheckVariableType(ast.object));
              case 'value[][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object));
              case 'value[][][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object.object));
              case 'value[][][][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object.object.object));
              case 'value.thread.value':
              case 'this.thread.value':
                return 'Integer';
              case 'this.output.value':
                return this.dynamicOutput ? 'Integer' : 'LiteralInteger';
              case 'this.constants.value':
                return this.getConstantType(ast.property.name);
              case 'this.constants.value[]':
                return this.getLookupType(this.getConstantType(ast.object.property.name));
              case 'this.constants.value[][]':
                return this.getLookupType(this.getConstantType(ast.object.object.property.name));
              case 'this.constants.value[][][]':
                return this.getLookupType(this.getConstantType(ast.object.object.object.property.name));
              case 'this.constants.value[][][][]':
                return this.getLookupType(this.getConstantType(ast.object.object.object.object.property.name));
              case 'fn()[]':
              case 'fn()[][]':
              case 'fn()[][][]':
                return this.getLookupType(this.getType(ast.object));
              case 'value.value':
                if (this.isAstMathVariable(ast)) {
                  return 'Number';
                }
                switch (ast.property.name) {
                  case 'r':
                  case 'g':
                  case 'b':
                  case 'a':
                    return this.getLookupType(this.getCheckVariableType(ast.object));
                }
                case '[][]':
                  return 'Number';
            }
            throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
          }
          throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
        case 'ConditionalExpression':
          return this.getType(ast.consequent);
        case 'FunctionDeclaration':
        case 'FunctionExpression':
          const lastReturn = this.findLastReturn(ast.body);
          if (lastReturn) {
            return this.getType(lastReturn);
          }
          return null;
        case 'IfStatement':
          return this.getType(ast.consequent);
        case 'SequenceExpression':
          return this.getType(ast.expressions[ast.expressions.length - 1]);
        default:
          throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
    }
  }

  getCheckVariableType(ast) {
    const type = this.getVariableType(ast);
    if (!type) {
      throw this.astErrorOutput(`${ast.type} is not defined`, ast);
    }
    return type;
  }

  inferArgumentTypesIfNeeded(functionName, args) {
    for (let i = 0; i < args.length; i++) {
      if (!this.needsArgumentType(functionName, i)) continue;
      const type = this.getType(args[i]);
      if (!type) {
        throw this.astErrorOutput(`Unable to infer argument ${i}`, args[i]);
      }
      this.assignArgumentType(functionName, i, type);
    }
  }

  isAstMathVariable(ast) {
    const mathProperties = [
      'E',
      'PI',
      'SQRT2',
      'SQRT1_2',
      'LN2',
      'LN10',
      'LOG2E',
      'LOG10E',
    ];
    return ast.type === 'MemberExpression' &&
      ast.object && ast.object.type === 'Identifier' &&
      ast.object.name === 'Math' &&
      ast.property &&
      ast.property.type === 'Identifier' &&
      mathProperties.indexOf(ast.property.name) > -1;
  }

  isAstMathFunction(ast) {
    const mathFunctions = [
      'abs',
      'acos',
      'acosh',
      'asin',
      'asinh',
      'atan',
      'atan2',
      'atanh',
      'cbrt',
      'ceil',
      'clz32',
      'cos',
      'cosh',
      'expm1',
      'exp',
      'floor',
      'fround',
      'imul',
      'log',
      'log2',
      'log10',
      'log1p',
      'max',
      'min',
      'pow',
      'random',
      'round',
      'sign',
      'sin',
      'sinh',
      'sqrt',
      'tan',
      'tanh',
      'trunc',
    ];
    return ast.type === 'CallExpression' &&
      ast.callee &&
      ast.callee.type === 'MemberExpression' &&
      ast.callee.object &&
      ast.callee.object.type === 'Identifier' &&
      ast.callee.object.name === 'Math' &&
      ast.callee.property &&
      ast.callee.property.type === 'Identifier' &&
      mathFunctions.indexOf(ast.callee.property.name) > -1;
  }

  isAstVariable(ast) {
    return ast.type === 'Identifier' || ast.type === 'MemberExpression';
  }

  isSafe(ast) {
    return this.isSafeDependencies(this.getDependencies(ast));
  }

  isSafeDependencies(dependencies) {
    return dependencies && dependencies.every ? dependencies.every(dependency => dependency.isSafe) : true;
  }

  getDependencies(ast, dependencies, isNotSafe) {
    if (!dependencies) {
      dependencies = [];
    }
    if (!ast) return null;
    if (Array.isArray(ast)) {
      for (let i = 0; i < ast.length; i++) {
        this.getDependencies(ast[i], dependencies, isNotSafe);
      }
      return dependencies;
    }
    switch (ast.type) {
      case 'AssignmentExpression':
        this.getDependencies(ast.left, dependencies, isNotSafe);
        this.getDependencies(ast.right, dependencies, isNotSafe);
        return dependencies;
      case 'ConditionalExpression':
        this.getDependencies(ast.test, dependencies, isNotSafe);
        this.getDependencies(ast.alternate, dependencies, isNotSafe);
        this.getDependencies(ast.consequent, dependencies, isNotSafe);
        return dependencies;
      case 'Literal':
        dependencies.push({
          origin: 'literal',
          value: ast.value,
          isSafe: isNotSafe === true ? false : ast.value > -Infinity && ast.value < Infinity && !isNaN(ast.value)
        });
        break;
      case 'VariableDeclarator':
        return this.getDependencies(ast.init, dependencies, isNotSafe);
      case 'Identifier':
        const declaration = this.getDeclaration(ast);
        if (declaration) {
          dependencies.push({
            name: ast.name,
            origin: 'declaration',
            isSafe: isNotSafe ? false : this.isSafeDependencies(declaration.dependencies),
          });
        } else if (this.argumentNames.indexOf(ast.name) > -1) {
          dependencies.push({
            name: ast.name,
            origin: 'argument',
            isSafe: false,
          });
        } else if (this.strictTypingChecking) {
          throw new Error(`Cannot find identifier origin "${ast.name}"`);
        }
        break;
      case 'FunctionDeclaration':
        return this.getDependencies(ast.body.body[ast.body.body.length - 1], dependencies, isNotSafe);
      case 'ReturnStatement':
        return this.getDependencies(ast.argument, dependencies);
      case 'BinaryExpression':
      case 'LogicalExpression':
        isNotSafe = (ast.operator === '/' || ast.operator === '*');
        this.getDependencies(ast.left, dependencies, isNotSafe);
        this.getDependencies(ast.right, dependencies, isNotSafe);
        return dependencies;
      case 'UnaryExpression':
      case 'UpdateExpression':
        return this.getDependencies(ast.argument, dependencies, isNotSafe);
      case 'VariableDeclaration':
        return this.getDependencies(ast.declarations, dependencies, isNotSafe);
      case 'ArrayExpression':
        dependencies.push({
          origin: 'declaration',
          isSafe: true,
        });
        return dependencies;
      case 'CallExpression':
        dependencies.push({
          origin: 'function',
          isSafe: true,
        });
        return dependencies;
      case 'MemberExpression':
        const details = this.getMemberExpressionDetails(ast);
        switch (details.signature) {
          case 'value[]':
            this.getDependencies(ast.object, dependencies, isNotSafe);
            break;
          case 'value[][]':
            this.getDependencies(ast.object.object, dependencies, isNotSafe);
            break;
          case 'value[][][]':
            this.getDependencies(ast.object.object.object, dependencies, isNotSafe);
            break;
          case 'this.output.value':
            if (this.dynamicOutput) {
              dependencies.push({
                name: details.name,
                origin: 'output',
                isSafe: false,
              });
            }
            break;
        }
        if (details) {
          if (details.property) {
            this.getDependencies(details.property, dependencies, isNotSafe);
          }
          if (details.xProperty) {
            this.getDependencies(details.xProperty, dependencies, isNotSafe);
          }
          if (details.yProperty) {
            this.getDependencies(details.yProperty, dependencies, isNotSafe);
          }
          if (details.zProperty) {
            this.getDependencies(details.zProperty, dependencies, isNotSafe);
          }
          return dependencies;
        }
        case 'SequenceExpression':
          return this.getDependencies(ast.expressions, dependencies, isNotSafe);
        default:
          throw this.astErrorOutput(`Unhandled type ${ ast.type } in getDependencies`, ast);
    }
    return dependencies;
  }

  getVariableSignature(ast, returnRawValue) {
    if (!this.isAstVariable(ast)) {
      throw new Error(`ast of type "${ ast.type }" is not a variable signature`);
    }
    if (ast.type === 'Identifier') {
      return 'value';
    }
    const signature = [];
    while (true) {
      if (!ast) break;
      if (ast.computed) {
        signature.push('[]');
      } else if (ast.type === 'ThisExpression') {
        signature.unshift('this');
      } else if (ast.property && ast.property.name) {
        if (
          ast.property.name === 'x' ||
          ast.property.name === 'y' ||
          ast.property.name === 'z'
        ) {
          signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
        } else if (
          ast.property.name === 'constants' ||
          ast.property.name === 'thread' ||
          ast.property.name === 'output'
        ) {
          signature.unshift('.' + ast.property.name);
        } else {
          signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
        }
      } else if (ast.name) {
        signature.unshift(returnRawValue ? ast.name : 'value');
      } else if (ast.callee && ast.callee.name) {
        signature.unshift(returnRawValue ? ast.callee.name + '()' : 'fn()');
      } else if (ast.elements) {
        signature.unshift('[]');
      } else {
        signature.unshift('unknown');
      }
      ast = ast.object;
    }

    const signatureString = signature.join('');
    if (returnRawValue) {
      return signatureString;
    }

    const allowedExpressions = [
      'value',
      'value[]',
      'value[][]',
      'value[][][]',
      'value[][][][]',
      'value.value',
      'value.thread.value',
      'this.thread.value',
      'this.output.value',
      'this.constants.value',
      'this.constants.value[]',
      'this.constants.value[][]',
      'this.constants.value[][][]',
      'this.constants.value[][][][]',
      'fn()[]',
      'fn()[][]',
      'fn()[][][]',
      '[][]',
    ];
    if (allowedExpressions.indexOf(signatureString) > -1) {
      return signatureString;
    }
    return null;
  }

  build() {
    return this.toString().length > 0;
  }

  astGeneric(ast, retArr) {
    if (ast === null) {
      throw this.astErrorOutput('NULL ast', ast);
    } else {
      if (Array.isArray(ast)) {
        for (let i = 0; i < ast.length; i++) {
          this.astGeneric(ast[i], retArr);
        }
        return retArr;
      }

      switch (ast.type) {
        case 'FunctionDeclaration':
          return this.astFunctionDeclaration(ast, retArr);
        case 'FunctionExpression':
          return this.astFunctionExpression(ast, retArr);
        case 'ReturnStatement':
          return this.astReturnStatement(ast, retArr);
        case 'Literal':
          return this.astLiteral(ast, retArr);
        case 'BinaryExpression':
          return this.astBinaryExpression(ast, retArr);
        case 'Identifier':
          return this.astIdentifierExpression(ast, retArr);
        case 'AssignmentExpression':
          return this.astAssignmentExpression(ast, retArr);
        case 'ExpressionStatement':
          return this.astExpressionStatement(ast, retArr);
        case 'EmptyStatement':
          return this.astEmptyStatement(ast, retArr);
        case 'BlockStatement':
          return this.astBlockStatement(ast, retArr);
        case 'IfStatement':
          return this.astIfStatement(ast, retArr);
        case 'SwitchStatement':
          return this.astSwitchStatement(ast, retArr);
        case 'BreakStatement':
          return this.astBreakStatement(ast, retArr);
        case 'ContinueStatement':
          return this.astContinueStatement(ast, retArr);
        case 'ForStatement':
          return this.astForStatement(ast, retArr);
        case 'WhileStatement':
          return this.astWhileStatement(ast, retArr);
        case 'DoWhileStatement':
          return this.astDoWhileStatement(ast, retArr);
        case 'VariableDeclaration':
          return this.astVariableDeclaration(ast, retArr);
        case 'VariableDeclarator':
          return this.astVariableDeclarator(ast, retArr);
        case 'ThisExpression':
          return this.astThisExpression(ast, retArr);
        case 'SequenceExpression':
          return this.astSequenceExpression(ast, retArr);
        case 'UnaryExpression':
          return this.astUnaryExpression(ast, retArr);
        case 'UpdateExpression':
          return this.astUpdateExpression(ast, retArr);
        case 'LogicalExpression':
          return this.astLogicalExpression(ast, retArr);
        case 'MemberExpression':
          return this.astMemberExpression(ast, retArr);
        case 'CallExpression':
          return this.astCallExpression(ast, retArr);
        case 'ArrayExpression':
          return this.astArrayExpression(ast, retArr);
        case 'DebuggerStatement':
          return this.astDebuggerStatement(ast, retArr);
        case 'ConditionalExpression':
          return this.astConditionalExpression(ast, retArr);
      }

      throw this.astErrorOutput('Unknown ast type : ' + ast.type, ast);
    }
  }
  astErrorOutput(error, ast) {
    if (typeof this.source !== 'string') {
      return new Error(error);
    }

    const debugString = utils.getAstString(this.source, ast);
    const leadingSource = this.source.substr(ast.start);
    const splitLines = leadingSource.split(/\n/);
    const lineBefore = splitLines.length > 0 ? splitLines[splitLines.length - 1] : 0;
    return new Error(`${error} on line ${ splitLines.length }, position ${ lineBefore.length }:\n ${ debugString }`);
  }

  astDebuggerStatement(arrNode, retArr) {
    return retArr;
  }

  astConditionalExpression(ast, retArr) {
    if (ast.type !== 'ConditionalExpression') {
      throw this.astErrorOutput('Not a conditional expression', ast);
    }
    retArr.push('(');
    this.astGeneric(ast.test, retArr);
    retArr.push('?');
    this.astGeneric(ast.consequent, retArr);
    retArr.push(':');
    this.astGeneric(ast.alternate, retArr);
    retArr.push(')');
    return retArr;
  }

  astFunction(ast, retArr) {
    throw new Error(`"astFunction" not defined on ${ this.constructor.name }`);
  }

  astFunctionDeclaration(ast, retArr) {
    if (this.isChildFunction(ast)) {
      return retArr;
    }
    return this.astFunction(ast, retArr);
  }
  astFunctionExpression(ast, retArr) {
    if (this.isChildFunction(ast)) {
      return retArr;
    }
    return this.astFunction(ast, retArr);
  }
  isChildFunction(ast) {
    for (let i = 0; i < this.functions.length; i++) {
      if (this.functions[i] === ast) {
        return true;
      }
    }
    return false;
  }
  astReturnStatement(ast, retArr) {
    return retArr;
  }
  astLiteral(ast, retArr) {
    this.literalTypes[this.astKey(ast)] = 'Number';
    return retArr;
  }
  astBinaryExpression(ast, retArr) {
    return retArr;
  }
  astIdentifierExpression(ast, retArr) {
    return retArr;
  }
  astAssignmentExpression(ast, retArr) {
    return retArr;
  }
  astExpressionStatement(esNode, retArr) {
    this.astGeneric(esNode.expression, retArr);
    retArr.push(';');
    return retArr;
  }
  astEmptyStatement(eNode, retArr) {
    return retArr;
  }
  astBlockStatement(ast, retArr) {
    return retArr;
  }
  astIfStatement(ast, retArr) {
    return retArr;
  }
  astSwitchStatement(ast, retArr) {
    return retArr;
  }
  astBreakStatement(brNode, retArr) {
    retArr.push('break;');
    return retArr;
  }
  astContinueStatement(crNode, retArr) {
    retArr.push('continue;\n');
    return retArr;
  }
  astForStatement(ast, retArr) {
    return retArr;
  }
  astWhileStatement(ast, retArr) {
    return retArr;
  }
  astDoWhileStatement(ast, retArr) {
    return retArr;
  }
  astVariableDeclarator(iVarDecNode, retArr) {
    this.astGeneric(iVarDecNode.id, retArr);
    if (iVarDecNode.init !== null) {
      retArr.push('=');
      this.astGeneric(iVarDecNode.init, retArr);
    }
    return retArr;
  }
  astThisExpression(ast, retArr) {
    return retArr;
  }
  astSequenceExpression(sNode, retArr) {
    const { expressions } = sNode;
    const sequenceResult = [];
    for (let i = 0; i < expressions.length; i++) {
      const expression = expressions[i];
      const expressionResult = [];
      this.astGeneric(expression, expressionResult);
      sequenceResult.push(expressionResult.join(''));
    }
    if (sequenceResult.length > 1) {
      retArr.push('(', sequenceResult.join(','), ')');
    } else {
      retArr.push(sequenceResult[0]);
    }
    return retArr;
  }
  astUnaryExpression(uNode, retArr) {
    const unaryResult = this.checkAndUpconvertBitwiseUnary(uNode, retArr);
    if (unaryResult) {
      return retArr;
    }

    if (uNode.prefix) {
      retArr.push(uNode.operator);
      this.astGeneric(uNode.argument, retArr);
    } else {
      this.astGeneric(uNode.argument, retArr);
      retArr.push(uNode.operator);
    }

    return retArr;
  }

  checkAndUpconvertBitwiseUnary(uNode, retArr) {}

  astUpdateExpression(uNode, retArr) {
    if (uNode.prefix) {
      retArr.push(uNode.operator);
      this.astGeneric(uNode.argument, retArr);
    } else {
      this.astGeneric(uNode.argument, retArr);
      retArr.push(uNode.operator);
    }

    return retArr;
  }
  astLogicalExpression(logNode, retArr) {
    retArr.push('(');
    this.astGeneric(logNode.left, retArr);
    retArr.push(logNode.operator);
    this.astGeneric(logNode.right, retArr);
    retArr.push(')');
    return retArr;
  }
  astMemberExpression(ast, retArr) {
    return retArr;
  }
  astCallExpression(ast, retArr) {
    return retArr;
  }
  astArrayExpression(ast, retArr) {
    return retArr;
  }

  getMemberExpressionDetails(ast) {
    if (ast.type !== 'MemberExpression') {
      throw this.astErrorOutput(`Expression ${ ast.type } not a MemberExpression`, ast);
    }
    let name = null;
    let type = null;
    const variableSignature = this.getVariableSignature(ast);
    switch (variableSignature) {
      case 'value':
        return null;
      case 'value.thread.value':
      case 'this.thread.value':
      case 'this.output.value':
        return {
          signature: variableSignature,
            type: 'Integer',
            name: ast.property.name
        };
      case 'value[]':
        if (typeof ast.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object),
            xProperty: ast.property
        };
      case 'value[][]':
        if (typeof ast.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object),
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value[][][]':
        if (typeof ast.object.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object.object),
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value[][][][]':
        if (typeof ast.object.object.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object.object.object),
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value.value':
        if (typeof ast.property.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        if (this.isAstMathVariable(ast)) {
          name = ast.property.name;
          return {
            name,
            origin: 'Math',
            type: 'Number',
            signature: variableSignature,
          };
        }
        switch (ast.property.name) {
          case 'r':
          case 'g':
          case 'b':
          case 'a':
            name = ast.object.name;
            return {
              name,
              property: ast.property.name,
                origin: 'user',
                signature: variableSignature,
                type: 'Number'
            };
          default:
            throw this.astErrorOutput('Unexpected expression', ast);
        }
        case 'this.constants.value':
          if (typeof ast.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
              signature: variableSignature,
          };
        case 'this.constants.value[]':
          if (typeof ast.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
              signature: variableSignature,
              xProperty: ast.property,
          };
        case 'this.constants.value[][]': {
          if (typeof ast.object.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
            signature: variableSignature,
            yProperty: ast.object.property,
            xProperty: ast.property,
          };
        }
        case 'this.constants.value[][][]': {
          if (typeof ast.object.object.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.object.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
            signature: variableSignature,
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
          };
        }
        case 'fn()[]':
        case 'fn()[][]':
        case '[][]':
          return {
            signature: variableSignature,
              property: ast.property,
          };
        default:
          throw this.astErrorOutput('Unexpected expression', ast);
    }
  }

  findIdentifierOrigin(astToFind) {
    const stack = [this.ast];

    while (stack.length > 0) {
      const atNode = stack[0];
      if (atNode.type === 'VariableDeclarator' && atNode.id && atNode.id.name && atNode.id.name === astToFind.name) {
        return atNode;
      }
      stack.shift();
      if (atNode.argument) {
        stack.push(atNode.argument);
      } else if (atNode.body) {
        stack.push(atNode.body);
      } else if (atNode.declarations) {
        stack.push(atNode.declarations);
      } else if (Array.isArray(atNode)) {
        for (let i = 0; i < atNode.length; i++) {
          stack.push(atNode[i]);
        }
      }
    }
    return null;
  }

  findLastReturn(ast) {
    const stack = [ast || this.ast];

    while (stack.length > 0) {
      const atNode = stack.pop();
      if (atNode.type === 'ReturnStatement') {
        return atNode;
      }
      if (atNode.type === 'FunctionDeclaration') {
        continue;
      }
      if (atNode.argument) {
        stack.push(atNode.argument);
      } else if (atNode.body) {
        stack.push(atNode.body);
      } else if (atNode.declarations) {
        stack.push(atNode.declarations);
      } else if (Array.isArray(atNode)) {
        for (let i = 0; i < atNode.length; i++) {
          stack.push(atNode[i]);
        }
      } else if (atNode.consequent) {
        stack.push(atNode.consequent);
      } else if (atNode.cases) {
        stack.push(atNode.cases);
      }
    }
    return null;
  }

  getInternalVariableName(name) {
    if (!this._internalVariableNames.hasOwnProperty(name)) {
      this._internalVariableNames[name] = 0;
    }
    this._internalVariableNames[name]++;
    if (this._internalVariableNames[name] === 1) {
      return name;
    }
    return name + this._internalVariableNames[name];
  }

  astKey(ast, separator = ',') {
    if (!ast.start || !ast.end) throw new Error('AST start and end needed');
    return `${ast.start}${separator}${ast.end}`;
  }
}

const typeLookupMap = {
  'Number': 'Number',
  'Float': 'Float',
  'Integer': 'Integer',
  'Array': 'Number',
  'Array(2)': 'Number',
  'Array(3)': 'Number',
  'Array(4)': 'Number',
  'Matrix(2)': 'Number',
  'Matrix(3)': 'Number',
  'Matrix(4)': 'Number',
  'Array2D': 'Number',
  'Array3D': 'Number',
  'Input': 'Number',
  'HTMLCanvas': 'Array(4)',
  'OffscreenCanvas': 'Array(4)',
  'HTMLImage': 'Array(4)',
  'ImageBitmap': 'Array(4)',
  'ImageData': 'Array(4)',
  'HTMLVideo': 'Array(4)',
  'HTMLImageArray': 'Array(4)',
  'NumberTexture': 'Number',
  'MemoryOptimizedNumberTexture': 'Number',
  'Array1D(2)': 'Array(2)',
  'Array1D(3)': 'Array(3)',
  'Array1D(4)': 'Array(4)',
  'Array2D(2)': 'Array(2)',
  'Array2D(3)': 'Array(3)',
  'Array2D(4)': 'Array(4)',
  'Array3D(2)': 'Array(2)',
  'Array3D(3)': 'Array(3)',
  'Array3D(4)': 'Array(4)',
  'ArrayTexture(1)': 'Number',
  'ArrayTexture(2)': 'Array(2)',
  'ArrayTexture(3)': 'Array(3)',
  'ArrayTexture(4)': 'Array(4)',
};

module.exports = {
  FunctionNode
};
},{"../utils":114,"./function-tracer":11,"acorn":1}],11:[function(require,module,exports){
const { utils } = require('../utils');

function last(array) {
  return array.length > 0 ? array[array.length - 1] : null;
}

const states = {
  trackIdentifiers: 'trackIdentifiers',
  memberExpression: 'memberExpression',
  inForLoopInit: 'inForLoopInit'
};

class FunctionTracer {
  constructor(ast) {
    this.runningContexts = [];
    this.functionContexts = [];
    this.contexts = [];
    this.functionCalls = [];
    this.declarations = [];
    this.identifiers = [];
    this.functions = [];
    this.returnStatements = [];
    this.trackedIdentifiers = null;
    this.states = [];
    this.newFunctionContext();
    this.scan(ast);
  }

  isState(state) {
    return this.states[this.states.length - 1] === state;
  }

  hasState(state) {
    return this.states.indexOf(state) > -1;
  }

  pushState(state) {
    this.states.push(state);
  }

  popState(state) {
    if (this.isState(state)) {
      this.states.pop();
    } else {
      throw new Error(`Cannot pop the non-active state "${state}"`);
    }
  }

  get currentFunctionContext() {
    return last(this.functionContexts);
  }

  get currentContext() {
    return last(this.runningContexts);
  }

  newFunctionContext() {
    const newContext = { '@contextType': 'function' };
    this.contexts.push(newContext);
    this.functionContexts.push(newContext);
  }

  newContext(run) {
    const newContext = Object.assign({ '@contextType': 'const/let' }, this.currentContext);
    this.contexts.push(newContext);
    this.runningContexts.push(newContext);
    run();
    const { currentFunctionContext } = this;
    for (const p in currentFunctionContext) {
      if (!currentFunctionContext.hasOwnProperty(p) || newContext.hasOwnProperty(p)) continue;
      newContext[p] = currentFunctionContext[p];
    }
    this.runningContexts.pop();
    return newContext;
  }

  useFunctionContext(run) {
    const functionContext = last(this.functionContexts);
    this.runningContexts.push(functionContext);
    run();
    this.runningContexts.pop();
  }

  getIdentifiers(run) {
    const trackedIdentifiers = this.trackedIdentifiers = [];
    this.pushState(states.trackIdentifiers);
    run();
    this.trackedIdentifiers = null;
    this.popState(states.trackIdentifiers);
    return trackedIdentifiers;
  }

  getDeclaration(name) {
    const { currentContext, currentFunctionContext, runningContexts } = this;
    const declaration = currentContext[name] || currentFunctionContext[name] || null;

    if (
      !declaration &&
      currentContext === currentFunctionContext &&
      runningContexts.length > 0
    ) {
      const previousRunningContext = runningContexts[runningContexts.length - 2];
      if (previousRunningContext[name]) {
        return previousRunningContext[name];
      }
    }

    return declaration;
  }

  scan(ast) {
    if (!ast) return;
    if (Array.isArray(ast)) {
      for (let i = 0; i < ast.length; i++) {
        this.scan(ast[i]);
      }
      return;
    }
    switch (ast.type) {
      case 'Program':
        this.useFunctionContext(() => {
          this.scan(ast.body);
        });
        break;
      case 'BlockStatement':
        this.newContext(() => {
          this.scan(ast.body);
        });
        break;
      case 'AssignmentExpression':
      case 'LogicalExpression':
        this.scan(ast.left);
        this.scan(ast.right);
        break;
      case 'BinaryExpression':
        this.scan(ast.left);
        this.scan(ast.right);
        break;
      case 'UpdateExpression':
        if (ast.operator === '++') {
          const declaration = this.getDeclaration(ast.argument.name);
          if (declaration) {
            declaration.suggestedType = 'Integer';
          }
        }
        this.scan(ast.argument);
        break;
      case 'UnaryExpression':
        this.scan(ast.argument);
        break;
      case 'VariableDeclaration':
        if (ast.kind === 'var') {
          this.useFunctionContext(() => {
            ast.declarations = utils.normalizeDeclarations(ast);
            this.scan(ast.declarations);
          });
        } else {
          ast.declarations = utils.normalizeDeclarations(ast);
          this.scan(ast.declarations);
        }
        break;
      case 'VariableDeclarator': {
        const { currentContext } = this;
        const inForLoopInit = this.hasState(states.inForLoopInit);
        const declaration = {
          ast: ast,
          context: currentContext,
          name: ast.id.name,
          origin: 'declaration',
          inForLoopInit,
          inForLoopTest: null,
          assignable: currentContext === this.currentFunctionContext || (!inForLoopInit && !currentContext.hasOwnProperty(ast.id.name)),
          suggestedType: null,
          valueType: null,
          dependencies: null,
          isSafe: null,
        };
        if (!currentContext[ast.id.name]) {
          currentContext[ast.id.name] = declaration;
        }
        this.declarations.push(declaration);
        this.scan(ast.id);
        this.scan(ast.init);
        break;
      }
      case 'FunctionExpression':
      case 'FunctionDeclaration':
        if (this.runningContexts.length === 0) {
          this.scan(ast.body);
        } else {
          this.functions.push(ast);
        }
        break;
      case 'IfStatement':
        this.scan(ast.test);
        this.scan(ast.consequent);
        if (ast.alternate) this.scan(ast.alternate);
        break;
      case 'ForStatement': {
        let testIdentifiers;
        const context = this.newContext(() => {
          this.pushState(states.inForLoopInit);
          this.scan(ast.init);
          this.popState(states.inForLoopInit);

          testIdentifiers = this.getIdentifiers(() => {
            this.scan(ast.test);
          });

          this.scan(ast.update);
          this.newContext(() => {
            this.scan(ast.body);
          });
        });

        if (testIdentifiers) {
          for (const p in context) {
            if (p === '@contextType') continue;
            if (testIdentifiers.indexOf(p) > -1) {
              context[p].inForLoopTest = true;
            }
          }
        }
        break;
      }
      case 'DoWhileStatement':
      case 'WhileStatement':
        this.newContext(() => {
          this.scan(ast.body);
          this.scan(ast.test);
        });
        break;
      case 'Identifier': {
        if (this.isState(states.trackIdentifiers)) {
          this.trackedIdentifiers.push(ast.name);
        }
        this.identifiers.push({
          context: this.currentContext,
          declaration: this.getDeclaration(ast.name),
          ast,
        });
        break;
      }
      case 'ReturnStatement':
        this.returnStatements.push(ast);
        this.scan(ast.argument);
        break;
      case 'MemberExpression':
        this.pushState(states.memberExpression);
        this.scan(ast.object);
        this.scan(ast.property);
        this.popState(states.memberExpression);
        break;
      case 'ExpressionStatement':
        this.scan(ast.expression);
        break;
      case 'SequenceExpression':
        this.scan(ast.expressions);
        break;
      case 'CallExpression':
        this.functionCalls.push({
          context: this.currentContext,
          ast,
        });
        this.scan(ast.arguments);
        break;
      case 'ArrayExpression':
        this.scan(ast.elements);
        break;
      case 'ConditionalExpression':
        this.scan(ast.test);
        this.scan(ast.alternate);
        this.scan(ast.consequent);
        break;
      case 'SwitchStatement':
        this.scan(ast.discriminant);
        this.scan(ast.cases);
        break;
      case 'SwitchCase':
        this.scan(ast.test);
        this.scan(ast.consequent);
        break;

      case 'ThisExpression':
      case 'Literal':
      case 'DebuggerStatement':
      case 'EmptyStatement':
      case 'BreakStatement':
      case 'ContinueStatement':
        break;
      default:
        throw new Error(`unhandled type "${ast.type}"`);
    }
  }
}

module.exports = {
  FunctionTracer,
};
},{"../utils":114}],12:[function(require,module,exports){
const { glWiretap } = require('gl-wiretap');
const { utils } = require('../../utils');

function toStringWithoutUtils(fn) {
  return fn.toString()
    .replace('=>', '')
    .replace(/^function /, '')
    .replace(/utils[.]/g, '/*utils.*/');
}

function glKernelString(Kernel, args, originKernel, setupContextString, destroyContextString) {
  if (!originKernel.built) {
    originKernel.build.apply(originKernel, args);
  }
  args = args ? Array.from(args).map(arg => {
    switch (typeof arg) {
      case 'boolean':
        return new Boolean(arg);
      case 'number':
        return new Number(arg);
      default:
        return arg;
    }
  }) : null;
  const uploadedValues = [];
  const postResult = [];
  const context = glWiretap(originKernel.context, {
    useTrackablePrimitives: true,
    onReadPixels: (targetName) => {
      if (kernel.subKernels) {
        if (!subKernelsResultVariableSetup) {
          postResult.push(`    const result = { result: ${getRenderString(targetName, kernel)} };`);
          subKernelsResultVariableSetup = true;
        } else {
          const property = kernel.subKernels[subKernelsResultIndex++].property;
          postResult.push(`    result${isNaN(property) ? '.' + property : `[${property}]`} = ${getRenderString(targetName, kernel)};`);
        }
        if (subKernelsResultIndex === kernel.subKernels.length) {
          postResult.push('    return result;');
        }
        return;
      }
      if (targetName) {
        postResult.push(`    return ${getRenderString(targetName, kernel)};`);
      } else {
        postResult.push(`    return null;`);
      }
    },
    onUnrecognizedArgumentLookup: (argument) => {
      const argumentName = findKernelValue(argument, kernel.kernelArguments, [], context, uploadedValues);
      if (argumentName) {
        return argumentName;
      }
      const constantName = findKernelValue(argument, kernel.kernelConstants, constants ? Object.keys(constants).map(key => constants[key]) : [], context, uploadedValues);
      if (constantName) {
        return constantName;
      }
      return null;
    }
  });
  let subKernelsResultVariableSetup = false;
  let subKernelsResultIndex = 0;
  const {
    source,
    canvas,
    output,
    pipeline,
    graphical,
    loopMaxIterations,
    constants,
    optimizeFloatMemory,
    precision,
    fixIntegerDivisionAccuracy,
    functions,
    nativeFunctions,
    subKernels,
    immutable,
    argumentTypes,
    constantTypes,
    kernelArguments,
    kernelConstants,
    tactic,
  } = originKernel;
  const kernel = new Kernel(source, {
    canvas,
    context,
    checkContext: false,
    output,
    pipeline,
    graphical,
    loopMaxIterations,
    constants,
    optimizeFloatMemory,
    precision,
    fixIntegerDivisionAccuracy,
    functions,
    nativeFunctions,
    subKernels,
    immutable,
    argumentTypes,
    constantTypes,
    tactic,
  });
  let result = [];
  context.setIndent(2);
  kernel.build.apply(kernel, args);
  result.push(context.toString());
  context.reset();

  kernel.kernelArguments.forEach((kernelArgument, i) => {
    switch (kernelArgument.type) {
      case 'Integer':
      case 'Boolean':
      case 'Number':
      case 'Float':
      case 'Array':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'HTMLCanvas':
      case 'HTMLImage':
      case 'HTMLVideo':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
        break;
      case 'HTMLImageArray':
        for (let imageIndex = 0; imageIndex < args[i].length; imageIndex++) {
          const arg = args[i];
          context.insertVariable(`uploadValue_${kernelArgument.name}[${imageIndex}]`, arg[imageIndex]);
        }
        break;
      case 'Input':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
        break;
      case 'MemoryOptimizedNumberTexture':
      case 'NumberTexture':
      case 'Array1D(2)':
      case 'Array1D(3)':
      case 'Array1D(4)':
      case 'Array2D(2)':
      case 'Array2D(3)':
      case 'Array2D(4)':
      case 'Array3D(2)':
      case 'Array3D(3)':
      case 'Array3D(4)':
      case 'ArrayTexture(1)':
      case 'ArrayTexture(2)':
      case 'ArrayTexture(3)':
      case 'ArrayTexture(4)':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, args[i].texture);
        break;
      default:
        throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${kernelArgument.type}`);
    }
  });
  result.push('/** start of injected functions **/');
  result.push(`function ${toStringWithoutUtils(utils.flattenTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten2dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten3dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten4dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.isArray)}`);
  if (kernel.renderOutput !== kernel.renderTexture && kernel.formatValues) {
    result.push(
      `  const renderOutput = function ${toStringWithoutUtils(kernel.formatValues)};`
    );
  }
  result.push('/** end of injected functions **/');
  result.push(`  const innerKernel = function (${kernel.kernelArguments.map(kernelArgument => kernelArgument.varName).join(', ')}) {`);
  context.setIndent(4);
  kernel.run.apply(kernel, args);
  if (kernel.renderKernels) {
    kernel.renderKernels();
  } else if (kernel.renderOutput) {
    kernel.renderOutput();
  }
  result.push('    /** start setup uploads for kernel values **/');
  kernel.kernelArguments.forEach(kernelArgument => {
    result.push('    ' + kernelArgument.getStringValueHandler().split('\n').join('\n    '));
  });
  result.push('    /** end setup uploads for kernel values **/');
  result.push(context.toString());
  if (kernel.renderOutput === kernel.renderTexture) {
    context.reset();
    const framebufferName = context.getContextVariableName(kernel.framebuffer);
    if (kernel.renderKernels) {
      const results = kernel.renderKernels();
      const textureName = context.getContextVariableName(kernel.texture.texture);
      result.push(`    return {
      result: {
        texture: ${ textureName },
        type: '${ results.result.type }',
        toArray: ${ getToArrayString(results.result, textureName, framebufferName) }
      },`);
      const { subKernels, mappedTextures } = kernel;
      for (let i = 0; i < subKernels.length; i++) {
        const texture = mappedTextures[i];
        const subKernel = subKernels[i];
        const subKernelResult = results[subKernel.property];
        const subKernelTextureName = context.getContextVariableName(texture.texture);
        result.push(`
      ${subKernel.property}: {
        texture: ${ subKernelTextureName },
        type: '${ subKernelResult.type }',
        toArray: ${ getToArrayString(subKernelResult, subKernelTextureName, framebufferName) }
      },`);
      }
      result.push(`    };`);
    } else {
      const rendered = kernel.renderOutput();
      const textureName = context.getContextVariableName(kernel.texture.texture);
      result.push(`    return {
        texture: ${ textureName },
        type: '${ rendered.type }',
        toArray: ${ getToArrayString(rendered, textureName, framebufferName) }
      };`);
    }
  }
  result.push(`    ${destroyContextString ? '\n' + destroyContextString + '    ': ''}`);
  result.push(postResult.join('\n'));
  result.push('  };');
  if (kernel.graphical) {
    result.push(getGetPixelsString(kernel));
    result.push(`  innerKernel.getPixels = getPixels;`);
  }
  result.push('  return innerKernel;');

  let constantsUpload = [];
  kernelConstants.forEach((kernelConstant) => {
    constantsUpload.push(`${kernelConstant.getStringValueHandler()}`);
  });
  return `function kernel(settings) {
  const { context, constants } = settings;
  ${constantsUpload.join('')}
  ${setupContextString ? setupContextString : ''}
${result.join('\n')}
}`;
}

function getRenderString(targetName, kernel) {
  const readBackValue = kernel.precision === 'single' ? targetName : `new Float32Array(${targetName}.buffer)`;
  if (kernel.output[2]) {
    return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]}, ${kernel.output[2]})`;
  }
  if (kernel.output[1]) {
    return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]})`;
  }

  return `renderOutput(${readBackValue}, ${kernel.output[0]})`;
}

function getGetPixelsString(kernel) {
  const getPixels = kernel.getPixels.toString();
  const useFunctionKeyword = !/^function/.test(getPixels);
  return utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ getPixels }`, {
    findDependency: (object, name) => {
      if (object === 'utils') {
        return `const ${name} = ${utils[name].toString()};`;
      }
      return null;
    },
    thisLookup: (property) => {
      if (property === 'context') {
        return null;
      }
      if (kernel.hasOwnProperty(property)) {
        return JSON.stringify(kernel[property]);
      }
      throw new Error(`unhandled thisLookup ${ property }`);
    }
  });
}

function getToArrayString(kernelResult, textureName, framebufferName) {
  const toArray = kernelResult.toArray.toString();
  const useFunctionKeyword = !/^function/.test(toArray);
  const flattenedFunctions = utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ toArray }`, {
    findDependency: (object, name) => {
      if (object === 'utils') {
        return `const ${name} = ${utils[name].toString()};`;
      } else if (object === 'this') {
        if (name === 'framebuffer') {
          return '';
        }
        return `${useFunctionKeyword ? 'function ' : ''}${kernelResult[name].toString()}`;
      } else {
        throw new Error('unhandled fromObject');
      }
    },
    thisLookup: (property, isDeclaration) => {
      if (property === 'texture') {
        return textureName;
      }
      if (property === 'context') {
        if (isDeclaration) return null;
        return 'gl';
      }
      if (kernelResult.hasOwnProperty(property)) {
        return JSON.stringify(kernelResult[property]);
      }
      throw new Error(`unhandled thisLookup ${ property }`);
    }
  });
  return `() => {
  function framebuffer() { return ${framebufferName}; };
  ${flattenedFunctions}
  return toArray();
  }`;
}

function findKernelValue(argument, kernelValues, values, context, uploadedValues) {
  if (argument === null) return null;
  if (kernelValues === null) return null;
  switch (typeof argument) {
    case 'boolean':
    case 'number':
      return null;
  }
  if (
    typeof HTMLImageElement !== 'undefined' &&
    argument instanceof HTMLImageElement
  ) {
    for (let i = 0; i < kernelValues.length; i++) {
      const kernelValue = kernelValues[i];
      if (kernelValue.type !== 'HTMLImageArray' && kernelValue) continue;
      if (kernelValue.uploadValue !== argument) continue;
      const variableIndex = values[i].indexOf(argument);
      if (variableIndex === -1) continue;
      const variableName = `uploadValue_${kernelValue.name}[${variableIndex}]`;
      context.insertVariable(variableName, argument);
      return variableName;
    }
  }

  for (let i = 0; i < kernelValues.length; i++) {
    const kernelValue = kernelValues[i];
    if (argument !== kernelValue.uploadValue) continue;
    const variable = `uploadValue_${kernelValue.name}`;
    context.insertVariable(variable, kernelValue);
    return variable;
  }
  return null;
}

module.exports = {
  glKernelString
};
},{"../../utils":114,"gl-wiretap":3}],13:[function(require,module,exports){
const { Kernel } = require('../kernel');
const { utils } = require('../../utils');
const { GLTextureArray2Float } = require('./texture/array-2-float');
const { GLTextureArray2Float2D } = require('./texture/array-2-float-2d');
const { GLTextureArray2Float3D } = require('./texture/array-2-float-3d');
const { GLTextureArray3Float } = require('./texture/array-3-float');
const { GLTextureArray3Float2D } = require('./texture/array-3-float-2d');
const { GLTextureArray3Float3D } = require('./texture/array-3-float-3d');
const { GLTextureArray4Float } = require('./texture/array-4-float');
const { GLTextureArray4Float2D } = require('./texture/array-4-float-2d');
const { GLTextureArray4Float3D } = require('./texture/array-4-float-3d');
const { GLTextureFloat } = require('./texture/float');
const { GLTextureFloat2D } = require('./texture/float-2d');
const { GLTextureFloat3D } = require('./texture/float-3d');
const { GLTextureMemoryOptimized } = require('./texture/memory-optimized');
const { GLTextureMemoryOptimized2D } = require('./texture/memory-optimized-2d');
const { GLTextureMemoryOptimized3D } = require('./texture/memory-optimized-3d');
const { GLTextureUnsigned } = require('./texture/unsigned');
const { GLTextureUnsigned2D } = require('./texture/unsigned-2d');
const { GLTextureUnsigned3D } = require('./texture/unsigned-3d');
const { GLTextureGraphical } = require('./texture/graphical');

class GLKernel extends Kernel {
  static get mode() {
    return 'gpu';
  }

  static getIsFloatRead() {
    const kernelString = `function kernelFunction() {
      return 1;
    }`;
    const kernel = new this(kernelString, {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [1],
      precision: 'single',
      returnType: 'Number',
      tactic: 'speed',
    });
    kernel.build();
    kernel.run();
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return result[0] === 1;
  }

  static getIsIntegerDivisionAccurate() {
    function kernelFunction(v1, v2) {
      return v1[this.thread.x] / v2[this.thread.x];
    }
    const kernel = new this(kernelFunction.toString(), {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [2],
      returnType: 'Number',
      precision: 'unsigned',
      tactic: 'speed',
    });
    const args = [
      [6, 6030401],
      [3, 3991]
    ];
    kernel.build.apply(kernel, args);
    kernel.run.apply(kernel, args);
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return result[0] === 2 && result[1] === 1511;
  }

  static getIsSpeedTacticSupported() {
    function kernelFunction(value) {
      return value[this.thread.x];
    }
    const kernel = new this(kernelFunction.toString(), {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [4],
      returnType: 'Number',
      precision: 'unsigned',
      tactic: 'speed',
    });
    const args = [
      [0, 1, 2, 3]
    ];
    kernel.build.apply(kernel, args);
    kernel.run.apply(kernel, args);
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return Math.round(result[0]) === 0 && Math.round(result[1]) === 1 && Math.round(result[2]) === 2 && Math.round(result[3]) === 3;
  }

  static get testCanvas() {
    throw new Error(`"testCanvas" not defined on ${ this.name }`);
  }

  static get testContext() {
    throw new Error(`"testContext" not defined on ${ this.name }`);
  }

  static getFeatures() {
    const gl = this.testContext;
    const isDrawBuffers = this.getIsDrawBuffers();
    return Object.freeze({
      isFloatRead: this.getIsFloatRead(),
      isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
      isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
      isTextureFloat: this.getIsTextureFloat(),
      isDrawBuffers,
      kernelMap: isDrawBuffers,
      channelCount: this.getChannelCount(),
      maxTextureSize: this.getMaxTextureSize(),
      lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
      lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
      mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
      mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
      highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
      highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
    });
  }

  static setupFeatureChecks() {
    throw new Error(`"setupFeatureChecks" not defined on ${ this.name }`);
  }

  static getSignature(kernel, argumentTypes) {
    return kernel.getVariablePrecisionString() + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
  }

  setFixIntegerDivisionAccuracy(fix) {
    this.fixIntegerDivisionAccuracy = fix;
    return this;
  }

  setPrecision(flag) {
    this.precision = flag;
    return this;
  }

  setFloatTextures(flag) {
    utils.warnDeprecated('method', 'setFloatTextures', 'setOptimizeFloatMemory');
    this.floatTextures = flag;
    return this;
  }

  static nativeFunctionArguments(source) {
    const argumentTypes = [];
    const argumentNames = [];
    const states = [];
    const isStartingVariableName = /^[a-zA-Z_]/;
    const isVariableChar = /[a-zA-Z_0-9]/;
    let i = 0;
    let argumentName = null;
    let argumentType = null;
    while (i < source.length) {
      const char = source[i];
      const nextChar = source[i + 1];
      const state = states.length > 0 ? states[states.length - 1] : null;

      if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '*') {
        states.push('MULTI_LINE_COMMENT');
        i += 2;
        continue;
      } else if (state === 'MULTI_LINE_COMMENT' && char === '*' && nextChar === '/') {
        states.pop();
        i += 2;
        continue;
      }

      else if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '/') {
        states.push('COMMENT');
        i += 2;
        continue;
      } else if (state === 'COMMENT' && char === '\n') {
        states.pop();
        i++;
        continue;
      }

      else if (state === null && char === '(') {
        states.push('FUNCTION_ARGUMENTS');
        i++;
        continue;
      } else if (state === 'FUNCTION_ARGUMENTS') {
        if (char === ')') {
          states.pop();
          break;
        }
        if (char === 'f' && nextChar === 'l' && source[i + 2] === 'o' && source[i + 3] === 'a' && source[i + 4] === 't' && source[i + 5] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'float';
          argumentName = '';
          i += 6;
          continue;
        } else if (char === 'i' && nextChar === 'n' && source[i + 2] === 't' && source[i + 3] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'int';
          argumentName = '';
          i += 4;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '2' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec2';
          argumentName = '';
          i += 5;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '3' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec3';
          argumentName = '';
          i += 5;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '4' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec4';
          argumentName = '';
          i += 5;
          continue;
        }
      }

      else if (state === 'DECLARE_VARIABLE') {
        if (argumentName === '') {
          if (char === ' ') {
            i++;
            continue;
          }
          if (!isStartingVariableName.test(char)) {
            throw new Error('variable name is not expected string');
          }
        }
        argumentName += char;
        if (!isVariableChar.test(nextChar)) {
          states.pop();
          argumentNames.push(argumentName);
          argumentTypes.push(typeMap[argumentType]);
        }
      }

      i++;
    }
    if (states.length > 0) {
      throw new Error('GLSL function was not parsable');
    }
    return {
      argumentNames,
      argumentTypes,
    };
  }

  static nativeFunctionReturnType(source) {
    return typeMap[source.match(/int|float|vec[2-4]/)[0]];
  }

  static combineKernels(combinedKernel, lastKernel) {
    combinedKernel.apply(null, arguments);
    const {
      texSize,
      context,
      threadDim
    } = lastKernel.texSize;
    let result;
    if (lastKernel.precision === 'single') {
      const w = texSize[0];
      const h = Math.ceil(texSize[1] / 4);
      result = new Float32Array(w * h * 4 * 4);
      context.readPixels(0, 0, w, h * 4, context.RGBA, context.FLOAT, result);
    } else {
      const bytes = new Uint8Array(texSize[0] * texSize[1] * 4);
      context.readPixels(0, 0, texSize[0], texSize[1], context.RGBA, context.UNSIGNED_BYTE, bytes);
      result = new Float32Array(bytes.buffer);
    }

    result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);

    if (lastKernel.output.length === 1) {
      return result;
    } else if (lastKernel.output.length === 2) {
      return utils.splitArray(result, lastKernel.output[0]);
    } else if (lastKernel.output.length === 3) {
      const cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);
      return cube.map(function(x) {
        return utils.splitArray(x, lastKernel.output[0]);
      });
    }
  }

  constructor(source, settings) {
    super(source, settings);
    this.transferValues = null;
    this.formatValues = null;
    this.TextureConstructor = null;
    this.renderOutput = null;
    this.renderRawOutput = null;
    this.texSize = null;
    this.translatedSource = null;
    this.compiledFragmentShader = null;
    this.compiledVertexShader = null;
    this.switchingKernels = null;
    this._textureSwitched = null;
    this._mappedTextureSwitched = null;
  }

  checkTextureSize() {
    const { features } = this.constructor;
    if (this.texSize[0] > features.maxTextureSize || this.texSize[1] > features.maxTextureSize) {
      throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${features.maxTextureSize},${features.maxTextureSize}]`);
    }
  }

  translateSource() {
    throw new Error(`"translateSource" not defined on ${this.constructor.name}`);
  }

  pickRenderStrategy(args) {
    if (this.graphical) {
      this.renderRawOutput = this.readPackedPixelsToUint8Array;
      this.transferValues = (pixels) => pixels;
      this.TextureConstructor = GLTextureGraphical;
      return null;
    }
    if (this.precision === 'unsigned') {
      this.renderRawOutput = this.readPackedPixelsToUint8Array;
      this.transferValues = this.readPackedPixelsToFloat32Array;
      if (this.pipeline) {
        this.renderOutput = this.renderTexture;
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToTextures;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer':
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureUnsigned3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureUnsigned2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureUnsigned;
              return null;
            }
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              return this.requestFallback(args);
        }
      } else {
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToArrays;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer':
            this.renderOutput = this.renderValues;
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureUnsigned3D;
              this.formatValues = utils.erect3DPackedFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureUnsigned2D;
              this.formatValues = utils.erect2DPackedFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureUnsigned;
              this.formatValues = utils.erectPackedFloat;
              return null;
            }
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              return this.requestFallback(args);
        }
      }
    } else if (this.precision === 'single') {
      this.renderRawOutput = this.readFloatPixelsToFloat32Array;
      this.transferValues = this.readFloatPixelsToFloat32Array;
      if (this.pipeline) {
        this.renderOutput = this.renderTexture;
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToTextures;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.optimizeFloatMemory) {
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureMemoryOptimized3D;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureMemoryOptimized2D;
                return null;
              } else {
                this.TextureConstructor = GLTextureMemoryOptimized;
                return null;
              }
            } else {
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureFloat3D;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureFloat2D;
                return null;
              } else {
                this.TextureConstructor = GLTextureFloat;
                return null;
              }
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              return null;
            }
          }
        }
      }
      this.renderOutput = this.renderValues;
      if (this.subKernels !== null) {
        this.renderKernels = this.renderKernelsToArrays;
      }
      if (this.optimizeFloatMemory) {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureMemoryOptimized3D;
              this.formatValues = utils.erectMemoryOptimized3DFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureMemoryOptimized2D;
              this.formatValues = utils.erectMemoryOptimized2DFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureMemoryOptimized;
              this.formatValues = utils.erectMemoryOptimizedFloat;
              return null;
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              this.formatValues = utils.erect3DArray2;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              this.formatValues = utils.erect2DArray2;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              this.formatValues = utils.erectArray2;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              this.formatValues = utils.erect3DArray3;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              this.formatValues = utils.erect2DArray3;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              this.formatValues = utils.erectArray3;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              this.formatValues = utils.erect3DArray4;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              this.formatValues = utils.erect2DArray4;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              this.formatValues = utils.erectArray4;
              return null;
            }
          }
        }
      } else {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureFloat3D;
              this.formatValues = utils.erect3DFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureFloat2D;
              this.formatValues = utils.erect2DFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureFloat;
              this.formatValues = utils.erectFloat;
              return null;
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              this.formatValues = utils.erect3DArray2;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              this.formatValues = utils.erect2DArray2;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              this.formatValues = utils.erectArray2;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              this.formatValues = utils.erect3DArray3;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              this.formatValues = utils.erect2DArray3;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              this.formatValues = utils.erectArray3;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              this.formatValues = utils.erect3DArray4;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              this.formatValues = utils.erect2DArray4;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              this.formatValues = utils.erectArray4;
              return null;
            }
          }
        }
      }
    } else {
      throw new Error(`unhandled precision of "${this.precision}"`);
    }

    throw new Error(`unhandled return type "${this.returnType}"`);
  }

  getKernelString() {
    throw new Error(`abstract method call`);
  }

  getMainResultTexture() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Float':
      case 'Integer':
      case 'Number':
        return this.getMainResultNumberTexture();
      case 'Array(2)':
        return this.getMainResultArray2Texture();
      case 'Array(3)':
        return this.getMainResultArray3Texture();
      case 'Array(4)':
        return this.getMainResultArray4Texture();
      default:
        throw new Error(`unhandled returnType type ${ this.returnType }`);
    }
  }

  getMainResultKernelNumberTexture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelNumberTexture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray2Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray2Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray3Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray3Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray4Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray4Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultGraphical() {
    throw new Error(`abstract method call`);
  }
  getMainResultMemoryOptimizedFloats() {
    throw new Error(`abstract method call`);
  }
  getMainResultPackedPixels() {
    throw new Error(`abstract method call`);
  }

  getMainResultString() {
    if (this.graphical) {
      return this.getMainResultGraphical();
    } else if (this.precision === 'single') {
      if (this.optimizeFloatMemory) {
        return this.getMainResultMemoryOptimizedFloats();
      }
      return this.getMainResultTexture();
    } else {
      return this.getMainResultPackedPixels();
    }
  }

  getMainResultNumberTexture() {
    return utils.linesToString(this.getMainResultKernelNumberTexture()) +
      utils.linesToString(this.getMainResultSubKernelNumberTexture());
  }

  getMainResultArray2Texture() {
    return utils.linesToString(this.getMainResultKernelArray2Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray2Texture());
  }

  getMainResultArray3Texture() {
    return utils.linesToString(this.getMainResultKernelArray3Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray3Texture());
  }

  getMainResultArray4Texture() {
    return utils.linesToString(this.getMainResultKernelArray4Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray4Texture());
  }

  getFloatTacticDeclaration() {
    const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
    return `precision ${variablePrecision} float;\n`;
  }

  getIntTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic, true)} int;\n`;
  }

  getSampler2DTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2D;\n`;
  }

  getSampler2DArrayTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2DArray;\n`;
  }

  renderTexture() {
    return this.immutable ? this.texture.clone() : this.texture;
  }
  readPackedPixelsToUint8Array() {
    if (this.precision !== 'unsigned') throw new Error('Requires this.precision to be "unsigned"');
    const {
      texSize,
      context: gl
    } = this;
    const result = new Uint8Array(texSize[0] * texSize[1] * 4);
    gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
    return result;
  }

  readPackedPixelsToFloat32Array() {
    return new Float32Array(this.readPackedPixelsToUint8Array().buffer);
  }

  readFloatPixelsToFloat32Array() {
    if (this.precision !== 'single') throw new Error('Requires this.precision to be "single"');
    const {
      texSize,
      context: gl
    } = this;
    const w = texSize[0];
    const h = texSize[1];
    const result = new Float32Array(w * h * 4);
    gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
    return result;
  }

  getPixels(flip) {
    const {
      context: gl,
      output
    } = this;
    const [width, height] = output;
    const pixels = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    return new Uint8ClampedArray((flip ? pixels : utils.flipPixels(pixels, width, height)).buffer);
  }

  renderKernelsToArrays() {
    const result = {
      result: this.renderOutput(),
    };
    for (let i = 0; i < this.subKernels.length; i++) {
      result[this.subKernels[i].property] = this.mappedTextures[i].toArray();
    }
    return result;
  }

  renderKernelsToTextures() {
    const result = {
      result: this.renderOutput(),
    };
    if (this.immutable) {
      for (let i = 0; i < this.subKernels.length; i++) {
        result[this.subKernels[i].property] = this.mappedTextures[i].clone();
      }
    } else {
      for (let i = 0; i < this.subKernels.length; i++) {
        result[this.subKernels[i].property] = this.mappedTextures[i];
      }
    }
    return result;
  }

  resetSwitchingKernels() {
    const existingValue = this.switchingKernels;
    this.switchingKernels = null;
    return existingValue;
  }

  setOutput(output) {
    const newOutput = this.toKernelOutput(output);
    if (this.program) {
      if (!this.dynamicOutput) {
        throw new Error('Resizing a kernel with dynamicOutput: false is not possible');
      }
      const newThreadDim = [newOutput[0], newOutput[1] || 1, newOutput[2] || 1];
      const newTexSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, newThreadDim);
      const oldTexSize = this.texSize;
      if (oldTexSize) {
        const oldPrecision = this.getVariablePrecisionString(oldTexSize, this.tactic);
        const newPrecision = this.getVariablePrecisionString(newTexSize, this.tactic);
        if (oldPrecision !== newPrecision) {
          if (this.debug) {
            console.warn('Precision requirement changed, asking GPU instance to recompile');
          }
          this.switchKernels({
            type: 'outputPrecisionMismatch',
            precision: newPrecision,
            needed: output
          });
          return;
        }
      }
      this.output = newOutput;
      this.threadDim = newThreadDim;
      this.texSize = newTexSize;
      const { context: gl } = this;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      this.updateMaxTexSize();
      this.framebuffer.width = this.texSize[0];
      this.framebuffer.height = this.texSize[1];
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      this.canvas.width = this.maxTexSize[0];
      this.canvas.height = this.maxTexSize[1];
      if (this.texture) {
        this.texture.delete();
      }
      this.texture = null;
      this._setupOutputTexture();
      if (this.mappedTextures && this.mappedTextures.length > 0) {
        for (let i = 0; i < this.mappedTextures.length; i++) {
          this.mappedTextures[i].delete();
        }
        this.mappedTextures = null;
        this._setupSubOutputTextures();
      }
    } else {
      this.output = newOutput;
    }
    return this;
  }
  renderValues() {
    return this.formatValues(
      this.transferValues(),
      this.output[0],
      this.output[1],
      this.output[2]
    );
  }
  switchKernels(reason) {
    if (this.switchingKernels) {
      this.switchingKernels.push(reason);
    } else {
      this.switchingKernels = [reason];
    }
  }
  getVariablePrecisionString(textureSize = this.texSize, tactic = this.tactic, isInt = false) {
    if (!tactic) {
      if (!this.constructor.features.isSpeedTacticSupported) return 'highp';
      const low = this.constructor.features[isInt ? 'lowIntPrecision' : 'lowFloatPrecision'];
      const medium = this.constructor.features[isInt ? 'mediumIntPrecision' : 'mediumFloatPrecision'];
      const high = this.constructor.features[isInt ? 'highIntPrecision' : 'highFloatPrecision'];
      const requiredSize = Math.log2(textureSize[0] * textureSize[1]);
      if (requiredSize <= low.rangeMax) {
        return 'lowp';
      } else if (requiredSize <= medium.rangeMax) {
        return 'mediump';
      } else if (requiredSize <= high.rangeMax) {
        return 'highp';
      } else {
        throw new Error(`The required size exceeds that of the ability of your system`);
      }
    }
    switch (tactic) {
      case 'speed':
        return 'lowp';
      case 'balanced':
        return 'mediump';
      case 'precision':
        return 'highp';
      default:
        throw new Error(`Unknown tactic "${tactic}" use "speed", "balanced", "precision", or empty for auto`);
    }
  }

  updateTextureArgumentRefs(kernelValue, arg) {
    if (!this.immutable) return;
    if (this.texture.texture === arg.texture) {
      const { prevArg } = kernelValue;
      if (prevArg) {
        if (prevArg.texture._refs === 1) {
          this.texture.delete();
          this.texture = prevArg.clone();
          this._textureSwitched = true;
        }
        prevArg.delete();
      }
      kernelValue.prevArg = arg.clone();
    } else if (this.mappedTextures && this.mappedTextures.length > 0) {
      const { mappedTextures } = this;
      for (let i = 0; i < mappedTextures.length; i++) {
        const mappedTexture = mappedTextures[i];
        if (mappedTexture.texture === arg.texture) {
          const { prevArg } = kernelValue;
          if (prevArg) {
            if (prevArg.texture._refs === 1) {
              mappedTexture.delete();
              mappedTextures[i] = prevArg.clone();
              this._mappedTextureSwitched[i] = true;
            }
            prevArg.delete();
          }
          kernelValue.prevArg = arg.clone();
          return;
        }
      }
    }
  }

  onActivate(previousKernel) {
    this._textureSwitched = true;
    this.texture = previousKernel.texture;
    if (this.mappedTextures) {
      for (let i = 0; i < this.mappedTextures.length; i++) {
        this._mappedTextureSwitched[i] = true;
      }
      this.mappedTextures = previousKernel.mappedTextures;
    }
  }

  initCanvas() {}
}

const typeMap = {
  int: 'Integer',
  float: 'Number',
  vec2: 'Array(2)',
  vec3: 'Array(3)',
  vec4: 'Array(4)',
};

module.exports = {
  GLKernel
};
},{"../../utils":114,"../kernel":36,"./texture/array-2-float":16,"./texture/array-2-float-2d":14,"./texture/array-2-float-3d":15,"./texture/array-3-float":19,"./texture/array-3-float-2d":17,"./texture/array-3-float-3d":18,"./texture/array-4-float":22,"./texture/array-4-float-2d":20,"./texture/array-4-float-3d":21,"./texture/float":25,"./texture/float-2d":23,"./texture/float-3d":24,"./texture/graphical":26,"./texture/memory-optimized":30,"./texture/memory-optimized-2d":28,"./texture/memory-optimized-3d":29,"./texture/unsigned":33,"./texture/unsigned-2d":31,"./texture/unsigned-3d":32}],14:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray2Float2D
};
},{"../../../utils":114,"./float":25}],15:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray2Float3D
};
},{"../../../utils":114,"./float":25}],16:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erectArray2(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray2Float
};
},{"../../../utils":114,"./float":25}],17:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erect2DArray3(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray3Float2D
};
},{"../../../utils":114,"./float":25}],18:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray3Float3D
};
},{"../../../utils":114,"./float":25}],19:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erectArray3(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureArray3Float
};
},{"../../../utils":114,"./float":25}],20:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erect2DArray4(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray4Float2D
};
},{"../../../utils":114,"./float":25}],21:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray4Float3D
};
},{"../../../utils":114,"./float":25}],22:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erectArray4(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureArray4Float
};
},{"../../../utils":114,"./float":25}],23:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureFloat2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  toArray() {
    return utils.erect2DFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureFloat2D
};
},{"../../../utils":114,"./float":25}],24:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureFloat3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  toArray() {
    return utils.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureFloat3D
};
},{"../../../utils":114,"./float":25}],25:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTexture } = require('./index');

class GLTextureFloat extends GLTexture {
  get textureType() {
    return this.context.FLOAT;
  }
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  renderRawOutput() {
    const gl = this.context;
    const size = this.size;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      this.texture,
      0
    );
    const result = new Float32Array(size[0] * size[1] * 4);
    gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.FLOAT, result);
    return result;
  }
  renderValues() {
    if (this._deleted) return null;
    return this.renderRawOutput();
  }
  toArray() {
    return utils.erectFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureFloat
};
},{"../../../utils":114,"./index":27}],26:[function(require,module,exports){
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureGraphical extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return this.renderValues();
  }
}

module.exports = {
  GLTextureGraphical
};
},{"./unsigned":33}],27:[function(require,module,exports){
const { Texture } = require('../../../texture');

class GLTexture extends Texture {
  get textureType() {
    throw new Error(`"textureType" not implemented on ${ this.name }`);
  }

  clone() {
    return new this.constructor(this);
  }

  beforeMutate() {
    if (this.texture._refs > 1) {
      this.newTexture();
      return true;
    }
    return false;
  }

  cloneTexture() {
    this.texture._refs--;
    const { context: gl, size, texture, kernel } = this;
    if (kernel.debug) {
      console.warn('cloning internal texture');
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    selectTexture(gl, texture);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const target = gl.createTexture();
    selectTexture(gl, target);
    gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, size[0], size[1]);
    target._refs = 1;
    this.texture = target;
  }

  newTexture() {
    this.texture._refs--;
    const gl = this.context;
    const size = this.size;
    const kernel = this.kernel;
    if (kernel.debug) {
      console.warn('new internal texture');
    }
    const target = gl.createTexture();
    selectTexture(gl, target);
    gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    target._refs = 1;
    this.texture = target;
  }

  clear() {
    if (this.texture._refs) {
      this.texture._refs--;
      const gl = this.context;
      const target = this.texture = gl.createTexture();
      selectTexture(gl, target);
      const size = this.size;
      target._refs = 1;
      gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    }
    const { context: gl, texture } = this;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    gl.bindTexture(gl.TEXTURE_2D, texture);
    selectTexture(gl, texture);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  }

  delete() {
    if (this._deleted) return;
    this._deleted = true;
    if (this.texture._refs) {
      this.texture._refs--;
      if (this.texture._refs) return;
    }
    this.context.deleteTexture(this.texture);
  }

  framebuffer() {
    if (!this._framebuffer) {
      this._framebuffer = this.kernel.getRawValueFramebuffer(this.size[0], this.size[1]);
    }
    return this._framebuffer;
  }
}

function selectTexture(gl, texture) {
  gl.activeTexture(gl.TEXTURE15);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
}

module.exports = { GLTexture };
},{"../../../texture":113}],28:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureMemoryOptimized2D
};
},{"../../../utils":114,"./float":25}],29:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureMemoryOptimized3D
};
},{"../../../utils":114,"./float":25}],30:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimizedFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureMemoryOptimized
};
},{"../../../utils":114,"./float":25}],31:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureUnsigned2D extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  toArray() {
    return utils.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureUnsigned2D
};
},{"../../../utils":114,"./unsigned":33}],32:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureUnsigned3D extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  toArray() {
    return utils.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureUnsigned3D
};
},{"../../../utils":114,"./unsigned":33}],33:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTexture } = require('./index');

class GLTextureUnsigned extends GLTexture {
  get textureType() {
    return this.context.UNSIGNED_BYTE;
  }
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  renderRawOutput() {
    const { context: gl } = this;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      this.texture,
      0
    );
    const result = new Uint8Array(this.size[0] * this.size[1] * 4);
    gl.readPixels(0, 0, this.size[0], this.size[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
    return result;
  }
  renderValues() {
    if (this._deleted) return null;
    return new Float32Array(this.renderRawOutput().buffer);
  }
  toArray() {
    return utils.erectPackedFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureUnsigned
};
},{"../../../utils":114,"./index":27}],34:[function(require,module,exports){
const getContext = require('gl');
const { WebGLKernel } = require('../web-gl/kernel');
const { glKernelString } = require('../gl/kernel-string');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;
let features = null;

class HeadlessGLKernel extends WebGLKernel {
  static get isSupported() {
    if (isSupported !== null) return isSupported;
    this.setupFeatureChecks();
    isSupported = testContext !== null;
    return isSupported;
  }

  static setupFeatureChecks() {
    testCanvas = null;
    testExtensions = null;
    if (typeof getContext !== 'function') return;
    try { 
      testContext = getContext(2, 2, {
        preserveDrawingBuffer: true
      });
      if (!testContext || !testContext.getExtension) return;
      testExtensions = {
        STACKGL_resize_drawingbuffer: testContext.getExtension('STACKGL_resize_drawingbuffer'),
        STACKGL_destroy_context: testContext.getExtension('STACKGL_destroy_context'),
        OES_texture_float: testContext.getExtension('OES_texture_float'),
        OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
        OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
        WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
        WEBGL_color_buffer_float: testContext.getExtension('WEBGL_color_buffer_float'),
      };
      features = this.getFeatures();
    } catch (e) {
      console.warn(e);
    }
  }

  static isContextMatch(context) {
    try {
      return context.getParameter(context.RENDERER) === 'ANGLE';
    } catch (e) {
      return false;
    }
  }

  static getIsTextureFloat() {
    return Boolean(testExtensions.OES_texture_float);
  }

  static getIsDrawBuffers() {
    return Boolean(testExtensions.WEBGL_draw_buffers);
  }

  static getChannelCount() {
    return testExtensions.WEBGL_draw_buffers ?
      testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
      1;
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  initCanvas() {
    return {};
  }

  initContext() {
    return getContext(2, 2, {
      preserveDrawingBuffer: true
    });
  }

  initExtensions() {
    this.extensions = {
      STACKGL_resize_drawingbuffer: this.context.getExtension('STACKGL_resize_drawingbuffer'),
      STACKGL_destroy_context: this.context.getExtension('STACKGL_destroy_context'),
      OES_texture_float: this.context.getExtension('OES_texture_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
    };
  }

  build() {
    super.build.apply(this, arguments);
    if (!this.fallbackRequested) {
      this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
    }
  }

  destroyExtensions() {
    this.extensions.STACKGL_resize_drawingbuffer = null;
    this.extensions.STACKGL_destroy_context = null;
    this.extensions.OES_texture_float = null;
    this.extensions.OES_texture_float_linear = null;
    this.extensions.OES_element_index_uint = null;
    this.extensions.WEBGL_draw_buffers = null;
  }

  static destroyContext(context) {
    const extension = context.getExtension('STACKGL_destroy_context');
    if (extension && extension.destroy) {
      extension.destroy();
    }
  }

  toString() {
    const setupContextString = `const gl = context || require('gl')(1, 1);\n`;
    const destroyContextString = `    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }\n`;
    return glKernelString(this.constructor, arguments, this, setupContextString, destroyContextString);
  }

  setOutput(output) {
    super.setOutput(output);
    if (this.graphical && this.extensions.STACKGL_resize_drawingbuffer) {
      this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
    }
    return this;
  }
}

module.exports = {
  HeadlessGLKernel
};
},{"../gl/kernel-string":12,"../web-gl/kernel":70,"gl":2}],35:[function(require,module,exports){
class KernelValue {
  constructor(value, settings) {
    const {
      name,
      kernel,
      context,
      checkContext,
      onRequestContextHandle,
      onUpdateValueMismatch,
      origin,
      strictIntegers,
      type,
      tactic,
    } = settings;
    if (!name) {
      throw new Error('name not set');
    }
    if (!type) {
      throw new Error('type not set');
    }
    if (!origin) {
      throw new Error('origin not set');
    }
    if (origin !== 'user' && origin !== 'constants') {
      throw new Error(`origin must be "user" or "constants" value is "${ origin }"`);
    }
    if (!onRequestContextHandle) {
      throw new Error('onRequestContextHandle is not set');
    }
    this.name = name;
    this.origin = origin;
    this.tactic = tactic;
    this.varName = origin === 'constants' ? `constants.${name}` : name;
    this.kernel = kernel;
    this.strictIntegers = strictIntegers;
    this.type = value.type || type;
    this.size = value.size || null;
    this.index = null;
    this.context = context;
    this.checkContext = checkContext !== null && checkContext !== undefined ? checkContext : true;
    this.contextHandle = null;
    this.onRequestContextHandle = onRequestContextHandle;
    this.onUpdateValueMismatch = onUpdateValueMismatch;
    this.forceUploadEachRun = null;
  }

  get id() {
    return `${this.origin}_${name}`;
  }

  getSource() {
    throw new Error(`"getSource" not defined on ${ this.constructor.name }`);
  }

  updateValue(value) {
    throw new Error(`"updateValue" not defined on ${ this.constructor.name }`);
  }
}

module.exports = {
  KernelValue
};
},{}],36:[function(require,module,exports){
const { utils } = require('../utils');
const { Input } = require('../input');

class Kernel {
  static get isSupported() {
    throw new Error(`"isSupported" not implemented on ${ this.name }`);
  }

  static isContextMatch(context) {
    throw new Error(`"isContextMatch" not implemented on ${ this.name }`);
  }

  static getFeatures() {
    throw new Error(`"getFeatures" not implemented on ${ this.name }`);
  }

  static destroyContext(context) {
    throw new Error(`"destroyContext" called on ${ this.name }`);
  }

  static nativeFunctionArguments() {
    throw new Error(`"nativeFunctionArguments" called on ${ this.name }`);
  }

  static nativeFunctionReturnType() {
    throw new Error(`"nativeFunctionReturnType" called on ${ this.name }`);
  }

  static combineKernels() {
    throw new Error(`"combineKernels" called on ${ this.name }`);
  }

  constructor(source, settings) {
    if (typeof source !== 'object') {
      if (typeof source !== 'string') {
        throw new Error('source not a string');
      }
      if (!utils.isFunctionString(source)) {
        throw new Error('source not a function string');
      }
    }
    this.useLegacyEncoder = false;
    this.fallbackRequested = false;
    this.onRequestFallback = null;

    this.argumentNames = typeof source === 'string' ? utils.getArgumentNamesFromString(source) : null;
    this.argumentTypes = null;
    this.argumentSizes = null;
    this.argumentBitRatios = null;
    this.kernelArguments = null;
    this.kernelConstants = null;
    this.forceUploadKernelConstants = null;


    this.source = source;

    this.output = null;

    this.debug = false;

    this.graphical = false;

    this.loopMaxIterations = 0;

    this.constants = null;

    this.constantTypes = null;

    this.constantBitRatios = null;

    this.dynamicArguments = false;

    this.dynamicOutput = false;

    this.canvas = null;

    this.context = null;

    this.checkContext = null;

    this.gpu = null;

    this.functions = null;

    this.nativeFunctions = null;

    this.injectedNative = null;

    this.subKernels = null;

    this.validate = true;

    this.immutable = false;

    this.pipeline = false;

    this.precision = null;

    this.tactic = null;

    this.plugins = null;

    this.returnType = null;
    this.leadingReturnStatement = null;
    this.followingReturnStatement = null;
    this.optimizeFloatMemory = null;
    this.strictIntegers = false;
    this.fixIntegerDivisionAccuracy = null;
    this.built = false;
    this.signature = null;
  }

  mergeSettings(settings) {
    for (let p in settings) {
      if (!settings.hasOwnProperty(p) || !this.hasOwnProperty(p)) continue;
      switch (p) {
        case 'output':
          if (!Array.isArray(settings.output)) {
            this.setOutput(settings.output); 
            continue;
          }
          break;
        case 'functions':
          this.functions = [];
          for (let i = 0; i < settings.functions.length; i++) {
            this.addFunction(settings.functions[i]);
          }
          continue;
        case 'graphical':
          if (settings[p] && !settings.hasOwnProperty('precision')) {
            this.precision = 'unsigned';
          }
          this[p] = settings[p];
          continue;
        case 'nativeFunctions':
          if (!settings.nativeFunctions) continue;
          this.nativeFunctions = [];
          for (let i = 0; i < settings.nativeFunctions.length; i++) {
            const s = settings.nativeFunctions[i];
            const { name, source } = s;
            this.addNativeFunction(name, source, s);
          }
          continue;
      }
      this[p] = settings[p];
    }

    if (!this.canvas) this.canvas = this.initCanvas();
    if (!this.context) this.context = this.initContext();
    if (!this.plugins) this.plugins = this.initPlugins(settings);
  }
  build() {
    throw new Error(`"build" not defined on ${ this.constructor.name }`);
  }

  run() {
    throw new Error(`"run" not defined on ${ this.constructor.name }`)
  }

  initCanvas() {
    throw new Error(`"initCanvas" not defined on ${ this.constructor.name }`);
  }

  initContext() {
    throw new Error(`"initContext" not defined on ${ this.constructor.name }`);
  }

  initPlugins(settings) {
    throw new Error(`"initPlugins" not defined on ${ this.constructor.name }`);
  }

  addFunction(source, settings = {}) {
    if (source.name && source.source && source.argumentTypes && 'returnType' in source) {
      this.functions.push(source);
    } else if ('settings' in source && 'source' in source) {
      this.functions.push(this.functionToIGPUFunction(source.source, source.settings));
    } else if (typeof source === 'string' || typeof source === 'function') {
      this.functions.push(this.functionToIGPUFunction(source, settings));
    } else {
      throw new Error(`function not properly defined`);
    }
    return this;
  }

  addNativeFunction(name, source, settings = {}) {
    const { argumentTypes, argumentNames } = settings.argumentTypes ?
      splitArgumentTypes(settings.argumentTypes) :
      this.constructor.nativeFunctionArguments(source) || {};
    this.nativeFunctions.push({
      name,
      source,
      settings,
      argumentTypes,
      argumentNames,
      returnType: settings.returnType || this.constructor.nativeFunctionReturnType(source)
    });
    return this;
  }

  setupArguments(args) {
    this.kernelArguments = [];
    if (!this.argumentTypes) {
      if (!this.argumentTypes) {
        this.argumentTypes = [];
        for (let i = 0; i < args.length; i++) {
          const argType = utils.getVariableType(args[i], this.strictIntegers);
          const type = argType === 'Integer' ? 'Number' : argType;
          this.argumentTypes.push(type);
          this.kernelArguments.push({
            type
          });
        }
      }
    } else {
      for (let i = 0; i < this.argumentTypes.length; i++) {
        this.kernelArguments.push({
          type: this.argumentTypes[i]
        });
      }
    }

    this.argumentSizes = new Array(args.length);
    this.argumentBitRatios = new Int32Array(args.length);

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      this.argumentSizes[i] = arg.constructor === Input ? arg.size : null;
      this.argumentBitRatios[i] = this.getBitRatio(arg);
    }

    if (this.argumentNames.length !== args.length) {
      throw new Error(`arguments are miss-aligned`);
    }
  }

  setupConstants() {
    this.kernelConstants = [];
    let needsConstantTypes = this.constantTypes === null;
    if (needsConstantTypes) {
      this.constantTypes = {};
    }
    this.constantBitRatios = {};
    if (this.constants) {
      for (let name in this.constants) {
        if (needsConstantTypes) {
          const type = utils.getVariableType(this.constants[name], this.strictIntegers);
          this.constantTypes[name] = type;
          this.kernelConstants.push({
            name,
            type
          });
        } else {
          this.kernelConstants.push({
            name,
            type: this.constantTypes[name]
          });
        }
        this.constantBitRatios[name] = this.getBitRatio(this.constants[name]);
      }
    }
  }

  setOptimizeFloatMemory(flag) {
    this.optimizeFloatMemory = flag;
    return this;
  }

  toKernelOutput(output) {
    if (output.hasOwnProperty('x')) {
      if (output.hasOwnProperty('y')) {
        if (output.hasOwnProperty('z')) {
          return [output.x, output.y, output.z];
        } else {
          return [output.x, output.y];
        }
      } else {
        return [output.x];
      }
    } else {
      return output;
    }
  }

  setOutput(output) {
    this.output = this.toKernelOutput(output);
    return this;
  }

  setDebug(flag) {
    this.debug = flag;
    return this;
  }

  setGraphical(flag) {
    this.graphical = flag;
    this.precision = 'unsigned';
    return this;
  }

  setLoopMaxIterations(max) {
    this.loopMaxIterations = max;
    return this;
  }

  setConstants(constants) {
    this.constants = constants;
    return this;
  }

  setConstantTypes(constantTypes) {
    this.constantTypes = constantTypes;
    return this;
  }

  setFunctions(functions) {
    for (let i = 0; i < functions.length; i++) {
      this.addFunction(functions[i]);
    }
    return this;
  }

  setNativeFunctions(nativeFunctions) {
    for (let i = 0; i < nativeFunctions.length; i++) {
      const settings = nativeFunctions[i];
      const { name, source } = settings;
      this.addNativeFunction(name, source, settings);
    }
    return this;
  }

  setInjectedNative(injectedNative) {
    this.injectedNative = injectedNative;
    return this;
  }

  setPipeline(flag) {
    this.pipeline = flag;
    return this;
  }

  setPrecision(flag) {
    this.precision = flag;
    return this;
  }

  setDimensions(flag) {
    utils.warnDeprecated('method', 'setDimensions', 'setOutput');
    this.output = flag;
    return this;
  }

  setOutputToTexture(flag) {
    utils.warnDeprecated('method', 'setOutputToTexture', 'setPipeline');
    this.pipeline = flag;
    return this;
  }

  setImmutable(flag) {
    this.immutable = flag;
    return this;
  }

  setCanvas(canvas) {
    this.canvas = canvas;
    return this;
  }

  setStrictIntegers(flag) {
    this.strictIntegers = flag;
    return this;
  }

  setDynamicOutput(flag) {
    this.dynamicOutput = flag;
    return this;
  }

  setHardcodeConstants(flag) {
    utils.warnDeprecated('method', 'setHardcodeConstants');
    this.setDynamicOutput(flag);
    this.setDynamicArguments(flag);
    return this;
  }

  setDynamicArguments(flag) {
    this.dynamicArguments = flag;
    return this;
  }

  setUseLegacyEncoder(flag) {
    this.useLegacyEncoder = flag;
    return this;
  }

  setWarnVarUsage(flag) {
    utils.warnDeprecated('method', 'setWarnVarUsage');
    return this;
  }

  getCanvas() {
    utils.warnDeprecated('method', 'getCanvas');
    return this.canvas;
  }

  getWebGl() {
    utils.warnDeprecated('method', 'getWebGl');
    return this.context;
  }

  setContext(context) {
    this.context = context;
    return this;
  }

  setArgumentTypes(argumentTypes) {
    if (Array.isArray(argumentTypes)) {
      this.argumentTypes = argumentTypes;
    } else {
      this.argumentTypes = [];
      for (const p in argumentTypes) {
        if (!argumentTypes.hasOwnProperty(p)) continue;
        const argumentIndex = this.argumentNames.indexOf(p);
        if (argumentIndex === -1) throw new Error(`unable to find argument ${ p }`);
        this.argumentTypes[argumentIndex] = argumentTypes[p];
      }
    }
    return this;
  }

  setTactic(tactic) {
    this.tactic = tactic;
    return this;
  }

  requestFallback(args) {
    if (!this.onRequestFallback) {
      throw new Error(`"onRequestFallback" not defined on ${ this.constructor.name }`);
    }
    this.fallbackRequested = true;
    return this.onRequestFallback(args);
  }

  validateSettings() {
    throw new Error(`"validateSettings" not defined on ${ this.constructor.name }`);
  }

  addSubKernel(subKernel) {
    if (this.subKernels === null) {
      this.subKernels = [];
    }
    if (!subKernel.source) throw new Error('subKernel missing "source" property');
    if (!subKernel.property && isNaN(subKernel.property)) throw new Error('subKernel missing "property" property');
    if (!subKernel.name) throw new Error('subKernel missing "name" property');
    this.subKernels.push(subKernel);
    return this;
  }

  destroy(removeCanvasReferences) {
    throw new Error(`"destroy" called on ${ this.constructor.name }`);
  }

  getBitRatio(value) {
    if (this.precision === 'single') {
      return 4;
    } else if (Array.isArray(value[0])) {
      return this.getBitRatio(value[0]);
    } else if (value.constructor === Input) {
      return this.getBitRatio(value.value);
    }
    switch (value.constructor) {
      case Uint8ClampedArray:
      case Uint8Array:
      case Int8Array:
        return 1;
      case Uint16Array:
      case Int16Array:
        return 2;
      case Float32Array:
      case Int32Array:
      default:
        return 4;
    }
  }

  getPixels(flip) {
    throw new Error(`"getPixels" called on ${ this.constructor.name }`);
  }

  checkOutput() {
    if (!this.output || !utils.isArray(this.output)) throw new Error('kernel.output not an array');
    if (this.output.length < 1) throw new Error('kernel.output is empty, needs at least 1 value');
    for (let i = 0; i < this.output.length; i++) {
      if (isNaN(this.output[i]) || this.output[i] < 1) {
        throw new Error(`${ this.constructor.name }.output[${ i }] incorrectly defined as \`${ this.output[i] }\`, needs to be numeric, and greater than 0`);
      }
    }
  }

  prependString(value) {
    throw new Error(`"prependString" called on ${ this.constructor.name }`);
  }

  hasPrependString(value) {
    throw new Error(`"hasPrependString" called on ${ this.constructor.name }`);
  }

  toJSON() {
    return {
      settings: {
        output: this.output,
        pipeline: this.pipeline,
        argumentNames: this.argumentNames,
        argumentsTypes: this.argumentTypes,
        constants: this.constants,
        pluginNames: this.plugins ? this.plugins.map(plugin => plugin.name) : null,
        returnType: this.returnType,
      }
    };
  }

  buildSignature(args) {
    const Constructor = this.constructor;
    this.signature = Constructor.getSignature(this, Constructor.getArgumentTypes(this, args));
  }

  static getArgumentTypes(kernel, args) {
    const argumentTypes = new Array(args.length);
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      const type = kernel.argumentTypes[i];
      if (arg.type) {
        argumentTypes[i] = arg.type;
      } else {
        switch (type) {
          case 'Number':
          case 'Integer':
          case 'Float':
          case 'ArrayTexture(1)':
            argumentTypes[i] = utils.getVariableType(arg);
            break;
          default:
            argumentTypes[i] = type;
        }
      }
    }
    return argumentTypes;
  }

  static getSignature(kernel, argumentTypes) {
    throw new Error(`"getSignature" not implemented on ${ this.name }`);
  }

  functionToIGPUFunction(source, settings = {}) {
    if (typeof source !== 'string' && typeof source !== 'function') throw new Error('source not a string or function');
    const sourceString = typeof source === 'string' ? source : source.toString();
    let argumentTypes = [];

    if (Array.isArray(settings.argumentTypes)) {
      argumentTypes = settings.argumentTypes;
    } else if (typeof settings.argumentTypes === 'object') {
      argumentTypes = utils.getArgumentNamesFromString(sourceString)
        .map(name => settings.argumentTypes[name]) || [];
    } else {
      argumentTypes = settings.argumentTypes || [];
    }

    return {
      name: utils.getFunctionNameFromString(sourceString) || null,
      source: sourceString,
      argumentTypes,
      returnType: settings.returnType || null,
    };
  }

  onActivate(previousKernel) {}
}

function splitArgumentTypes(argumentTypesObject) {
  const argumentNames = Object.keys(argumentTypesObject);
  const argumentTypes = [];
  for (let i = 0; i < argumentNames.length; i++) {
    const argumentName = argumentNames[i];
    argumentTypes.push(argumentTypesObject[argumentName]);
  }
  return { argumentTypes, argumentNames };
}

module.exports = {
  Kernel
};
},{"../input":110,"../utils":114}],37:[function(require,module,exports){
const fragmentShader = `__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

varying vec2 vTexCoord;

float acosh(float x) {
  return log(x + sqrt(x * x - 1.0));
}

float sinh(float x) {
  return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;
}

float asinh(float x) {
  return log(x + sqrt(x * x + 1.0));
}

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float atanh(float x) {
  x = (x + 1.0) / (x - 1.0);
  if (x < 0.0) {
    return 0.5 * log(-x);
  }
  return 0.5 * log(x);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float cosh(float x) {
  return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; 
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float tanh(float x) {
  float e = exp(2.0 * x);
  return (e - 1.0) / (e + 1.0);
}

float trunc(float x) {
  if (x >= 0.0) {
    return floor(x); 
  } else {
    return ceil(x);
  }
}

vec4 _round(vec4 x) {
  return floor(x + 0.5);
}

float _round(float x) {
  return floor(x + 0.5);
}

const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x / y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(_round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;
  if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;
  return 0.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  if (channel == 0) return texel.r * 255.0;
  if (channel == 1) return texel.g * 255.0;
  if (channel == 2) return texel.b * 255.0;
  if (channel == 3) return texel.a * 255.0;
  return 0.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return texel.r;
  if (channel == 1) return texel.g;
  if (channel == 2) return texel.b;
  if (channel == 3) return texel.a;
  return 0.0;
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture2D(tex, st / vec2(texSize));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
  
  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

void color(sampler2D image) {
  actualColor = texture2D(image, vTexCoord);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

module.exports = {
  fragmentShader
};
},{}],38:[function(require,module,exports){
const { utils } = require('../../utils');
const { FunctionNode } = require('../function-node');

class WebGLFunctionNode extends FunctionNode {
  constructor(source, settings) {
    super(source, settings);
    if (settings && settings.hasOwnProperty('fixIntegerDivisionAccuracy')) {
      this.fixIntegerDivisionAccuracy = settings.fixIntegerDivisionAccuracy;
    }
  }

  astConditionalExpression(ast, retArr) {
    if (ast.type !== 'ConditionalExpression') {
      throw this.astErrorOutput('Not a conditional expression', ast);
    }
    const consequentType = this.getType(ast.consequent);
    const alternateType = this.getType(ast.alternate);
    if (consequentType === null && alternateType === null) {
      retArr.push('if (');
      this.astGeneric(ast.test, retArr);
      retArr.push(') {');
      this.astGeneric(ast.consequent, retArr);
      retArr.push(';');
      retArr.push('} else {');
      this.astGeneric(ast.alternate, retArr);
      retArr.push(';');
      retArr.push('}');
      return retArr;
    }
    retArr.push('(');
    this.astGeneric(ast.test, retArr);
    retArr.push('?');
    this.astGeneric(ast.consequent, retArr);
    retArr.push(':');
    this.astGeneric(ast.alternate, retArr);
    retArr.push(')');
    return retArr;
  }

  astFunction(ast, retArr) {
    if (this.isRootKernel) {
      retArr.push('void');
    } else {
      if (!this.returnType) {
        const lastReturn = this.findLastReturn();
        if (lastReturn) {
          this.returnType = this.getType(ast.body);
          if (this.returnType === 'LiteralInteger') {
            this.returnType = 'Number';
          }
        }
      }

      const { returnType } = this;
      if (!returnType) {
        retArr.push('void');
      } else {
        const type = typeMap[returnType];
        if (!type) {
          throw new Error(`unknown type ${returnType}`);
        }
        retArr.push(type);
      }
    }
    retArr.push(' ');
    retArr.push(this.name);
    retArr.push('(');

    if (!this.isRootKernel) {
      for (let i = 0; i < this.argumentNames.length; ++i) {
        const argumentName = this.argumentNames[i];

        if (i > 0) {
          retArr.push(', ');
        }
        let argumentType = this.argumentTypes[this.argumentNames.indexOf(argumentName)];
        if (!argumentType) {
          throw this.astErrorOutput(`Unknown argument ${argumentName} type`, ast);
        }
        if (argumentType === 'LiteralInteger') {
          this.argumentTypes[i] = argumentType = 'Number';
        }
        const type = typeMap[argumentType];
        if (!type) {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        const name = utils.sanitizeName(argumentName);
        if (type === 'sampler2D' || type === 'sampler2DArray') {
          retArr.push(`${type} user_${name},ivec2 user_${name}Size,ivec3 user_${name}Dim`);
        } else {
          retArr.push(`${type} user_${name}`);
        }
      }
    }

    retArr.push(') {\n');

    for (let i = 0; i < ast.body.body.length; ++i) {
      this.astGeneric(ast.body.body[i], retArr);
      retArr.push('\n');
    }

    retArr.push('}\n');
    return retArr;
  }

  astReturnStatement(ast, retArr) {
    if (!ast.argument) throw this.astErrorOutput('Unexpected return statement', ast);
    this.pushState('skip-literal-correction');
    const type = this.getType(ast.argument);
    this.popState('skip-literal-correction');

    const result = [];

    if (!this.returnType) {
      if (type === 'LiteralInteger' || type === 'Integer') {
        this.returnType = 'Number';
      } else {
        this.returnType = type;
      }
    }

    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Float':
        switch (type) {
          case 'Integer':
            result.push('float(');
            this.astGeneric(ast.argument, result);
            result.push(')');
            break;
          case 'LiteralInteger':
            this.castLiteralToFloat(ast.argument, result);

            if (this.getType(ast) === 'Integer') {
              result.unshift('float(');
              result.push(')');
            }
            break;
          default:
            this.astGeneric(ast.argument, result);
        }
        break;
      case 'Integer':
        switch (type) {
          case 'Float':
          case 'Number':
            this.castValueToInteger(ast.argument, result);
            break;
          case 'LiteralInteger':
            this.castLiteralToInteger(ast.argument, result);
            break;
          default:
            this.astGeneric(ast.argument, result);
        }
        break;
      case 'Array(4)':
      case 'Array(3)':
      case 'Array(2)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
      case 'Input':
        this.astGeneric(ast.argument, result);
        break;
      default:
        throw this.astErrorOutput(`unhandled return type ${this.returnType}`, ast);
    }

    if (this.isRootKernel) {
      retArr.push(`kernelResult = ${ result.join('') };`);
      retArr.push('return;');
    } else if (this.isSubKernel) {
      retArr.push(`subKernelResult_${ this.name } = ${ result.join('') };`);
      retArr.push(`return subKernelResult_${ this.name };`);
    } else {
      retArr.push(`return ${ result.join('') };`);
    }
    return retArr;
  }

  astLiteral(ast, retArr) {
    if (isNaN(ast.value)) {
      throw this.astErrorOutput(
        'Non-numeric literal not supported : ' + ast.value,
        ast
      );
    }

    const key = this.astKey(ast);
    if (Number.isInteger(ast.value)) {
      if (this.isState('casting-to-integer') || this.isState('building-integer')) {
        this.literalTypes[key] = 'Integer';
        retArr.push(`${ast.value}`);
      } else if (this.isState('casting-to-float') || this.isState('building-float')) {
        this.literalTypes[key] = 'Number';
        retArr.push(`${ast.value}.0`);
      } else {
        this.literalTypes[key] = 'Number';
        retArr.push(`${ast.value}.0`);
      }
    } else if (this.isState('casting-to-integer') || this.isState('building-integer')) {
      this.literalTypes[key] = 'Integer';
      retArr.push(Math.round(ast.value));
    } else {
      this.literalTypes[key] = 'Number';
      retArr.push(`${ast.value}`);
    }
    return retArr;
  }

  astBinaryExpression(ast, retArr) {
    if (this.checkAndUpconvertOperator(ast, retArr)) {
      return retArr;
    }

    if (this.fixIntegerDivisionAccuracy && ast.operator === '/') {
      retArr.push('divWithIntCheck(');
      this.pushState('building-float');
      switch (this.getType(ast.left)) {
        case 'Integer':
          this.castValueToFloat(ast.left, retArr);
          break;
        case 'LiteralInteger':
          this.castLiteralToFloat(ast.left, retArr);
          break;
        default:
          this.astGeneric(ast.left, retArr);
      }
      retArr.push(', ');
      switch (this.getType(ast.right)) {
        case 'Integer':
          this.castValueToFloat(ast.right, retArr);
          break;
        case 'LiteralInteger':
          this.castLiteralToFloat(ast.right, retArr);
          break;
        default:
          this.astGeneric(ast.right, retArr);
      }
      this.popState('building-float');
      retArr.push(')');
      return retArr;
    }

    retArr.push('(');
    const leftType = this.getType(ast.left) || 'Number';
    const rightType = this.getType(ast.right) || 'Number';
    if (!leftType || !rightType) {
      throw this.astErrorOutput(`Unhandled binary expression`, ast);
    }
    const key = leftType + ' & ' + rightType;
    switch (key) {
      case 'Integer & Integer':
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-integer');
        break;
      case 'Number & Float':
      case 'Float & Number':
      case 'Float & Float':
      case 'Number & Number':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'LiteralInteger & LiteralInteger':
        if (this.isState('casting-to-integer') || this.isState('building-integer')) {
          this.pushState('building-integer');
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.astGeneric(ast.right, retArr);
          this.popState('building-integer');
        } else {
          this.pushState('building-float');
          this.castLiteralToFloat(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.castLiteralToFloat(ast.right, retArr);
          this.popState('building-float');
        }
        break;

      case 'Integer & Float':
      case 'Integer & Number':
        if (ast.operator === '>' || ast.operator === '<' && ast.right.type === 'Literal') {
          if (!Number.isInteger(ast.right.value)) {
            this.pushState('building-float');
            this.castValueToFloat(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.astGeneric(ast.right, retArr);
            this.popState('building-float');
            break;
          }
        }
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.pushState('casting-to-integer');
        if (ast.right.type === 'Literal') {
          const literalResult = [];
          this.astGeneric(ast.right, literalResult);
          const literalType = this.getType(ast.right);
          if (literalType === 'Integer') {
            retArr.push(literalResult.join(''));
          } else {
            throw this.astErrorOutput(`Unhandled binary expression with literal`, ast);
          }
        } else {
          retArr.push('int(');
          this.astGeneric(ast.right, retArr);
          retArr.push(')');
        }
        this.popState('casting-to-integer');
        this.popState('building-integer');
        break;
      case 'Integer & LiteralInteger':
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castLiteralToInteger(ast.right, retArr);
        this.popState('building-integer');
        break;

      case 'Number & Integer':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castValueToFloat(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'Float & LiteralInteger':
      case 'Number & LiteralInteger':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castLiteralToFloat(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'LiteralInteger & Float':
      case 'LiteralInteger & Number':
        if (this.isState('casting-to-integer')) {
          this.pushState('building-integer');
          this.castLiteralToInteger(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.castValueToInteger(ast.right, retArr);
          this.popState('building-integer');
        } else {
          this.pushState('building-float');
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.pushState('casting-to-float');
          this.astGeneric(ast.right, retArr);
          this.popState('casting-to-float');
          this.popState('building-float');
        }
        break;
      case 'LiteralInteger & Integer':
        this.pushState('building-integer');
        this.castLiteralToInteger(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-integer');
        break;

      case 'Boolean & Boolean':
        this.pushState('building-boolean');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-boolean');
        break;

      case 'Float & Integer':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castValueToFloat(ast.right, retArr);
        this.popState('building-float');
        break;

      default:
        throw this.astErrorOutput(`Unhandled binary expression between ${key}`, ast);
    }
    retArr.push(')');

    return retArr;
  }

  checkAndUpconvertOperator(ast, retArr) {
    const bitwiseResult = this.checkAndUpconvertBitwiseOperators(ast, retArr);
    if (bitwiseResult) {
      return bitwiseResult;
    }
    const upconvertableOperators = {
      '%': this.fixIntegerDivisionAccuracy ? 'integerCorrectionModulo' : 'modulo',
      '**': 'pow',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    switch (this.getType(ast.left)) {
      case 'Integer':
        this.castValueToFloat(ast.left, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToFloat(ast.left, retArr);
        break;
      default:
        this.astGeneric(ast.left, retArr);
    }
    retArr.push(',');
    switch (this.getType(ast.right)) {
      case 'Integer':
        this.castValueToFloat(ast.right, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToFloat(ast.right, retArr);
        break;
      default:
        this.astGeneric(ast.right, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  checkAndUpconvertBitwiseOperators(ast, retArr) {
    const upconvertableOperators = {
      '&': 'bitwiseAnd',
      '|': 'bitwiseOr',
      '^': 'bitwiseXOR',
      '<<': 'bitwiseZeroFillLeftShift',
      '>>': 'bitwiseSignedRightShift',
      '>>>': 'bitwiseZeroFillRightShift',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    const leftType = this.getType(ast.left);
    switch (leftType) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.left, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.left, retArr);
        break;
      default:
        this.astGeneric(ast.left, retArr);
    }
    retArr.push(',');
    const rightType = this.getType(ast.right);
    switch (rightType) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.right, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.right, retArr);
        break;
      default:
        this.astGeneric(ast.right, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  checkAndUpconvertBitwiseUnary(ast, retArr) {
    const upconvertableOperators = {
      '~': 'bitwiseNot',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    switch (this.getType(ast.argument)) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.argument, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.argument, retArr);
        break;
      default:
        this.astGeneric(ast.argument, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  castLiteralToInteger(ast, retArr) {
    this.pushState('casting-to-integer');
    this.astGeneric(ast, retArr);
    this.popState('casting-to-integer');
    return retArr;
  }

  castLiteralToFloat(ast, retArr) {
    this.pushState('casting-to-float');
    this.astGeneric(ast, retArr);
    this.popState('casting-to-float');
    return retArr;
  }

  castValueToInteger(ast, retArr) {
    this.pushState('casting-to-integer');
    retArr.push('int(');
    this.astGeneric(ast, retArr);
    retArr.push(')');
    this.popState('casting-to-integer');
    return retArr;
  }

  castValueToFloat(ast, retArr) {
    this.pushState('casting-to-float');
    retArr.push('float(');
    this.astGeneric(ast, retArr);
    retArr.push(')');
    this.popState('casting-to-float');
    return retArr;
  }

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
    }

    const type = this.getType(idtNode);

    const name = utils.sanitizeName(idtNode.name);
    if (idtNode.name === 'Infinity') {
      retArr.push('3.402823466e+38');
    } else if (type === 'Boolean') {
      if (this.argumentNames.indexOf(name) > -1) {
        retArr.push(`bool(user_${name})`);
      } else {
        retArr.push(`user_${name}`);
      }
    } else {
      retArr.push(`user_${name}`);
    }

    return retArr;
  }

  astForStatement(forNode, retArr) {
    if (forNode.type !== 'ForStatement') {
      throw this.astErrorOutput('Invalid for statement', forNode);
    }

    const initArr = [];
    const testArr = [];
    const updateArr = [];
    const bodyArr = [];
    let isSafe = null;

    if (forNode.init) {
      const { declarations } = forNode.init;
      if (declarations.length > 1) {
        isSafe = false;
      }
      this.astGeneric(forNode.init, initArr);
      for (let i = 0; i < declarations.length; i++) {
        if (declarations[i].init && declarations[i].init.type !== 'Literal') {
          isSafe = false;
        }
      }
    } else {
      isSafe = false;
    }

    if (forNode.test) {
      this.astGeneric(forNode.test, testArr);
    } else {
      isSafe = false;
    }

    if (forNode.update) {
      this.astGeneric(forNode.update, updateArr);
    } else {
      isSafe = false;
    }

    if (forNode.body) {
      this.pushState('loop-body');
      this.astGeneric(forNode.body, bodyArr);
      this.popState('loop-body');
    }

    if (isSafe === null) {
      isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
    }

    if (isSafe) {
      const initString = initArr.join('');
      const initNeedsSemiColon = initString[initString.length - 1] !== ';';
      retArr.push(`for (${initString}${initNeedsSemiColon ? ';' : ''}${testArr.join('')};${updateArr.join('')}){\n`);
      retArr.push(bodyArr.join(''));
      retArr.push('}\n');
    } else {
      const iVariableName = this.getInternalVariableName('safeI');
      if (initArr.length > 0) {
        retArr.push(initArr.join(''), '\n');
      }
      retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
      if (testArr.length > 0) {
        retArr.push(`if (!${testArr.join('')}) break;\n`);
      }
      retArr.push(bodyArr.join(''));
      retArr.push(`\n${updateArr.join('')};`);
      retArr.push('}\n');
    }
    return retArr;
  }

  astWhileStatement(whileNode, retArr) {
    if (whileNode.type !== 'WhileStatement') {
      throw this.astErrorOutput('Invalid while statement', whileNode);
    }

    const iVariableName = this.getInternalVariableName('safeI');
    retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
    retArr.push('if (!');
    this.astGeneric(whileNode.test, retArr);
    retArr.push(') break;\n');
    this.astGeneric(whileNode.body, retArr);
    retArr.push('}\n');

    return retArr;
  }

  astDoWhileStatement(doWhileNode, retArr) {
    if (doWhileNode.type !== 'DoWhileStatement') {
      throw this.astErrorOutput('Invalid while statement', doWhileNode);
    }

    const iVariableName = this.getInternalVariableName('safeI');
    retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
    this.astGeneric(doWhileNode.body, retArr);
    retArr.push('if (!');
    this.astGeneric(doWhileNode.test, retArr);
    retArr.push(') break;\n');
    retArr.push('}\n');

    return retArr;
  }


  astAssignmentExpression(assNode, retArr) {
    if (assNode.operator === '%=') {
      this.astGeneric(assNode.left, retArr);
      retArr.push('=');
      retArr.push('mod(');
      this.astGeneric(assNode.left, retArr);
      retArr.push(',');
      this.astGeneric(assNode.right, retArr);
      retArr.push(')');
    } else if (assNode.operator === '**=') {
      this.astGeneric(assNode.left, retArr);
      retArr.push('=');
      retArr.push('pow(');
      this.astGeneric(assNode.left, retArr);
      retArr.push(',');
      this.astGeneric(assNode.right, retArr);
      retArr.push(')');
    } else {
      const leftType = this.getType(assNode.left);
      const rightType = this.getType(assNode.right);
      this.astGeneric(assNode.left, retArr);
      retArr.push(assNode.operator);
      if (leftType !== 'Integer' && rightType === 'Integer') {
        retArr.push('float(');
        this.astGeneric(assNode.right, retArr);
        retArr.push(')');
      } else {
        this.astGeneric(assNode.right, retArr);
      }
      return retArr;
    }
  }

  astBlockStatement(bNode, retArr) {
    if (this.isState('loop-body')) {
      this.pushState('block-body'); 
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      this.popState('block-body');
    } else {
      retArr.push('{\n');
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      retArr.push('}\n');
    }
    return retArr;
  }

  astVariableDeclaration(varDecNode, retArr) {
    const declarations = varDecNode.declarations;
    if (!declarations || !declarations[0] || !declarations[0].init) {
      throw this.astErrorOutput('Unexpected expression', varDecNode);
    }
    const result = [];
    let lastType = null;
    const declarationSets = [];
    let declarationSet = [];
    for (let i = 0; i < declarations.length; i++) {
      const declaration = declarations[i];
      const init = declaration.init;
      const info = this.getDeclaration(declaration.id);
      const actualType = this.getType(declaration.init);
      let type = actualType;
      if (type === 'LiteralInteger') {
        if (info.suggestedType === 'Integer') {
          type = 'Integer';
        } else {
          type = 'Number';
        }
      }
      const markupType = typeMap[type];
      if (!markupType) {
        throw this.astErrorOutput(`Markup type ${ type } not handled`, varDecNode);
      }
      const declarationResult = [];
      if (actualType === 'Integer' && type === 'Integer') {
        info.valueType = 'Number';
        if (i === 0 || lastType === null) {
          declarationResult.push('float ');
        } else if (type !== lastType) {
          throw new Error('Unhandled declaration');
        }
        lastType = type;
        declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
        declarationResult.push('float(');
        this.astGeneric(init, declarationResult);
        declarationResult.push(')');
      } else {
        info.valueType = type;
        if (i === 0 || lastType === null) {
          declarationResult.push(`${markupType} `);
        } else if (type !== lastType) {
          declarationSets.push(declarationSet.join(','));
          declarationSet = [];
          declarationResult.push(`${markupType} `);
        }
        lastType = type;
        declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
        if (actualType === 'Number' && type === 'Integer') {
          if (init.left && init.left.type === 'Literal') {
            this.astGeneric(init, declarationResult);
          } else {
            declarationResult.push('int(');
            this.astGeneric(init, declarationResult);
            declarationResult.push(')');
          }
        } else if (actualType === 'LiteralInteger' && type === 'Integer') {
          this.castLiteralToInteger(init, declarationResult);
        } else {
          this.astGeneric(init, declarationResult);
        }
      }
      declarationSet.push(declarationResult.join(''));
    }

    if (declarationSet.length > 0) {
      declarationSets.push(declarationSet.join(','));
    }

    result.push(declarationSets.join(';'));

    retArr.push(result.join(''));
    retArr.push(';');
    return retArr;
  }

  astIfStatement(ifNode, retArr) {
    retArr.push('if (');
    this.astGeneric(ifNode.test, retArr);
    retArr.push(')');
    if (ifNode.consequent.type === 'BlockStatement') {
      this.astGeneric(ifNode.consequent, retArr);
    } else {
      retArr.push(' {\n');
      this.astGeneric(ifNode.consequent, retArr);
      retArr.push('\n}\n');
    }

    if (ifNode.alternate) {
      retArr.push('else ');
      if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
        this.astGeneric(ifNode.alternate, retArr);
      } else {
        retArr.push(' {\n');
        this.astGeneric(ifNode.alternate, retArr);
        retArr.push('\n}\n');
      }
    }
    return retArr;
  }

  astSwitchStatement(ast, retArr) {
    if (ast.type !== 'SwitchStatement') {
      throw this.astErrorOutput('Invalid switch statement', ast);
    }
    const { discriminant, cases } = ast;
    const type = this.getType(discriminant);
    const varName = `switchDiscriminant${this.astKey(ast, '_')}`;
    switch (type) {
      case 'Float':
      case 'Number':
        retArr.push(`float ${varName} = `);
        this.astGeneric(discriminant, retArr);
        retArr.push(';\n');
        break;
      case 'Integer':
        retArr.push(`int ${varName} = `);
        this.astGeneric(discriminant, retArr);
        retArr.push(';\n');
        break;
    }
    if (cases.length === 1 && !cases[0].test) {
      this.astGeneric(cases[0].consequent, retArr);
      return retArr;
    }

    let fallingThrough = false;
    let defaultResult = [];
    let movingDefaultToEnd = false;
    let pastFirstIf = false;
    for (let i = 0; i < cases.length; i++) {
      if (!cases[i].test) {
        if (cases.length > i + 1) {
          movingDefaultToEnd = true;
          this.astGeneric(cases[i].consequent, defaultResult);
          continue;
        } else {
          retArr.push(' else {\n');
        }
      } else {
        if (i === 0 || !pastFirstIf) {
          pastFirstIf = true;
          retArr.push(`if (${varName} == `);
        } else {
          if (fallingThrough) {
            retArr.push(`${varName} == `);
            fallingThrough = false;
          } else {
            retArr.push(` else if (${varName} == `);
          }
        }
        if (type === 'Integer') {
          const testType = this.getType(cases[i].test);
          switch (testType) {
            case 'Number':
            case 'Float':
              this.castValueToInteger(cases[i].test, retArr);
              break;
            case 'LiteralInteger':
              this.castLiteralToInteger(cases[i].test, retArr);
              break;
          }
        } else if (type === 'Float') {
          const testType = this.getType(cases[i].test);
          switch (testType) {
            case 'LiteralInteger':
              this.castLiteralToFloat(cases[i].test, retArr);
              break;
            case 'Integer':
              this.castValueToFloat(cases[i].test, retArr);
              break;
          }
        } else {
          throw new Error('unhanlded');
        }
        if (!cases[i].consequent || cases[i].consequent.length === 0) {
          fallingThrough = true;
          retArr.push(' || ');
          continue;
        }
        retArr.push(`) {\n`);
      }
      this.astGeneric(cases[i].consequent, retArr);
      retArr.push('\n}');
    }
    if (movingDefaultToEnd) {
      retArr.push(' else {');
      retArr.push(defaultResult.join(''));
      retArr.push('}');
    }
    return retArr;
  }

  astThisExpression(tNode, retArr) {
    retArr.push('this');
    return retArr;
  }

  astMemberExpression(mNode, retArr) {
    const {
      property,
      name,
      signature,
      origin,
      type,
      xProperty,
      yProperty,
      zProperty
    } = this.getMemberExpressionDetails(mNode);
    switch (signature) {
      case 'value.thread.value':
      case 'this.thread.value':
        if (name !== 'x' && name !== 'y' && name !== 'z') {
          throw this.astErrorOutput('Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`', mNode);
        }
        retArr.push(`threadId.${name}`);
        return retArr;
      case 'this.output.value':
        if (this.dynamicOutput) {
          switch (name) {
            case 'x':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.x)');
              } else {
                retArr.push('uOutputDim.x');
              }
              break;
            case 'y':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.y)');
              } else {
                retArr.push('uOutputDim.y');
              }
              break;
            case 'z':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.z)');
              } else {
                retArr.push('uOutputDim.z');
              }
              break;
            default:
              throw this.astErrorOutput('Unexpected expression', mNode);
          }
        } else {
          switch (name) {
            case 'x':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[0]);
              } else {
                retArr.push(this.output[0], '.0');
              }
              break;
            case 'y':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[1]);
              } else {
                retArr.push(this.output[1], '.0');
              }
              break;
            case 'z':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[2]);
              } else {
                retArr.push(this.output[2], '.0');
              }
              break;
            default:
              throw this.astErrorOutput('Unexpected expression', mNode);
          }
        }
        return retArr;
      case 'value':
        throw this.astErrorOutput('Unexpected expression', mNode);
      case 'value[]':
      case 'value[][]':
      case 'value[][][]':
      case 'value[][][][]':
      case 'value.value':
        if (origin === 'Math') {
          retArr.push(Math[name]);
          return retArr;
        }
        const cleanName = utils.sanitizeName(name);
        switch (property) {
          case 'r':
            retArr.push(`user_${ cleanName }.r`);
            return retArr;
          case 'g':
            retArr.push(`user_${ cleanName }.g`);
            return retArr;
          case 'b':
            retArr.push(`user_${ cleanName }.b`);
            return retArr;
          case 'a':
            retArr.push(`user_${ cleanName }.a`);
            return retArr;
        }
        break;
      case 'this.constants.value':
        if (typeof xProperty === 'undefined') {
          switch (type) {
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              retArr.push(`constants_${ utils.sanitizeName(name) }`);
              return retArr;
          }
        }
        case 'this.constants.value[]':
        case 'this.constants.value[][]':
        case 'this.constants.value[][][]':
        case 'this.constants.value[][][][]':
          break;
        case 'fn()[]':
          this.astCallExpression(mNode.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(property));
          retArr.push(']');
          return retArr;
        case 'fn()[][]':
          this.astCallExpression(mNode.object.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(mNode.object.property));
          retArr.push(']');
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(mNode.property));
          retArr.push(']');
          return retArr;
        case '[][]':
          this.astArrayExpression(mNode.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(property));
          retArr.push(']');
          return retArr;
        default:
          throw this.astErrorOutput('Unexpected expression', mNode);
    }

    if (mNode.computed === false) {
      switch (type) {
        case 'Number':
        case 'Integer':
        case 'Float':
        case 'Boolean':
          retArr.push(`${origin}_${utils.sanitizeName(name)}`);
          return retArr;
      }
    }

    const markupName = `${origin}_${utils.sanitizeName(name)}`;

    switch (type) {
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        this.astGeneric(mNode.object, retArr);
        retArr.push('[');
        retArr.push(this.memberExpressionPropertyMarkup(xProperty));
        retArr.push(']');
        break;
      case 'HTMLImageArray':
        retArr.push(`getImage3D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(1)':
        retArr.push(`getFloatFromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(2)':
      case 'Array2D(2)':
      case 'Array3D(2)':
        retArr.push(`getMemoryOptimizedVec2(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(2)':
        retArr.push(`getVec2FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(3)':
      case 'Array2D(3)':
      case 'Array3D(3)':
        retArr.push(`getMemoryOptimizedVec3(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(3)':
        retArr.push(`getVec3FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(4)':
      case 'Array2D(4)':
      case 'Array3D(4)':
        retArr.push(`getMemoryOptimizedVec4(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(4)':
      case 'HTMLCanvas':
      case 'OffscreenCanvas':
      case 'HTMLImage':
      case 'ImageBitmap':
      case 'ImageData':
      case 'HTMLVideo':
        retArr.push(`getVec4FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'NumberTexture':
      case 'Array':
      case 'Array2D':
      case 'Array3D':
      case 'Array4D':
      case 'Input':
      case 'Number':
      case 'Float':
      case 'Integer':
        if (this.precision === 'single') {
          retArr.push(`getMemoryOptimized32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
        } else {
          const bitRatio = (origin === 'user' ?
            this.lookupFunctionArgumentBitRatio(this.name, name) :
            this.constantBitRatios[name]
          );
          switch (bitRatio) {
            case 1:
              retArr.push(`get8(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            case 2:
              retArr.push(`get16(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            case 4:
            case 0:
              retArr.push(`get32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            default:
              throw new Error(`unhandled bit ratio of ${bitRatio}`);
          }
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
        }
        break;
      case 'MemoryOptimizedNumberTexture':
        retArr.push(`getMemoryOptimized32(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        retArr.push(`${markupName}[${this.memberExpressionPropertyMarkup(yProperty)}]`);
        if (yProperty) {
          retArr.push(`[${this.memberExpressionPropertyMarkup(xProperty)}]`);
        }
        break;
      default:
        throw new Error(`unhandled member expression "${ type }"`);
    }
    return retArr;
  }

  astCallExpression(ast, retArr) {
    if (!ast.callee) {
      throw this.astErrorOutput('Unknown CallExpression', ast);
    }

    let functionName = null;
    const isMathFunction = this.isAstMathFunction(ast);

    if (isMathFunction || (ast.callee.object && ast.callee.object.type === 'ThisExpression')) {
      functionName = ast.callee.property.name;
    }
    else if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[0].type === 'Literal' && !isNaN(ast.callee.expressions[0].raw)) {
      functionName = ast.callee.expressions[1].property.name;
    } else {
      functionName = ast.callee.name;
    }

    if (!functionName) {
      throw this.astErrorOutput(`Unhandled function, couldn't find name`, ast);
    }

    switch (functionName) {
      case 'pow':
        functionName = '_pow';
        break;
      case 'round':
        functionName = '_round';
        break;
    }

    if (this.calledFunctions.indexOf(functionName) < 0) {
      this.calledFunctions.push(functionName);
    }

    if (functionName === 'random' && this.plugins && this.plugins.length > 0) {
      for (let i = 0; i < this.plugins.length; i++) {
        const plugin = this.plugins[i];
        if (plugin.functionMatch === 'Math.random()' && plugin.functionReplace) {
          retArr.push(plugin.functionReplace);
          return retArr;
        }
      }
    }

    if (this.onFunctionCall) {
      this.onFunctionCall(this.name, functionName, ast.arguments);
    }

    retArr.push(functionName);

    retArr.push('(');

    if (isMathFunction) {
      for (let i = 0; i < ast.arguments.length; ++i) {
        const argument = ast.arguments[i];
        const argumentType = this.getType(argument);
        if (i > 0) {
          retArr.push(', ');
        }

        switch (argumentType) {
          case 'Integer':
            this.castValueToFloat(argument, retArr);
            break;
          default:
            this.astGeneric(argument, retArr);
            break;
        }
      }
    } else {
      const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
      for (let i = 0; i < ast.arguments.length; ++i) {
        const argument = ast.arguments[i];
        let targetType = targetTypes[i];
        if (i > 0) {
          retArr.push(', ');
        }
        const argumentType = this.getType(argument);
        if (!targetType) {
          this.triggerImplyArgumentType(functionName, i, argumentType, this);
          targetType = argumentType;
        }
        switch (argumentType) {
          case 'Boolean':
            this.astGeneric(argument, retArr);
            continue;
          case 'Number':
          case 'Float':
            if (targetType === 'Integer') {
              retArr.push('int(');
              this.astGeneric(argument, retArr);
              retArr.push(')');
              continue;
            } else if (targetType === 'Number' || targetType === 'Float') {
              this.astGeneric(argument, retArr);
              continue;
            } else if (targetType === 'LiteralInteger') {
              this.castLiteralToFloat(argument, retArr);
              continue;
            }
            break;
          case 'Integer':
            if (targetType === 'Number' || targetType === 'Float') {
              retArr.push('float(');
              this.astGeneric(argument, retArr);
              retArr.push(')');
              continue;
            } else if (targetType === 'Integer') {
              this.astGeneric(argument, retArr);
              continue;
            }
            break;
          case 'LiteralInteger':
            if (targetType === 'Integer') {
              this.castLiteralToInteger(argument, retArr);
              continue;
            } else if (targetType === 'Number' || targetType === 'Float') {
              this.castLiteralToFloat(argument, retArr);
              continue;
            } else if (targetType === 'LiteralInteger') {
              this.astGeneric(argument, retArr);
              continue;
            }
            break;
          case 'Array(2)':
          case 'Array(3)':
          case 'Array(4)':
            if (targetType === argumentType) {
              if (argument.type === 'Identifier') {
                retArr.push(`user_${utils.sanitizeName(argument.name)}`);
              } else if (argument.type === 'ArrayExpression' || argument.type === 'MemberExpression' || argument.type === 'CallExpression') {
                this.astGeneric(argument, retArr);
              } else {
                throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
              }
              continue;
            }
            break;
          case 'HTMLCanvas':
          case 'OffscreenCanvas':
          case 'HTMLImage':
          case 'ImageBitmap':
          case 'ImageData':
          case 'HTMLImageArray':
          case 'HTMLVideo':
          case 'ArrayTexture(1)':
          case 'ArrayTexture(2)':
          case 'ArrayTexture(3)':
          case 'ArrayTexture(4)':
          case 'Array':
          case 'Input':
            if (targetType === argumentType) {
              if (argument.type !== 'Identifier') throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
              this.triggerImplyArgumentBitRatio(this.name, argument.name, functionName, i);
              const name = utils.sanitizeName(argument.name);
              retArr.push(`user_${name},user_${name}Size,user_${name}Dim`);
              continue;
            }
            break;
        }
        throw this.astErrorOutput(`Unhandled argument combination of ${ argumentType } and ${ targetType } for argument named "${ argument.name }"`, ast);
      }
    }
    retArr.push(')');

    return retArr;
  }

  astArrayExpression(arrNode, retArr) {
    const returnType = this.getType(arrNode);

    const arrLen = arrNode.elements.length;

    switch (returnType) {
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        retArr.push(`mat${arrLen}(`);
        break;
      default:
        retArr.push(`vec${arrLen}(`);
    }
    for (let i = 0; i < arrLen; ++i) {
      if (i > 0) {
        retArr.push(', ');
      }
      const subNode = arrNode.elements[i];
      this.astGeneric(subNode, retArr)
    }
    retArr.push(')');

    return retArr;
  }

  memberExpressionXYZ(x, y, z, retArr) {
    if (z) {
      retArr.push(this.memberExpressionPropertyMarkup(z), ', ');
    } else {
      retArr.push('0, ');
    }
    if (y) {
      retArr.push(this.memberExpressionPropertyMarkup(y), ', ');
    } else {
      retArr.push('0, ');
    }
    retArr.push(this.memberExpressionPropertyMarkup(x));
    return retArr;
  }

  memberExpressionPropertyMarkup(property) {
    if (!property) {
      throw new Error('Property not set');
    }
    const type = this.getType(property);
    const result = [];
    switch (type) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(property, result);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(property, result);
        break;
      default:
        this.astGeneric(property, result);
    }
    return result.join('');
  }
}

const typeMap = {
  'Array': 'sampler2D',
  'Array(2)': 'vec2',
  'Array(3)': 'vec3',
  'Array(4)': 'vec4',
  'Matrix(2)': 'mat2',
  'Matrix(3)': 'mat3',
  'Matrix(4)': 'mat4',
  'Array2D': 'sampler2D',
  'Array3D': 'sampler2D',
  'Boolean': 'bool',
  'Float': 'float',
  'Input': 'sampler2D',
  'Integer': 'int',
  'Number': 'float',
  'LiteralInteger': 'float',
  'NumberTexture': 'sampler2D',
  'MemoryOptimizedNumberTexture': 'sampler2D',
  'ArrayTexture(1)': 'sampler2D',
  'ArrayTexture(2)': 'sampler2D',
  'ArrayTexture(3)': 'sampler2D',
  'ArrayTexture(4)': 'sampler2D',
  'HTMLVideo': 'sampler2D',
  'HTMLCanvas': 'sampler2D',
  'OffscreenCanvas': 'sampler2D',
  'HTMLImage': 'sampler2D',
  'ImageBitmap': 'sampler2D',
  'ImageData': 'sampler2D',
  'HTMLImageArray': 'sampler2DArray',
};

const operatorMap = {
  '===': '==',
  '!==': '!='
};

module.exports = {
  WebGLFunctionNode
};
},{"../../utils":114,"../function-node":10}],39:[function(require,module,exports){
const { WebGLKernelValueBoolean } = require('./kernel-value/boolean');
const { WebGLKernelValueFloat } = require('./kernel-value/float');
const { WebGLKernelValueInteger } = require('./kernel-value/integer');

const { WebGLKernelValueHTMLImage } = require('./kernel-value/html-image');
const { WebGLKernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');

const { WebGLKernelValueHTMLVideo } = require('./kernel-value/html-video');
const { WebGLKernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');

const { WebGLKernelValueSingleInput } = require('./kernel-value/single-input');
const { WebGLKernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');

const { WebGLKernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
const { WebGLKernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');

const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');

const { WebGLKernelValueNumberTexture } = require('./kernel-value/number-texture');
const { WebGLKernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');

const { WebGLKernelValueSingleArray } = require('./kernel-value/single-array');
const { WebGLKernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');

const { WebGLKernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
const { WebGLKernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');

const { WebGLKernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
const { WebGLKernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');

const { WebGLKernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
const { WebGLKernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');

const { WebGLKernelValueArray2 } = require('./kernel-value/array2');
const { WebGLKernelValueArray3 } = require('./kernel-value/array3');
const { WebGLKernelValueArray4 } = require('./kernel-value/array4');

const { WebGLKernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
const { WebGLKernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');

const kernelValueMaps = {
  unsigned: {
    dynamic: {
      'Boolean': WebGLKernelValueBoolean,
      'Integer': WebGLKernelValueInteger,
      'Float': WebGLKernelValueFloat,
      'Array': WebGLKernelValueDynamicUnsignedArray,
      'Array(2)': WebGLKernelValueArray2,
      'Array(3)': WebGLKernelValueArray3,
      'Array(4)': WebGLKernelValueArray4,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGLKernelValueDynamicUnsignedInput,
      'NumberTexture': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
      'OffscreenCanvas': WebGLKernelValueDynamicHTMLImage,
      'HTMLImage': WebGLKernelValueDynamicHTMLImage,
      'ImageBitmap': WebGLKernelValueDynamicHTMLImage,
      'ImageData': WebGLKernelValueDynamicHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGLKernelValueBoolean,
      'Float': WebGLKernelValueFloat,
      'Integer': WebGLKernelValueInteger,
      'Array': WebGLKernelValueUnsignedArray,
      'Array(2)': WebGLKernelValueArray2,
      'Array(3)': WebGLKernelValueArray3,
      'Array(4)': WebGLKernelValueArray4,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGLKernelValueUnsignedInput,
      'NumberTexture': WebGLKernelValueNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueHTMLImage,
      'OffscreenCanvas': WebGLKernelValueHTMLImage,
      'HTMLImage': WebGLKernelValueHTMLImage,
      'ImageBitmap': WebGLKernelValueHTMLImage,
      'ImageData': WebGLKernelValueHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueHTMLVideo,
    }
  },
  single: {
    dynamic: {
      'Boolean': WebGLKernelValueBoolean,
      'Integer': WebGLKernelValueInteger,
      'Float': WebGLKernelValueFloat,
      'Array': WebGLKernelValueDynamicSingleArray,
      'Array(2)': WebGLKernelValueArray2,
      'Array(3)': WebGLKernelValueArray3,
      'Array(4)': WebGLKernelValueArray4,
      'Array1D(2)': WebGLKernelValueDynamicSingleArray1DI,
      'Array1D(3)': WebGLKernelValueDynamicSingleArray1DI,
      'Array1D(4)': WebGLKernelValueDynamicSingleArray1DI,
      'Array2D(2)': WebGLKernelValueDynamicSingleArray2DI,
      'Array2D(3)': WebGLKernelValueDynamicSingleArray2DI,
      'Array2D(4)': WebGLKernelValueDynamicSingleArray2DI,
      'Array3D(2)': WebGLKernelValueDynamicSingleArray3DI,
      'Array3D(3)': WebGLKernelValueDynamicSingleArray3DI,
      'Array3D(4)': WebGLKernelValueDynamicSingleArray3DI,
      'Input': WebGLKernelValueDynamicSingleInput,
      'NumberTexture': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
      'OffscreenCanvas': WebGLKernelValueDynamicHTMLImage,
      'HTMLImage': WebGLKernelValueDynamicHTMLImage,
      'ImageBitmap': WebGLKernelValueDynamicHTMLImage,
      'ImageData': WebGLKernelValueDynamicHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGLKernelValueBoolean,
      'Float': WebGLKernelValueFloat,
      'Integer': WebGLKernelValueInteger,
      'Array': WebGLKernelValueSingleArray,
      'Array(2)': WebGLKernelValueArray2,
      'Array(3)': WebGLKernelValueArray3,
      'Array(4)': WebGLKernelValueArray4,
      'Array1D(2)': WebGLKernelValueSingleArray1DI,
      'Array1D(3)': WebGLKernelValueSingleArray1DI,
      'Array1D(4)': WebGLKernelValueSingleArray1DI,
      'Array2D(2)': WebGLKernelValueSingleArray2DI,
      'Array2D(3)': WebGLKernelValueSingleArray2DI,
      'Array2D(4)': WebGLKernelValueSingleArray2DI,
      'Array3D(2)': WebGLKernelValueSingleArray3DI,
      'Array3D(3)': WebGLKernelValueSingleArray3DI,
      'Array3D(4)': WebGLKernelValueSingleArray3DI,
      'Input': WebGLKernelValueSingleInput,
      'NumberTexture': WebGLKernelValueNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueHTMLImage,
      'OffscreenCanvas': WebGLKernelValueHTMLImage,
      'HTMLImage': WebGLKernelValueHTMLImage,
      'ImageBitmap': WebGLKernelValueHTMLImage,
      'ImageData': WebGLKernelValueHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueHTMLVideo,
    }
  },
};

function lookupKernelValueType(type, dynamic, precision, value) {
  if (!type) {
    throw new Error('type missing');
  }
  if (!dynamic) {
    throw new Error('dynamic missing');
  }
  if (!precision) {
    throw new Error('precision missing');
  }
  if (value.type) {
    type = value.type;
  }
  const types = kernelValueMaps[precision][dynamic];
  if (types[type] === false) {
    return null;
  } else if (types[type] === undefined) {
    throw new Error(`Could not find a KernelValue for ${ type }`);
  }
  return types[type];
}

module.exports = {
  lookupKernelValueType,
  kernelValueMaps,
};
},{"./kernel-value/array2":41,"./kernel-value/array3":42,"./kernel-value/array4":43,"./kernel-value/boolean":44,"./kernel-value/dynamic-html-image":45,"./kernel-value/dynamic-html-video":46,"./kernel-value/dynamic-memory-optimized-number-texture":47,"./kernel-value/dynamic-number-texture":48,"./kernel-value/dynamic-single-array":49,"./kernel-value/dynamic-single-array1d-i":50,"./kernel-value/dynamic-single-array2d-i":51,"./kernel-value/dynamic-single-array3d-i":52,"./kernel-value/dynamic-single-input":53,"./kernel-value/dynamic-unsigned-array":54,"./kernel-value/dynamic-unsigned-input":55,"./kernel-value/float":56,"./kernel-value/html-image":57,"./kernel-value/html-video":58,"./kernel-value/integer":60,"./kernel-value/memory-optimized-number-texture":61,"./kernel-value/number-texture":62,"./kernel-value/single-array":63,"./kernel-value/single-array1d-i":64,"./kernel-value/single-array2d-i":65,"./kernel-value/single-array3d-i":66,"./kernel-value/single-input":67,"./kernel-value/unsigned-array":68,"./kernel-value/unsigned-input":69}],40:[function(require,module,exports){
const { WebGLKernelValue } = require('./index');
const { Input } = require('../../../input');

class WebGLKernelArray extends WebGLKernelValue {
  checkSize(width, height) {
    if (!this.kernel.validate) return;
    const { maxTextureSize } = this.kernel.constructor.features;
    if (width > maxTextureSize || height > maxTextureSize) {
      if (width > height) {
        throw new Error(`Argument texture width of ${width} larger than maximum size of ${maxTextureSize} for your GPU`);
      } else if (width < height) {
        throw new Error(`Argument texture height of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
      } else {
        throw new Error(`Argument texture height and width of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
      }
    }
  }

  setup() {
    this.requestTexture();
    this.setupTexture();
    this.defineTexture();
  }

  requestTexture() {
    this.texture = this.onRequestTexture();
  }

  defineTexture() {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  }

  setupTexture() {
    this.contextHandle = this.onRequestContextHandle();
    this.index = this.onRequestIndex();
    this.dimensionsId = this.id + 'Dim';
    this.sizeId = this.id + 'Size';
  }

  getBitRatio(value) {
    if (Array.isArray(value[0])) {
      return this.getBitRatio(value[0]);
    } else if (value.constructor === Input) {
      return this.getBitRatio(value.value);
    }
    switch (value.constructor) {
      case Uint8ClampedArray:
      case Uint8Array:
      case Int8Array:
        return 1;
      case Uint16Array:
      case Int16Array:
        return 2;
      case Float32Array:
      case Int32Array:
      default:
        return 4;
    }
  }

  destroy() {
    if (this.prevArg) {
      this.prevArg.delete();
    }
    this.context.deleteTexture(this.texture);
  }
}

module.exports = {
  WebGLKernelArray
};
},{"../../../input":110,"./index":59}],41:[function(require,module,exports){
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueArray2 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec2 ${this.id} = vec2(${value[0]},${value[1]});\n`;
    }
    return `uniform vec2 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform2fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueArray2
};
},{"./index":59}],42:[function(require,module,exports){
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueArray3 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec3 ${this.id} = vec3(${value[0]},${value[1]},${value[2]});\n`;
    }
    return `uniform vec3 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform3fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueArray3
};
},{"./index":59}],43:[function(require,module,exports){
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueArray4 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec4 ${this.id} = vec4(${value[0]},${value[1]},${value[2]},${value[3]});\n`;
    }
    return `uniform vec4 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform4fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueArray4
};
},{"./index":59}],44:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueBoolean extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const bool ${this.id} = ${value};\n`;
    }
    return `uniform bool ${this.id};\n`;
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueBoolean
};
},{"../../../utils":114,"./index":59}],45:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueHTMLImage } = require('./html-image');

class WebGLKernelValueDynamicHTMLImage extends WebGLKernelValueHTMLImage {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    const { width, height } = value;
    this.checkSize(width, height);
    this.dimensions = [width, height, 1];
    this.textureSize = [width, height];
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicHTMLImage
};
},{"../../../utils":114,"./html-image":57}],46:[function(require,module,exports){
const { WebGLKernelValueDynamicHTMLImage } = require('./dynamic-html-image');

class WebGLKernelValueDynamicHTMLVideo extends WebGLKernelValueDynamicHTMLImage {}

module.exports = {
  WebGLKernelValueDynamicHTMLVideo
};
},{"./dynamic-html-image":45}],47:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./memory-optimized-number-texture');

class WebGLKernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(inputTexture) {
    this.dimensions = inputTexture.dimensions;
    this.checkSize(inputTexture.size[0], inputTexture.size[1]);
    this.textureSize = inputTexture.size;
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(inputTexture);
  }
}

module.exports = {
  WebGLKernelValueDynamicMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"./memory-optimized-number-texture":61}],48:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueNumberTexture } = require('./number-texture');

class WebGLKernelValueDynamicNumberTexture extends WebGLKernelValueNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = value.dimensions;
    this.checkSize(value.size[0], value.size[1]);
    this.textureSize = value.size;
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicNumberTexture
};
},{"../../../utils":114,"./number-texture":62}],49:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray } = require('./single-array');

class WebGLKernelValueDynamicSingleArray extends WebGLKernelValueSingleArray {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray
};
},{"../../../utils":114,"./single-array":63}],50:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray1DI } = require('./single-array1d-i');

class WebGLKernelValueDynamicSingleArray1DI extends WebGLKernelValueSingleArray1DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray1DI
};
},{"../../../utils":114,"./single-array1d-i":64}],51:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray2DI } = require('./single-array2d-i');

class WebGLKernelValueDynamicSingleArray2DI extends WebGLKernelValueSingleArray2DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray2DI
};
},{"../../../utils":114,"./single-array2d-i":65}],52:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray3DI } = require('./single-array3d-i');

class WebGLKernelValueDynamicSingleArray3DI extends WebGLKernelValueSingleArray3DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray3DI
};
},{"../../../utils":114,"./single-array3d-i":66}],53:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleInput } = require('./single-input');

class WebGLKernelValueDynamicSingleInput extends WebGLKernelValueSingleInput {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleInput
};
},{"../../../utils":114,"./single-input":67}],54:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedArray } = require('./unsigned-array');

class WebGLKernelValueDynamicUnsignedArray extends WebGLKernelValueUnsignedArray {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    const Type = this.getTransferArrayType(value);
    this.preUploadValue = new Type(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicUnsignedArray
};
},{"../../../utils":114,"./unsigned-array":68}],55:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedInput } = require('./unsigned-input');

class WebGLKernelValueDynamicUnsignedInput extends WebGLKernelValueUnsignedInput {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    const Type = this.getTransferArrayType(value.value);
    this.preUploadValue = new Type(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicUnsignedInput
};
},{"../../../utils":114,"./unsigned-input":69}],56:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueFloat extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      if (Number.isInteger(value)) {
        return `const float ${this.id} = ${value}.0;\n`;
      }
      return `const float ${this.id} = ${value};\n`;
    }
    return `uniform float ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1f(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueFloat
};
},{"../../../utils":114,"./index":59}],57:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueHTMLImage extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const { width, height } = value;
    this.checkSize(width, height);
    this.dimensions = [width, height, 1];
    this.textureSize = [width, height];
    this.uploadValue = value;
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputImage) {
    if (inputImage.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputImage.constructor);
      return;
    }
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue = inputImage);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueHTMLImage
};
},{"../../../utils":114,"./array":40}],58:[function(require,module,exports){
const { WebGLKernelValueHTMLImage } = require('./html-image');

class WebGLKernelValueHTMLVideo extends WebGLKernelValueHTMLImage {}

module.exports = {
  WebGLKernelValueHTMLVideo
};
},{"./html-image":57}],59:[function(require,module,exports){
const { utils } = require('../../../utils');
const { KernelValue } = require('../../kernel-value');

class WebGLKernelValue extends KernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.dimensionsId = null;
    this.sizeId = null;
    this.initialValueConstructor = value.constructor;
    this.onRequestTexture = settings.onRequestTexture;
    this.onRequestIndex = settings.onRequestIndex;
    this.uploadValue = null;
    this.textureSize = null;
    this.bitRatio = null;
    this.prevArg = null;
  }

  get id() {
    return `${this.origin}_${utils.sanitizeName(this.name)}`;
  }

  setup() {}

  getTransferArrayType(value) {
    if (Array.isArray(value[0])) {
      return this.getTransferArrayType(value[0]);
    }
    switch (value.constructor) {
      case Array:
      case Int32Array:
      case Int16Array:
      case Int8Array:
        return Float32Array;
      case Uint8ClampedArray:
      case Uint8Array:
      case Uint16Array:
      case Uint32Array:
      case Float32Array:
      case Float64Array:
        return value.constructor;
    }
    console.warn('Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros');
    return value.constructor;
  }

  getStringValueHandler() {
    throw new Error(`"getStringValueHandler" not implemented on ${this.constructor.name}`);
  }

  getVariablePrecisionString() {
    return this.kernel.getVariablePrecisionString(this.textureSize || undefined, this.tactic || undefined);
  }

  destroy() {}
}

module.exports = {
  WebGLKernelValue
};
},{"../../../utils":114,"../../kernel-value":35}],60:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueInteger extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const int ${this.id} = ${ parseInt(value) };\n`;
    }
    return `uniform int ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueInteger
};
},{"../../../utils":114,"./index":59}],61:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

const sameError = `Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()`;

class WebGLKernelValueMemoryOptimizedNumberTexture extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const [width, height] = value.size;
    this.checkSize(width, height);
    this.dimensions = value.dimensions;
    this.textureSize = value.size;
    this.uploadValue = value.texture;
    this.forceUploadEachRun = true;
  }

  setup() {
    this.setupTexture();
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputTexture) {
    if (inputTexture.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputTexture.constructor);
      return;
    }
    if (this.checkContext && inputTexture.context !== this.context) {
      throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
    }

    const { kernel, context: gl } = this;
    if (kernel.pipeline) {
      if (kernel.immutable) {
        kernel.updateTextureArgumentRefs(this, inputTexture);
      } else {
        if (kernel.texture && kernel.texture.texture === inputTexture.texture) {
          throw new Error(sameError);
        } else if (kernel.mappedTextures) {
          const { mappedTextures } = kernel;
          for (let i = 0; i < mappedTextures.length; i++) {
            if (mappedTextures[i].texture === inputTexture.texture) {
              throw new Error(sameError);
            }
          }
        }
      }
    }

    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueMemoryOptimizedNumberTexture,
  sameError
};
},{"../../../utils":114,"./array":40}],62:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');
const { sameError } = require('./memory-optimized-number-texture');

class WebGLKernelValueNumberTexture extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const [width, height] = value.size;
    this.checkSize(width, height);
    const { size: textureSize, dimensions } = value;
    this.bitRatio = this.getBitRatio(value);
    this.dimensions = dimensions;
    this.textureSize = textureSize;
    this.uploadValue = value.texture;
    this.forceUploadEachRun = true;
  }

  setup() {
    this.setupTexture();
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputTexture) {
    if (inputTexture.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputTexture.constructor);
      return;
    }
    if (this.checkContext && inputTexture.context !== this.context) {
      throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
    }

    const { kernel, context: gl } = this;
    if (kernel.pipeline) {
      if (kernel.immutable) {
        kernel.updateTextureArgumentRefs(this, inputTexture);
      } else {
        if (kernel.texture && kernel.texture.texture === inputTexture.texture) {
          throw new Error(sameError);
        } else if (kernel.mappedTextures) {
          const { mappedTextures } = kernel;
          for (let i = 0; i < mappedTextures.length; i++) {
            if (mappedTextures[i].texture === inputTexture.texture) {
              throw new Error(sameError);
            }
          }
        }
      }
    }

    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueNumberTexture
};
},{"../../../utils":114,"./array":40,"./memory-optimized-number-texture":61}],63:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray
};
},{"../../../utils":114,"./array":40}],64:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray1DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], 1, 1]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten2dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray1DI
};
},{"../../../utils":114,"./array":40}],65:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray2DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], 1]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten3dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray2DI
};
},{"../../../utils":114,"./array":40}],66:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray3DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], valueDimensions[3]]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten4dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray3DI
};
},{"../../../utils":114,"./array":40}],67:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleInput extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}.value, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    if (input.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(input.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(input.value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleInput
};
},{"../../../utils":114,"./array":40}],68:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueUnsignedArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = this.getBitRatio(value);
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.TranserArrayType = this.getTransferArrayType(value);
    this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
      `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
      `flattenTo(${this.varName}, preUploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.preUploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueUnsignedArray
};
},{"../../../utils":114,"./array":40}],69:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueUnsignedInput extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = this.getBitRatio(value);
    const [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.TranserArrayType = this.getTransferArrayType(value.value);
    this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
      `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
      `flattenTo(${this.varName}.value, preUploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    if (input.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(input.value, this.preUploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueUnsignedInput
};
},{"../../../utils":114,"./array":40}],70:[function(require,module,exports){
const { GLKernel } = require('../gl/kernel');
const { FunctionBuilder } = require('../function-builder');
const { WebGLFunctionNode } = require('./function-node');
const { utils } = require('../../utils');
const mrud = require('../../plugins/math-random-uniformly-distributed');
const { fragmentShader } = require('./fragment-shader');
const { vertexShader } = require('./vertex-shader');
const { glKernelString } = require('../gl/kernel-string');
const { lookupKernelValueType } = require('./kernel-value-maps');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;
let features = null;

const plugins = [mrud];
const canvases = [];
const maxTexSizes = {};


class WebGLKernel extends GLKernel {
  static get isSupported() {
    if (isSupported !== null) {
      return isSupported;
    }
    this.setupFeatureChecks();
    isSupported = this.isContextMatch(testContext);
    return isSupported;
  }

  static setupFeatureChecks() {
    if (typeof document !== 'undefined') {
      testCanvas = document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      testCanvas = new OffscreenCanvas(0, 0);
    }
    if (!testCanvas) return;
    testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
    if (!testContext || !testContext.getExtension) return;
    testExtensions = {
      OES_texture_float: testContext.getExtension('OES_texture_float'),
      OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
    };
    features = this.getFeatures();
  }

  static isContextMatch(context) {
    if (typeof WebGLRenderingContext !== 'undefined') {
      return context instanceof WebGLRenderingContext;
    }
    return false;
  }

  static getIsTextureFloat() {
    return Boolean(testExtensions.OES_texture_float);
  }

  static getIsDrawBuffers() {
    return Boolean(testExtensions.WEBGL_draw_buffers);
  }

  static getChannelCount() {
    return testExtensions.WEBGL_draw_buffers ?
      testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
      1;
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static lookupKernelValueType(type, dynamic, precision, value) {
    return lookupKernelValueType(type, dynamic, precision, value);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  static get fragmentShader() {
    return fragmentShader;
  }

  static get vertexShader() {
    return vertexShader;
  }

  constructor(source, settings) {
    super(source, settings);
    this.program = null;
    this.pipeline = settings.pipeline;
    this.endianness = utils.systemEndianness();
    this.extensions = {};
    this.argumentTextureCount = 0;
    this.constantTextureCount = 0;
    this.fragShader = null;
    this.vertShader = null;
    this.drawBuffersMap = null;

    this.maxTexSize = null;
    this.onRequestSwitchKernel = null;

    this.texture = null;
    this.mappedTextures = null;
    this.mergeSettings(source.settings || settings);

    this.threadDim = null;
    this.framebuffer = null;
    this.buffer = null;

    this.textureCache = [];
    this.programUniformLocationCache = {};
    this.uniform1fCache = {};
    this.uniform1iCache = {};
    this.uniform2fCache = {};
    this.uniform2fvCache = {};
    this.uniform2ivCache = {};
    this.uniform3fvCache = {};
    this.uniform3ivCache = {};
    this.uniform4fvCache = {};
    this.uniform4ivCache = {};
  }

  initCanvas() {
    if (typeof document !== 'undefined') {
      const canvas = document.createElement('canvas');
      canvas.width = 2;
      canvas.height = 2;
      return canvas;
    } else if (typeof OffscreenCanvas !== 'undefined') {
      return new OffscreenCanvas(0, 0);
    }
  }

  initContext() {
    const settings = {
      alpha: false,
      depth: false,
      antialias: false
    };
    return this.canvas.getContext('webgl', settings) || this.canvas.getContext('experimental-webgl', settings);
  }

  initPlugins(settings) {
    const pluginsToUse = [];
    const { source } = this;
    if (typeof source === 'string') {
      for (let i = 0; i < plugins.length; i++) {
        const plugin = plugins[i];
        if (source.match(plugin.functionMatch)) {
          pluginsToUse.push(plugin);
        }
      }
    } else if (typeof source === 'object') {
      if (settings.pluginNames) { 
        for (let i = 0; i < plugins.length; i++) {
          const plugin = plugins[i];
          const usePlugin = settings.pluginNames.some(pluginName => pluginName === plugin.name);
          if (usePlugin) {
            pluginsToUse.push(plugin);
          }
        }
      }
    }
    return pluginsToUse;
  }

  initExtensions() {
    this.extensions = {
      OES_texture_float: this.context.getExtension('OES_texture_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
      WEBGL_color_buffer_float: this.context.getExtension('WEBGL_color_buffer_float'),
    };
  }

  validateSettings(args) {
    if (!this.validate) {
      this.texSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, this.output);
      return;
    }

    const { features } = this.constructor;

    if (this.optimizeFloatMemory === true && !features.isTextureFloat) {
      throw new Error('Float textures are not supported');
    } else if (this.precision === 'single' && !features.isFloatRead) {
      throw new Error('Single precision not supported');
    } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
      this.precision = features.isFloatRead ? 'single' : 'unsigned';
    }

    if (this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) {
      throw new Error('could not instantiate draw buffers extension');
    }

    if (this.fixIntegerDivisionAccuracy === null) {
      this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
    } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
      this.fixIntegerDivisionAccuracy = false;
    }

    this.checkOutput();

    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      switch (argType) {
        case 'Array':
          this.output = utils.getDimensions(argType);
          break;
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
          this.output = args[0].output;
          break;
        default:
          throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }

      if (this.precision === 'precision') {
        this.precision = 'unsigned';
        console.warn('Cannot use graphical mode and single precision at the same time');
      }

      this.texSize = utils.clone(this.output);
      return;
    } else if (this.precision === null && features.isTextureFloat) {
      this.precision = 'single';
    }

    this.texSize = utils.getKernelTextureSize({
      optimizeFloatMemory: this.optimizeFloatMemory,
      precision: this.precision,
    }, this.output);

    this.checkTextureSize();
  }

  updateMaxTexSize() {
    const { texSize, canvas } = this;
    if (this.maxTexSize === null) {
      let canvasIndex = canvases.indexOf(canvas);
      if (canvasIndex === -1) {
        canvasIndex = canvases.length;
        canvases.push(canvas);
        maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];
      }
      this.maxTexSize = maxTexSizes[canvasIndex];
    }
    if (this.maxTexSize[0] < texSize[0]) {
      this.maxTexSize[0] = texSize[0];
    }
    if (this.maxTexSize[1] < texSize[1]) {
      this.maxTexSize[1] = texSize[1];
    }
  }

  setupArguments(args) {
    this.kernelArguments = [];
    this.argumentTextureCount = 0;
    const needsArgumentTypes = this.argumentTypes === null;
    if (needsArgumentTypes) {
      this.argumentTypes = [];
    }
    this.argumentSizes = [];
    this.argumentBitRatios = [];

    if (args.length < this.argumentNames.length) {
      throw new Error('not enough arguments for kernel');
    } else if (args.length > this.argumentNames.length) {
      throw new Error('too many arguments for kernel');
    }

    const { context: gl } = this;
    let textureIndexes = 0;

    const onRequestTexture = () => {
      return this.createTexture();
    };
    const onRequestIndex = () => {
      return this.constantTextureCount + textureIndexes++;
    };
    const onUpdateValueMismatch = (constructor) => {
      this.switchKernels({
        type: 'argumentMismatch',
        needed: constructor
      });
    };
    const onRequestContextHandle = () => {
      return gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount++;
    };

    for (let index = 0; index < args.length; index++) {
      const value = args[index];
      const name = this.argumentNames[index];
      let type;
      if (needsArgumentTypes) {
        type = utils.getVariableType(value, this.strictIntegers);
        this.argumentTypes.push(type);
      } else {
        type = this.argumentTypes[index];
      }
      const KernelValue = this.constructor.lookupKernelValueType(type, this.dynamicArguments ? 'dynamic' : 'static', this.precision, args[index]);
      if (KernelValue === null) {
        return this.requestFallback(args);
      }
      const kernelArgument = new KernelValue(value, {
        name,
        type,
        tactic: this.tactic,
        origin: 'user',
        context: gl,
        checkContext: this.checkContext,
        kernel: this,
        strictIntegers: this.strictIntegers,
        onRequestTexture,
        onRequestIndex,
        onUpdateValueMismatch,
        onRequestContextHandle,
      });
      this.kernelArguments.push(kernelArgument);
      kernelArgument.setup();
      this.argumentSizes.push(kernelArgument.textureSize);
      this.argumentBitRatios[index] = kernelArgument.bitRatio;
    }
  }

  createTexture() {
    const texture = this.context.createTexture();
    this.textureCache.push(texture);
    return texture;
  }

  setupConstants(args) {
    const { context: gl } = this;
    this.kernelConstants = [];
    this.forceUploadKernelConstants = [];
    let needsConstantTypes = this.constantTypes === null;
    if (needsConstantTypes) {
      this.constantTypes = {};
    }
    this.constantBitRatios = {};
    let textureIndexes = 0;
    for (const name in this.constants) {
      const value = this.constants[name];
      let type;
      if (needsConstantTypes) {
        type = utils.getVariableType(value, this.strictIntegers);
        this.constantTypes[name] = type;
      } else {
        type = this.constantTypes[name];
      }
      const KernelValue = this.constructor.lookupKernelValueType(type, 'static', this.precision, value);
      if (KernelValue === null) {
        return this.requestFallback(args);
      }
      const kernelValue = new KernelValue(value, {
        name,
        type,
        tactic: this.tactic,
        origin: 'constants',
        context: this.context,
        checkContext: this.checkContext,
        kernel: this,
        strictIntegers: this.strictIntegers,
        onRequestTexture: () => {
          return this.createTexture();
        },
        onRequestIndex: () => {
          return textureIndexes++;
        },
        onRequestContextHandle: () => {
          return gl.TEXTURE0 + this.constantTextureCount++;
        }
      });
      this.constantBitRatios[name] = kernelValue.bitRatio;
      this.kernelConstants.push(kernelValue);
      kernelValue.setup();
      if (kernelValue.forceUploadEachRun) {
        this.forceUploadKernelConstants.push(kernelValue);
      }
    }
  }

  build() {
    if (this.built) return;
    this.initExtensions();
    this.validateSettings(arguments);
    this.setupConstants(arguments);
    if (this.fallbackRequested) return;
    this.setupArguments(arguments);
    if (this.fallbackRequested) return;
    this.updateMaxTexSize();
    this.translateSource();
    const failureResult = this.pickRenderStrategy(arguments);
    if (failureResult) {
      return failureResult;
    }
    const { texSize, context: gl, canvas } = this;
    gl.enable(gl.SCISSOR_TEST);
    if (this.pipeline && this.precision === 'single') {
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      canvas.width = this.maxTexSize[0];
      canvas.height = this.maxTexSize[1];
    } else {
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      canvas.width = this.maxTexSize[0];
      canvas.height = this.maxTexSize[1];
    }
    const threadDim = this.threadDim = Array.from(this.output);
    while (threadDim.length < 3) {
      threadDim.push(1);
    }

    const compiledVertexShader = this.getVertexShader(arguments);
    const vertShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertShader, compiledVertexShader);
    gl.compileShader(vertShader);
    this.vertShader = vertShader;

    const compiledFragmentShader = this.getFragmentShader(arguments);
    const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragShader, compiledFragmentShader);
    gl.compileShader(fragShader);
    this.fragShader = fragShader;

    if (this.debug) {
      console.log('GLSL Shader Output:');
      console.log(compiledFragmentShader);
    }

    if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
      throw new Error('Error compiling vertex shader: ' + gl.getShaderInfoLog(vertShader));
    }
    if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
      throw new Error('Error compiling fragment shader: ' + gl.getShaderInfoLog(fragShader));
    }

    const program = this.program = gl.createProgram();
    gl.attachShader(program, vertShader);
    gl.attachShader(program, fragShader);
    gl.linkProgram(program);
    this.framebuffer = gl.createFramebuffer();
    this.framebuffer.width = texSize[0];
    this.framebuffer.height = texSize[1];
    this.rawValueFramebuffers = {};

    const vertices = new Float32Array([-1, -1,
      1, -1, -1, 1,
      1, 1
    ]);
    const texCoords = new Float32Array([
      0, 0,
      1, 0,
      0, 1,
      1, 1
    ]);

    const texCoordOffset = vertices.byteLength;

    let buffer = this.buffer;
    if (!buffer) {
      buffer = this.buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);
    } else {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    }

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
    gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);

    const aPosLoc = gl.getAttribLocation(this.program, 'aPos');
    gl.enableVertexAttribArray(aPosLoc);
    gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);
    const aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');
    gl.enableVertexAttribArray(aTexCoordLoc);
    gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, texCoordOffset);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);

    let i = 0;
    gl.useProgram(this.program);
    for (let p in this.constants) {
      this.kernelConstants[i++].updateValue(this.constants[p]);
    }

    this._setupOutputTexture();
    if (
      this.subKernels !== null &&
      this.subKernels.length > 0
    ) {
      this._mappedTextureSwitched = {};
      this._setupSubOutputTextures();
    }
    this.buildSignature(arguments);
    this.built = true;
  }

  translateSource() {
    const functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {
      fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
    });
    this.translatedSource = functionBuilder.getPrototypeString('kernel');
    this.setupReturnTypes(functionBuilder);
  }

  setupReturnTypes(functionBuilder) {
    if (!this.graphical && !this.returnType) {
      this.returnType = functionBuilder.getKernelResultType();
    }

    if (this.subKernels && this.subKernels.length > 0) {
      for (let i = 0; i < this.subKernels.length; i++) {
        const subKernel = this.subKernels[i];
        if (!subKernel.returnType) {
          subKernel.returnType = functionBuilder.getSubKernelResultType(i);
        }
      }
    }
  }

  run() {
    const { kernelArguments, texSize, forceUploadKernelConstants, context: gl } = this;

    gl.useProgram(this.program);
    gl.scissor(0, 0, texSize[0], texSize[1]);
    if (this.dynamicOutput) {
      this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));
      this.setUniform2iv('uTexSize', texSize);
    }

    this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);

    for (let i = 0; i < forceUploadKernelConstants.length; i++) {
      const constant = forceUploadKernelConstants[i];
      constant.updateValue(this.constants[constant.name]);
      if (this.switchingKernels) return;
    }
    for (let i = 0; i < kernelArguments.length; i++) {
      kernelArguments[i].updateValue(arguments[i]);
      if (this.switchingKernels) return;
    }

    if (this.plugins) {
      for (let i = 0; i < this.plugins.length; i++) {
        const plugin = this.plugins[i];
        if (plugin.onBeforeRun) {
          plugin.onBeforeRun(this);
        }
      }
    }

    if (this.graphical) {
      if (this.pipeline) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        if (this.immutable) {
          this._replaceOutputTexture();
        }
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        return this.immutable ? this.texture.clone() : this.texture;
      }
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      return;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    if (this.immutable) {
      this._replaceOutputTexture();
    }

    if (this.subKernels !== null) {
      if (this.immutable) {
        this._replaceSubOutputTextures();
      }
      this.drawBuffers();
    }

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  drawBuffers() {
    this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);
  }

  getInternalFormat() {
    return this.context.RGBA;
  }
  getTextureFormat() {
    const { context: gl } = this;
    switch (this.getInternalFormat()) {
      case gl.RGBA:
        return gl.RGBA;
      default:
        throw new Error('Unknown internal format');
    }
  }

  _replaceOutputTexture() {
    if (this.texture.beforeMutate() || this._textureSwitched) {
      const gl = this.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      this._textureSwitched = false;
    }
  }

  _setupOutputTexture() {
    const gl = this.context;
    const texSize = this.texSize;
    if (this.texture) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      return;
    }
    const texture = this.createTexture();
    gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    const format = this.getInternalFormat();
    if (this.precision === 'single') {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    this.texture = new this.TextureConstructor({
      texture,
      size: texSize,
      dimensions: this.threadDim,
      output: this.output,
      context: this.context,
      internalFormat: this.getInternalFormat(),
      textureFormat: this.getTextureFormat(),
      kernel: this,
    });
  }

  _replaceSubOutputTextures() {
    const gl = this.context;
    for (let i = 0; i < this.mappedTextures.length; i++) {
      const mappedTexture = this.mappedTextures[i];
      if (mappedTexture.beforeMutate() || this._mappedTextureSwitched[i]) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, mappedTexture.texture, 0);
        this._mappedTextureSwitched[i] = false;
      }
    }
  }

  _setupSubOutputTextures() {
    const gl = this.context;
    if (this.mappedTextures) {
      for (let i = 0; i < this.subKernels.length; i++) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
      }
      return;
    }
    const texSize = this.texSize;
    this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
    this.mappedTextures = [];
    for (let i = 0; i < this.subKernels.length; i++) {
      const texture = this.createTexture();
      this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
      gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      if (this.precision === 'single') {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);

      this.mappedTextures.push(new this.TextureConstructor({
        texture,
        size: texSize,
        dimensions: this.threadDim,
        output: this.output,
        context: this.context,
        internalFormat: this.getInternalFormat(),
        textureFormat: this.getTextureFormat(),
        kernel: this,
      }));
    }
  }

  setUniform1f(name, value) {
    if (this.uniform1fCache.hasOwnProperty(name)) {
      const cache = this.uniform1fCache[name];
      if (value === cache) {
        return;
      }
    }
    this.uniform1fCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform1f(loc, value);
  }

  setUniform1i(name, value) {
    if (this.uniform1iCache.hasOwnProperty(name)) {
      const cache = this.uniform1iCache[name];
      if (value === cache) {
        return;
      }
    }
    this.uniform1iCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform1i(loc, value);
  }

  setUniform2f(name, value1, value2) {
    if (this.uniform2fCache.hasOwnProperty(name)) {
      const cache = this.uniform2fCache[name];
      if (
        value1 === cache[0] &&
        value2 === cache[1]
      ) {
        return;
      }
    }
    this.uniform2fCache[name] = [value1, value2];
    const loc = this.getUniformLocation(name);
    this.context.uniform2f(loc, value1, value2);
  }

  setUniform2fv(name, value) {
    if (this.uniform2fvCache.hasOwnProperty(name)) {
      const cache = this.uniform2fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1]
      ) {
        return;
      }
    }
    this.uniform2fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform2fv(loc, value);
  }

  setUniform2iv(name, value) {
    if (this.uniform2ivCache.hasOwnProperty(name)) {
      const cache = this.uniform2ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1]
      ) {
        return;
      }
    }
    this.uniform2ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform2iv(loc, value);
  }

  setUniform3fv(name, value) {
    if (this.uniform3fvCache.hasOwnProperty(name)) {
      const cache = this.uniform3fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2]
      ) {
        return;
      }
    }
    this.uniform3fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform3fv(loc, value);
  }

  setUniform3iv(name, value) {
    if (this.uniform3ivCache.hasOwnProperty(name)) {
      const cache = this.uniform3ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2]
      ) {
        return;
      }
    }
    this.uniform3ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform3iv(loc, value);
  }

  setUniform4fv(name, value) {
    if (this.uniform4fvCache.hasOwnProperty(name)) {
      const cache = this.uniform4fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2] &&
        value[3] === cache[3]
      ) {
        return;
      }
    }
    this.uniform4fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform4fv(loc, value);
  }

  setUniform4iv(name, value) {
    if (this.uniform4ivCache.hasOwnProperty(name)) {
      const cache = this.uniform4ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2] &&
        value[3] === cache[3]
      ) {
        return;
      }
    }
    this.uniform4ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform4iv(loc, value);
  }

  getUniformLocation(name) {
    if (this.programUniformLocationCache.hasOwnProperty(name)) {
      return this.programUniformLocationCache[name];
    }
    return this.programUniformLocationCache[name] = this.context.getUniformLocation(this.program, name);
  }

  _getFragShaderArtifactMap(args) {
    return {
      HEADER: this._getHeaderString(),
      LOOP_MAX: this._getLoopMaxString(),
      PLUGINS: this._getPluginsString(),
      CONSTANTS: this._getConstantsString(),
      DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),
      ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),
      DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),
      INJECTED_NATIVE: this._getInjectedNative(),
      MAIN_CONSTANTS: this._getMainConstantsString(),
      MAIN_ARGUMENTS: this._getMainArgumentsString(args),
      KERNEL: this.getKernelString(),
      MAIN_RESULT: this.getMainResultString(),
      FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
      INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
      SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
      SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
    };
  }

  _getVertShaderArtifactMap(args) {
    return {
      FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
      INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
      SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
      SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
    };
  }

  _getHeaderString() {
    return (
      this.subKernels !== null ?
      '#extension GL_EXT_draw_buffers : require\n' :
      ''
    );
  }

  _getLoopMaxString() {
    return (
      this.loopMaxIterations ?
      ` ${parseInt(this.loopMaxIterations)};\n` :
      ' 1000;\n'
    );
  }

  _getPluginsString() {
    if (!this.plugins) return '\n';
    return this.plugins.map(plugin => plugin.source && this.source.match(plugin.functionMatch) ? plugin.source : '').join('\n');
  }

  _getConstantsString() {
    const result = [];
    const { threadDim, texSize } = this;
    if (this.dynamicOutput) {
      result.push(
        'uniform ivec3 uOutputDim',
        'uniform ivec2 uTexSize'
      );
    } else {
      result.push(
        `ivec3 uOutputDim = ivec3(${threadDim[0]}, ${threadDim[1]}, ${threadDim[2]})`,
        `ivec2 uTexSize = ivec2(${texSize[0]}, ${texSize[1]})`
      );
    }
    return utils.linesToString(result);
  }

  _getTextureCoordinate() {
    const subKernels = this.subKernels;
    if (subKernels === null || subKernels.length < 1) {
      return 'varying vec2 vTexCoord;\n';
    } else {
      return 'out vec2 vTexCoord;\n';
    }
  }

  _getDecode32EndiannessString() {
    return (
      this.endianness === 'LE' ?
      '' :
      '  texel.rgba = texel.abgr;\n'
    );
  }

  _getEncode32EndiannessString() {
    return (
      this.endianness === 'LE' ?
      '' :
      '  texel.rgba = texel.abgr;\n'
    );
  }

  _getDivideWithIntegerCheckString() {
    return this.fixIntegerDivisionAccuracy ?
      `float divWithIntCheck(float x, float y) {
  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {
    return float(int(x) / int(y));
  }
  return x / y;
}

float integerCorrectionModulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -(number - (divisor * floor(divWithIntCheck(number, divisor))));
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return number - (divisor * floor(divWithIntCheck(number, divisor)));
}` :
      '';
  }

  _getMainArgumentsString(args) {
    const results = [];
    const { argumentNames } = this;
    for (let i = 0; i < argumentNames.length; i++) {
      results.push(this.kernelArguments[i].getSource(args[i]));
    }
    return results.join('');
  }

  _getInjectedNative() {
    return this.injectedNative || '';
  }

  _getMainConstantsString() {
    const result = [];
    const { constants } = this;
    if (constants) {
      let i = 0;
      for (const name in constants) {
        if (!this.constants.hasOwnProperty(name)) continue;
        result.push(this.kernelConstants[i++].getSource(this.constants[name]));
      }
    }
    return result.join('');
  }

  getRawValueFramebuffer(width, height) {
    if (!this.rawValueFramebuffers[width]) {
      this.rawValueFramebuffers[width] = {};
    }
    if (!this.rawValueFramebuffers[width][height]) {
      const framebuffer = this.context.createFramebuffer();
      framebuffer.width = width;
      framebuffer.height = height;
      this.rawValueFramebuffers[width][height] = framebuffer;
    }
    return this.rawValueFramebuffers[width][height];
  }

  getKernelResultDeclaration() {
    switch (this.returnType) {
      case 'Array(2)':
        return 'vec2 kernelResult';
      case 'Array(3)':
        return 'vec3 kernelResult';
      case 'Array(4)':
        return 'vec4 kernelResult';
      case 'LiteralInteger':
      case 'Float':
      case 'Number':
      case 'Integer':
        return 'float kernelResult';
      default:
        if (this.graphical) {
          return 'float kernelResult';
        } else {
          throw new Error(`unrecognized output type "${ this.returnType }"`);
        }
    }
  }
  getKernelString() {
    const result = [this.getKernelResultDeclaration()];
    const { subKernels } = this;
    if (subKernels !== null) {
      switch (this.returnType) {
        case 'Number':
        case 'Float':
        case 'Integer':
          for (let i = 0; i < subKernels.length; i++) {
            const subKernel = subKernels[i];
            result.push(
              subKernel.returnType === 'Integer' ?
              `int subKernelResult_${ subKernel.name } = 0` :
              `float subKernelResult_${ subKernel.name } = 0.0`
            );
          }
          break;
        case 'Array(2)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec2 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
        case 'Array(3)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec3 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
        case 'Array(4)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec4 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
      }
    }

    return utils.linesToString(result) + this.translatedSource;
  }

  getMainResultGraphical() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragColor = actualColor',
    ]);
  }

  getMainResultPackedPixels() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return this.getMainResultKernelPackedPixels() +
          this.getMainResultSubKernelPackedPixels();
      default:
        throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
    }
  }

  getMainResultKernelPackedPixels() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  gl_FragData[0] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
    ]);
  }

  getMainResultSubKernelPackedPixels() {
    const result = [];
    if (!this.subKernels) return '';
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
        );
      }
    }
    return utils.linesToString(result);
  }

  getMainResultMemoryOptimizedFloats() {
    const result = [
      '  index *= 4',
    ];

    switch (this.returnType) {
      case 'Number':
      case 'Integer':
      case 'Float':
        const channels = ['r', 'g', 'b', 'a'];
        for (let i = 0; i < channels.length; i++) {
          const channel = channels[i];
          this.getMainResultKernelMemoryOptimizedFloats(result, channel);
          this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);
          if (i + 1 < channels.length) {
            result.push('  index += 1');
          }
        }
        break;
      default:
        throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`);
    }

    return utils.linesToString(result);
  }

  getMainResultKernelMemoryOptimizedFloats(result, channel) {
    result.push(
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  gl_FragData[0].${channel} = kernelResult`
    );
  }

  getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}].${channel} = float(subKernelResult_${this.subKernels[i].name})`
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}].${channel} = subKernelResult_${this.subKernels[i].name}`
        );
      }
    }
  }

  getMainResultKernelNumberTexture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult',
    ];
  }

  getMainResultSubKernelNumberTexture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}][0] = float(subKernelResult_${subKernel.name})`
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}][0] = subKernelResult_${subKernel.name}`
        );
      }
    }
    return result;
  }

  getMainResultKernelArray2Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult[0]',
      '  gl_FragData[0][1] = kernelResult[1]',
    ];
  }

  getMainResultSubKernelArray2Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
        `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`
      );
    }
    return result;
  }

  getMainResultKernelArray3Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult[0]',
      '  gl_FragData[0][1] = kernelResult[1]',
      '  gl_FragData[0][2] = kernelResult[2]',
    ];
  }

  getMainResultSubKernelArray3Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
        `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
        `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`
      );
    }
    return result;
  }

  getMainResultKernelArray4Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0] = kernelResult',
    ];
  }

  getMainResultSubKernelArray4Texture() {
    const result = [];
    if (!this.subKernels) return result;
    switch (this.returnType) {
      case 'Number':
      case 'Float':
      case 'Integer':
        for (let i = 0; i < this.subKernels.length; ++i) {
          const subKernel = this.subKernels[i];
          if (subKernel.returnType === 'Integer') {
            result.push(
              `  gl_FragData[${i + 1}] = float(subKernelResult_${this.subKernels[i].name})`
            );
          } else {
            result.push(
              `  gl_FragData[${i + 1}] = subKernelResult_${this.subKernels[i].name}`
            );
          }
        }
        break;
      case 'Array(2)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`
          );
        }
        break;
      case 'Array(3)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
            `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`
          );
        }
        break;
      case 'Array(4)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
            `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,
            `  gl_FragData[${i + 1}][3] = subKernelResult_${this.subKernels[i].name}[3]`
          );
        }
        break;
    }

    return result;
  }

  replaceArtifacts(src, map) {
    return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\n/g, (match, artifact) => {
      if (map.hasOwnProperty(artifact)) {
        return map[artifact];
      }
      throw `unhandled artifact ${artifact}`;
    });
  }

  getFragmentShader(args) {
    if (this.compiledFragmentShader !== null) {
      return this.compiledFragmentShader;
    }
    return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));
  }

  getVertexShader(args) {
    if (this.compiledVertexShader !== null) {
      return this.compiledVertexShader;
    }
    return this.compiledVertexShader = this.replaceArtifacts(this.constructor.vertexShader, this._getVertShaderArtifactMap(args));
  }

  toString() {
    const setupContextString = utils.linesToString([
      `const gl = context`,
    ]);
    return glKernelString(this.constructor, arguments, this, setupContextString);
  }

  destroy(removeCanvasReferences) {
    if (!this.context) return;
    if (this.buffer) {
      this.context.deleteBuffer(this.buffer);
    }
    if (this.framebuffer) {
      this.context.deleteFramebuffer(this.framebuffer);
    }
    for (const width in this.rawValueFramebuffers) {
      for (const height in this.rawValueFramebuffers[width]) {
        this.context.deleteFramebuffer(this.rawValueFramebuffers[width][height]);
        delete this.rawValueFramebuffers[width][height];
      }
      delete this.rawValueFramebuffers[width];
    }
    if (this.vertShader) {
      this.context.deleteShader(this.vertShader);
    }
    if (this.fragShader) {
      this.context.deleteShader(this.fragShader);
    }
    if (this.program) {
      this.context.deleteProgram(this.program);
    }
    if (this.texture) {
      this.texture.delete();
      const textureCacheIndex = this.textureCache.indexOf(this.texture.texture);
      if (textureCacheIndex > -1) {
        this.textureCache.splice(textureCacheIndex, 1);
      }
      this.texture = null;
    }
    if (this.mappedTextures && this.mappedTextures.length) {
      for (let i = 0; i < this.mappedTextures.length; i++) {
        const mappedTexture = this.mappedTextures[i];
        mappedTexture.delete();
        const textureCacheIndex = this.textureCache.indexOf(mappedTexture.texture);
        if (textureCacheIndex > -1) {
          this.textureCache.splice(textureCacheIndex, 1);
        }
      }
      this.mappedTextures = null;
    }
    if (this.kernelArguments) {
      for (let i = 0; i < this.kernelArguments.length; i++) {
        this.kernelArguments[i].destroy();
      }
    }
    if (this.kernelConstants) {
      for (let i = 0; i < this.kernelConstants.length; i++) {
        this.kernelConstants[i].destroy();
      }
    }
    while (this.textureCache.length > 0) {
      const texture = this.textureCache.pop();
      this.context.deleteTexture(texture);
    }
    if (removeCanvasReferences) {
      const idx = canvases.indexOf(this.canvas);
      if (idx >= 0) {
        canvases[idx] = null;
        maxTexSizes[idx] = null;
      }
    }
    this.destroyExtensions();
    delete this.context;
    delete this.canvas;
    if (!this.gpu) return;
    const i = this.gpu.kernels.indexOf(this);
    if (i === -1) return;
    this.gpu.kernels.splice(i, 1);
  }

  destroyExtensions() {
    this.extensions.OES_texture_float = null;
    this.extensions.OES_texture_float_linear = null;
    this.extensions.OES_element_index_uint = null;
    this.extensions.WEBGL_draw_buffers = null;
  }

  static destroyContext(context) {
    const extension = context.getExtension('WEBGL_lose_context');
    if (extension) {
      extension.loseContext();
    }
  }

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, WebGLFunctionNode).toJSON();
    json.settings.threadDim = this.threadDim;
    return json;
  }
}

module.exports = {
  WebGLKernel
};
},{"../../plugins/math-random-uniformly-distributed":112,"../../utils":114,"../function-builder":9,"../gl/kernel":13,"../gl/kernel-string":12,"./fragment-shader":37,"./function-node":38,"./kernel-value-maps":39,"./vertex-shader":71}],71:[function(require,module,exports){
const vertexShader = `__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

attribute vec2 aPos;
attribute vec2 aTexCoord;

varying vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

module.exports = {
  vertexShader
};
},{}],72:[function(require,module,exports){
const fragmentShader = `#version 300 es
__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;
__SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

in vec2 vTexCoord;

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float _round(float x) {
  return floor(x + 0.5);
}


const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x/y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  return texel[channel] * 255.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  index = index / 4;
  vec4 texel = texture(tex, st / vec2(texSize));
  return texel[channel];
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, st / vec2(texSize));
}

vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, vec3(st / vec2(texSize), z));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));

  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

module.exports = {
  fragmentShader
};
},{}],73:[function(require,module,exports){
const { utils } = require('../../utils');
const { WebGLFunctionNode } = require('../web-gl/function-node');

class WebGL2FunctionNode extends WebGLFunctionNode {

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput(
        'IdentifierExpression - not an Identifier',
        idtNode
      );
    }

    const type = this.getType(idtNode);

    const name = utils.sanitizeName(idtNode.name);
    if (idtNode.name === 'Infinity') {
      retArr.push('intBitsToFloat(2139095039)');
    } else if (type === 'Boolean') {
      if (this.argumentNames.indexOf(name) > -1) {
        retArr.push(`bool(user_${name})`);
      } else {
        retArr.push(`user_${name}`);
      }
    } else {
      retArr.push(`user_${name}`);
    }

    return retArr;
  }
}

module.exports = {
  WebGL2FunctionNode
};
},{"../../utils":114,"../web-gl/function-node":38}],74:[function(require,module,exports){
const { WebGL2KernelValueBoolean } = require('./kernel-value/boolean');
const { WebGL2KernelValueFloat } = require('./kernel-value/float');
const { WebGL2KernelValueInteger } = require('./kernel-value/integer');

const { WebGL2KernelValueHTMLImage } = require('./kernel-value/html-image');
const { WebGL2KernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');

const { WebGL2KernelValueHTMLImageArray } = require('./kernel-value/html-image-array');
const { WebGL2KernelValueDynamicHTMLImageArray } = require('./kernel-value/dynamic-html-image-array');

const { WebGL2KernelValueHTMLVideo } = require('./kernel-value/html-video');
const { WebGL2KernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');

const { WebGL2KernelValueSingleInput } = require('./kernel-value/single-input');
const { WebGL2KernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');

const { WebGL2KernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
const { WebGL2KernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');

const { WebGL2KernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
const { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');

const { WebGL2KernelValueNumberTexture } = require('./kernel-value/number-texture');
const { WebGL2KernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');

const { WebGL2KernelValueSingleArray } = require('./kernel-value/single-array');
const { WebGL2KernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');

const { WebGL2KernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
const { WebGL2KernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');

const { WebGL2KernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
const { WebGL2KernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');

const { WebGL2KernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
const { WebGL2KernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');

const { WebGL2KernelValueArray2 } = require('./kernel-value/array2');
const { WebGL2KernelValueArray3 } = require('./kernel-value/array3');
const { WebGL2KernelValueArray4 } = require('./kernel-value/array4');

const { WebGL2KernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
const { WebGL2KernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');

const kernelValueMaps = {
  unsigned: {
    dynamic: {
      'Boolean': WebGL2KernelValueBoolean,
      'Integer': WebGL2KernelValueInteger,
      'Float': WebGL2KernelValueFloat,
      'Array': WebGL2KernelValueDynamicUnsignedArray,
      'Array(2)': WebGL2KernelValueArray2,
      'Array(3)': WebGL2KernelValueArray3,
      'Array(4)': WebGL2KernelValueArray4,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGL2KernelValueDynamicUnsignedInput,
      'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
      'OffscreenCanvas': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
      'ImageBitmap': WebGL2KernelValueDynamicHTMLImage,
      'ImageData': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGL2KernelValueBoolean,
      'Float': WebGL2KernelValueFloat,
      'Integer': WebGL2KernelValueInteger,
      'Array': WebGL2KernelValueUnsignedArray,
      'Array(2)': WebGL2KernelValueArray2,
      'Array(3)': WebGL2KernelValueArray3,
      'Array(4)': WebGL2KernelValueArray4,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGL2KernelValueUnsignedInput,
      'NumberTexture': WebGL2KernelValueNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueHTMLImage,
      'OffscreenCanvas': WebGL2KernelValueHTMLImage,
      'HTMLImage': WebGL2KernelValueHTMLImage,
      'ImageBitmap': WebGL2KernelValueHTMLImage,
      'ImageData': WebGL2KernelValueHTMLImage,
      'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueHTMLVideo,
    }
  },
  single: {
    dynamic: {
      'Boolean': WebGL2KernelValueBoolean,
      'Integer': WebGL2KernelValueInteger,
      'Float': WebGL2KernelValueFloat,
      'Array': WebGL2KernelValueDynamicSingleArray,
      'Array(2)': WebGL2KernelValueArray2,
      'Array(3)': WebGL2KernelValueArray3,
      'Array(4)': WebGL2KernelValueArray4,
      'Array1D(2)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array1D(3)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array1D(4)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array2D(2)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array2D(3)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array2D(4)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array3D(2)': WebGL2KernelValueDynamicSingleArray3DI,
      'Array3D(3)': WebGL2KernelValueDynamicSingleArray3DI,
      'Array3D(4)': WebGL2KernelValueDynamicSingleArray3DI,
      'Input': WebGL2KernelValueDynamicSingleInput,
      'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
      'OffscreenCanvas': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
      'ImageBitmap': WebGL2KernelValueDynamicHTMLImage,
      'ImageData': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGL2KernelValueBoolean,
      'Float': WebGL2KernelValueFloat,
      'Integer': WebGL2KernelValueInteger,
      'Array': WebGL2KernelValueSingleArray,
      'Array(2)': WebGL2KernelValueArray2,
      'Array(3)': WebGL2KernelValueArray3,
      'Array(4)': WebGL2KernelValueArray4,
      'Array1D(2)': WebGL2KernelValueSingleArray1DI,
      'Array1D(3)': WebGL2KernelValueSingleArray1DI,
      'Array1D(4)': WebGL2KernelValueSingleArray1DI,
      'Array2D(2)': WebGL2KernelValueSingleArray2DI,
      'Array2D(3)': WebGL2KernelValueSingleArray2DI,
      'Array2D(4)': WebGL2KernelValueSingleArray2DI,
      'Array3D(2)': WebGL2KernelValueSingleArray3DI,
      'Array3D(3)': WebGL2KernelValueSingleArray3DI,
      'Array3D(4)': WebGL2KernelValueSingleArray3DI,
      'Input': WebGL2KernelValueSingleInput,
      'NumberTexture': WebGL2KernelValueNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueHTMLImage,
      'OffscreenCanvas': WebGL2KernelValueHTMLImage,
      'HTMLImage': WebGL2KernelValueHTMLImage,
      'ImageBitmap': WebGL2KernelValueHTMLImage,
      'ImageData': WebGL2KernelValueHTMLImage,
      'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueHTMLVideo,
    }
  },
};

function lookupKernelValueType(type, dynamic, precision, value) {
  if (!type) {
    throw new Error('type missing');
  }
  if (!dynamic) {
    throw new Error('dynamic missing');
  }
  if (!precision) {
    throw new Error('precision missing');
  }
  if (value.type) {
    type = value.type;
  }
  const types = kernelValueMaps[precision][dynamic];
  if (types[type] === false) {
    return null;
  } else if (types[type] === undefined) {
    throw new Error(`Could not find a KernelValue for ${ type }`);
  }
  return types[type];
}

module.exports = {
  kernelValueMaps,
  lookupKernelValueType
};
},{"./kernel-value/array2":75,"./kernel-value/array3":76,"./kernel-value/array4":77,"./kernel-value/boolean":78,"./kernel-value/dynamic-html-image":80,"./kernel-value/dynamic-html-image-array":79,"./kernel-value/dynamic-html-video":81,"./kernel-value/dynamic-memory-optimized-number-texture":82,"./kernel-value/dynamic-number-texture":83,"./kernel-value/dynamic-single-array":84,"./kernel-value/dynamic-single-array1d-i":85,"./kernel-value/dynamic-single-array2d-i":86,"./kernel-value/dynamic-single-array3d-i":87,"./kernel-value/dynamic-single-input":88,"./kernel-value/dynamic-unsigned-array":89,"./kernel-value/dynamic-unsigned-input":90,"./kernel-value/float":91,"./kernel-value/html-image":93,"./kernel-value/html-image-array":92,"./kernel-value/html-video":94,"./kernel-value/integer":95,"./kernel-value/memory-optimized-number-texture":96,"./kernel-value/number-texture":97,"./kernel-value/single-array":98,"./kernel-value/single-array1d-i":99,"./kernel-value/single-array2d-i":100,"./kernel-value/single-array3d-i":101,"./kernel-value/single-input":102,"./kernel-value/unsigned-array":103,"./kernel-value/unsigned-input":104}],75:[function(require,module,exports){
const { WebGLKernelValueArray2 } = require('../../web-gl/kernel-value/array2');

class WebGL2KernelValueArray2 extends WebGLKernelValueArray2 {}

module.exports = {
  WebGL2KernelValueArray2
};
},{"../../web-gl/kernel-value/array2":41}],76:[function(require,module,exports){
const { WebGLKernelValueArray3 } = require('../../web-gl/kernel-value/array3');

class WebGL2KernelValueArray3 extends WebGLKernelValueArray3 {}

module.exports = {
  WebGL2KernelValueArray3
};
},{"../../web-gl/kernel-value/array3":42}],77:[function(require,module,exports){
const { WebGLKernelValueArray4 } = require('../../web-gl/kernel-value/array4');

class WebGL2KernelValueArray4 extends WebGLKernelValueArray4 {}

module.exports = {
  WebGL2KernelValueArray4
};
},{"../../web-gl/kernel-value/array4":43}],78:[function(require,module,exports){
const { WebGLKernelValueBoolean } = require('../../web-gl/kernel-value/boolean');

class WebGL2KernelValueBoolean extends WebGLKernelValueBoolean {}

module.exports = {
  WebGL2KernelValueBoolean
};
},{"../../web-gl/kernel-value/boolean":44}],79:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueHTMLImageArray } = require('./html-image-array');

class WebGL2KernelValueDynamicHTMLImageArray extends WebGL2KernelValueHTMLImageArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(images) {
    const { width, height } = images[0];
    this.checkSize(width, height);
    this.dimensions = [width, height, images.length];
    this.textureSize = [width, height];
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(images);
  }
}

module.exports = {
  WebGL2KernelValueDynamicHTMLImageArray
};
},{"../../../utils":114,"./html-image-array":92}],80:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicHTMLImage } = require('../../web-gl/kernel-value/dynamic-html-image');

class WebGL2KernelValueDynamicHTMLImage extends WebGLKernelValueDynamicHTMLImage {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicHTMLImage
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-html-image":45}],81:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueDynamicHTMLImage } = require('./dynamic-html-image');

class WebGL2KernelValueDynamicHTMLVideo extends WebGL2KernelValueDynamicHTMLImage {}

module.exports = {
  WebGL2KernelValueDynamicHTMLVideo
};
},{"../../../utils":114,"./dynamic-html-image":80}],82:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/dynamic-memory-optimized-number-texture');

class WebGL2KernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueDynamicMemoryOptimizedNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture":47}],83:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicNumberTexture } = require('../../web-gl/kernel-value/dynamic-number-texture');

class WebGL2KernelValueDynamicNumberTexture extends WebGLKernelValueDynamicNumberTexture {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-number-texture":48}],84:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray } = require('../../web-gl2/kernel-value/single-array');

class WebGL2KernelValueDynamicSingleArray extends WebGL2KernelValueSingleArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array":98}],85:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray1DI } = require('../../web-gl2/kernel-value/single-array1d-i');

class WebGL2KernelValueDynamicSingleArray1DI extends WebGL2KernelValueSingleArray1DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray1DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array1d-i":99}],86:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray2DI } = require('../../web-gl2/kernel-value/single-array2d-i');

class WebGL2KernelValueDynamicSingleArray2DI extends WebGL2KernelValueSingleArray2DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray2DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array2d-i":100}],87:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray3DI } = require('../../web-gl2/kernel-value/single-array3d-i');

class WebGL2KernelValueDynamicSingleArray3DI extends WebGL2KernelValueSingleArray3DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray3DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array3d-i":101}],88:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleInput } = require('../../web-gl2/kernel-value/single-input');

class WebGL2KernelValueDynamicSingleInput extends WebGL2KernelValueSingleInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleInput
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-input":102}],89:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicUnsignedArray } = require('../../web-gl/kernel-value/dynamic-unsigned-array');

class WebGL2KernelValueDynamicUnsignedArray extends WebGLKernelValueDynamicUnsignedArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicUnsignedArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-array":54}],90:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicUnsignedInput } = require('../../web-gl/kernel-value/dynamic-unsigned-input');

class WebGL2KernelValueDynamicUnsignedInput extends WebGLKernelValueDynamicUnsignedInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicUnsignedInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-input":55}],91:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueFloat } = require('../../web-gl/kernel-value/float');

class WebGL2KernelValueFloat extends WebGLKernelValueFloat {}

module.exports = {
  WebGL2KernelValueFloat
};
},{"../../../utils":114,"../../web-gl/kernel-value/float":56}],92:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('../../web-gl/kernel-value/array');

class WebGL2KernelValueHTMLImageArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.checkSize(value[0].width, value[0].height);
    this.dimensions = [value[0].width, value[0].height, value.length];
    this.textureSize = [value[0].width, value[0].height];
  }
  defineTexture() {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(images) {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage3D(
      gl.TEXTURE_2D_ARRAY,
      0,
      gl.RGBA,
      images[0].width,
      images[0].height,
      images.length,
      0,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      null
    );
    for (let i = 0; i < images.length; i++) {
      const xOffset = 0;
      const yOffset = 0;
      const imageDepth = 1;
      gl.texSubImage3D(
        gl.TEXTURE_2D_ARRAY,
        0,
        xOffset,
        yOffset,
        i,
        images[i].width,
        images[i].height,
        imageDepth,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        this.uploadValue = images[i]
      );
    }
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueHTMLImageArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/array":40}],93:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueHTMLImage } = require('../../web-gl/kernel-value/html-image');

class WebGL2KernelValueHTMLImage extends WebGLKernelValueHTMLImage {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueHTMLImage
};
},{"../../../utils":114,"../../web-gl/kernel-value/html-image":57}],94:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueHTMLImage } = require('./html-image');

class WebGL2KernelValueHTMLVideo extends WebGL2KernelValueHTMLImage {}

module.exports = {
  WebGL2KernelValueHTMLVideo
};
},{"../../../utils":114,"./html-image":93}],95:[function(require,module,exports){
const { WebGLKernelValueInteger } = require('../../web-gl/kernel-value/integer');

class WebGL2KernelValueInteger extends WebGLKernelValueInteger {
  getSource(value) {
    const variablePrecision = this.getVariablePrecisionString();
    if (this.origin === 'constants') {
      return `const ${ variablePrecision } int ${this.id} = ${ parseInt(value) };\n`;
    }
    return `uniform ${ variablePrecision } int ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGL2KernelValueInteger
};
},{"../../web-gl/kernel-value/integer":60}],96:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/memory-optimized-number-texture');

class WebGL2KernelValueMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
  getSource() {
    const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform sampler2D ${id}`,
      `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
      `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/memory-optimized-number-texture":61}],97:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueNumberTexture } = require('../../web-gl/kernel-value/number-texture');

class WebGL2KernelValueNumberTexture extends WebGLKernelValueNumberTexture {
  getSource() {
    const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${id}`,
      `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
      `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/number-texture":62}],98:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray } = require('../../web-gl/kernel-value/single-array');

class WebGL2KernelValueSingleArray extends WebGLKernelValueSingleArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array":63}],99:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray1DI } = require('../../web-gl/kernel-value/single-array1d-i');

class WebGL2KernelValueSingleArray1DI extends WebGLKernelValueSingleArray1DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray1DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array1d-i":64}],100:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray2DI } = require('../../web-gl/kernel-value/single-array2d-i');

class WebGL2KernelValueSingleArray2DI extends WebGLKernelValueSingleArray2DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray2DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array2d-i":65}],101:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray3DI } = require('../../web-gl/kernel-value/single-array3d-i');

class WebGL2KernelValueSingleArray3DI extends WebGLKernelValueSingleArray3DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray3DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array3d-i":66}],102:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleInput } = require('../../web-gl/kernel-value/single-input');

class WebGL2KernelValueSingleInput extends WebGLKernelValueSingleInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    const { context: gl } = this;
    utils.flattenTo(input.value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-input":67}],103:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedArray } = require('../../web-gl/kernel-value/unsigned-array');

class WebGL2KernelValueUnsignedArray extends WebGLKernelValueUnsignedArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueUnsignedArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-array":68}],104:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedInput } = require('../../web-gl/kernel-value/unsigned-input');

class WebGL2KernelValueUnsignedInput extends WebGLKernelValueUnsignedInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueUnsignedInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-input":69}],105:[function(require,module,exports){
const { WebGLKernel } = require('../web-gl/kernel');
const { WebGL2FunctionNode } = require('./function-node');
const { FunctionBuilder } = require('../function-builder');
const { utils } = require('../../utils');
const { fragmentShader } = require('./fragment-shader');
const { vertexShader } = require('./vertex-shader');
const { lookupKernelValueType } = require('./kernel-value-maps');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;

let features = null;

class WebGL2Kernel extends WebGLKernel {
  static get isSupported() {
    if (isSupported !== null) {
      return isSupported;
    }
    this.setupFeatureChecks();
    isSupported = this.isContextMatch(testContext);
    return isSupported;
  }

  static setupFeatureChecks() {
    if (typeof document !== 'undefined') {
      testCanvas = document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      testCanvas = new OffscreenCanvas(0, 0);
    }
    if (!testCanvas) return;
    testContext = testCanvas.getContext('webgl2');
    if (!testContext || !testContext.getExtension) return;
    testExtensions = {
      EXT_color_buffer_float: testContext.getExtension('EXT_color_buffer_float'),
      OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
    };
    features = this.getFeatures();
  }

  static isContextMatch(context) {
    if (typeof WebGL2RenderingContext !== 'undefined') {
      return context instanceof WebGL2RenderingContext;
    }
    return false;
  }

  static getFeatures() {
    const gl = this.testContext;
    return Object.freeze({
      isFloatRead: this.getIsFloatRead(),
      isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
      isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
      kernelMap: true,
      isTextureFloat: true,
      isDrawBuffers: true,
      channelCount: this.getChannelCount(),
      maxTextureSize: this.getMaxTextureSize(),
      lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
      lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
      mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
      mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
      highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
      highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
    });
  }

  static getIsTextureFloat() {
    return true;
  }

  static getChannelCount() {
    return testContext.getParameter(testContext.MAX_DRAW_BUFFERS);
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static lookupKernelValueType(type, dynamic, precision, value) {
    return lookupKernelValueType(type, dynamic, precision, value);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  static get fragmentShader() {
    return fragmentShader;
  }
  static get vertexShader() {
    return vertexShader;
  }

  initContext() {
    const settings = {
      alpha: false,
      depth: false,
      antialias: false
    };
    return this.canvas.getContext('webgl2', settings);
  }

  initExtensions() {
    this.extensions = {
      EXT_color_buffer_float: this.context.getExtension('EXT_color_buffer_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
    };
  }

  validateSettings(args) {
    if (!this.validate) {
      this.texSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, this.output);
      return;
    }

    const { features } = this.constructor;
    if (this.precision === 'single' && !features.isFloatRead) {
      throw new Error('Float texture outputs are not supported');
    } else if (!this.graphical && this.precision === null) {
      this.precision = features.isFloatRead ? 'single' : 'unsigned';
    }

    if (this.fixIntegerDivisionAccuracy === null) {
      this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
    } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
      this.fixIntegerDivisionAccuracy = false;
    }

    this.checkOutput();

    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      switch (argType) {
        case 'Array':
          this.output = utils.getDimensions(argType);
          break;
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
          this.output = args[0].output;
          break;
        default:
          throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }

      if (this.precision === 'single') {
        console.warn('Cannot use graphical mode and single precision at the same time');
        this.precision = 'unsigned';
      }

      this.texSize = utils.clone(this.output);
      return;
    } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
      this.precision = 'single';
    }

    this.texSize = utils.getKernelTextureSize({
      optimizeFloatMemory: this.optimizeFloatMemory,
      precision: this.precision,
    }, this.output);

    this.checkTextureSize();
  }

  translateSource() {
    const functionBuilder = FunctionBuilder.fromKernel(this, WebGL2FunctionNode, {
      fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
    });
    this.translatedSource = functionBuilder.getPrototypeString('kernel');
    this.setupReturnTypes(functionBuilder);
  }

  drawBuffers() {
    this.context.drawBuffers(this.drawBuffersMap);
  }

  getTextureFormat() {
    const { context: gl } = this;
    switch (this.getInternalFormat()) {
      case gl.R32F:
        return gl.RED;
      case gl.RG32F:
        return gl.RG;
      case gl.RGBA32F:
        return gl.RGBA;
      case gl.RGBA:
        return gl.RGBA;
      default:
        throw new Error('Unknown internal format');
    }
  }
  getInternalFormat() {
    const { context: gl } = this;

    if (this.precision === 'single') {
      if (this.pipeline) {
        switch (this.returnType) {
          case 'Number':
          case 'Float':
          case 'Integer':
            if (this.optimizeFloatMemory) {
              return gl.RGBA32F;
            } else {
              return gl.R32F;
            }
            case 'Array(2)':
              return gl.RG32F;
            case 'Array(3)': 
            case 'Array(4)':
              return gl.RGBA32F;
            default:
              throw new Error('Unhandled return type');
        }
      }
      return gl.RGBA32F;
    }
    return gl.RGBA;
  }

  _setupOutputTexture() {
    const gl = this.context;
    if (this.texture) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      return;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    const texture = gl.createTexture();
    const texSize = this.texSize;
    gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    const format = this.getInternalFormat();
    if (this.precision === 'single') {
      gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    this.texture = new this.TextureConstructor({
      texture,
      size: texSize,
      dimensions: this.threadDim,
      output: this.output,
      context: this.context,
      internalFormat: this.getInternalFormat(),
      textureFormat: this.getTextureFormat(),
      kernel: this,
    });
  }

  _setupSubOutputTextures() {
    const gl = this.context;
    if (this.mappedTextures) {
      for (let i = 0; i < this.subKernels.length; i++) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
      }
      return;
    }
    const texSize = this.texSize;
    this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
    this.mappedTextures = [];
    for (let i = 0; i < this.subKernels.length; i++) {
      const texture = this.createTexture();
      this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
      gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      const format = this.getInternalFormat();
      if (this.precision === 'single') {
        gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);

      this.mappedTextures.push(new this.TextureConstructor({
        texture,
        size: texSize,
        dimensions: this.threadDim,
        output: this.output,
        context: this.context,
        internalFormat: this.getInternalFormat(),
        textureFormat: this.getTextureFormat(),
        kernel: this,
      }));
    }
  }

  _getHeaderString() {
    return '';
  }

  _getTextureCoordinate() {
    const subKernels = this.subKernels;
    const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
    if (subKernels === null || subKernels.length < 1) {
      return `in ${ variablePrecision } vec2 vTexCoord;\n`;
    } else {
      return `out ${ variablePrecision } vec2 vTexCoord;\n`;
    }
  }

  _getMainArgumentsString(args) {
    const result = [];
    const argumentNames = this.argumentNames;
    for (let i = 0; i < argumentNames.length; i++) {
      result.push(this.kernelArguments[i].getSource(args[i]));
    }
    return result.join('');
  }

  getKernelString() {
    const result = [this.getKernelResultDeclaration()];
    const subKernels = this.subKernels;
    if (subKernels !== null) {
      result.push(
        'layout(location = 0) out vec4 data0'
      );
      switch (this.returnType) {
        case 'Number':
        case 'Float':
        case 'Integer':
          for (let i = 0; i < subKernels.length; i++) {
            const subKernel = subKernels[i];
            result.push(
              subKernel.returnType === 'Integer' ?
              `int subKernelResult_${ subKernel.name } = 0` :
              `float subKernelResult_${ subKernel.name } = 0.0`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(2)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec2 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(3)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec3 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(4)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec4 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
      }
    } else {
      result.push(
        'out vec4 data0'
      );
    }

    return utils.linesToString(result) + this.translatedSource;
  }

  getMainResultGraphical() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0 = actualColor',
    ]);
  }

  getMainResultPackedPixels() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return this.getMainResultKernelPackedPixels() +
          this.getMainResultSubKernelPackedPixels();
      default:
        throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
    }
  }

  getMainResultKernelPackedPixels() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  data0 = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
    ]);
  }

  getMainResultSubKernelPackedPixels() {
    const result = [];
    if (!this.subKernels) return '';
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
        );
      } else {
        result.push(
          `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
        );
      }
    }
    return utils.linesToString(result);
  }

  getMainResultKernelMemoryOptimizedFloats(result, channel) {
    result.push(
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  data0.${channel} = kernelResult`
    );
  }

  getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1}.${channel} = float(subKernelResult_${subKernel.name})`
        );
      } else {
        result.push(
          `  data${i + 1}.${channel} = subKernelResult_${subKernel.name}`
        );
      }
    }
  }

  getMainResultKernelNumberTexture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult',
    ];
  }

  getMainResultSubKernelNumberTexture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1}[0] = float(subKernelResult_${subKernel.name})`
        );
      } else {
        result.push(
          `  data${i + 1}[0] = subKernelResult_${subKernel.name}`
        );
      }
    }
    return result;
  }

  getMainResultKernelArray2Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult[0]',
      '  data0[1] = kernelResult[1]',
    ];
  }

  getMainResultSubKernelArray2Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      result.push(
        `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
        `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`
      );
    }
    return result;
  }

  getMainResultKernelArray3Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult[0]',
      '  data0[1] = kernelResult[1]',
      '  data0[2] = kernelResult[2]',
    ];
  }

  getMainResultSubKernelArray3Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      result.push(
        `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
        `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`,
        `  data${i + 1}[2] = subKernelResult_${subKernel.name}[2]`
      );
    }
    return result;
  }

  getMainResultKernelArray4Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0 = kernelResult',
    ];
  }

  getMainResultSubKernelArray4Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  data${i + 1} = subKernelResult_${this.subKernels[i].name}`
      );
    }
    return result;
  }

  destroyExtensions() {
    this.extensions.EXT_color_buffer_float = null;
    this.extensions.OES_texture_float_linear = null;
  }

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, WebGL2FunctionNode).toJSON();
    json.settings.threadDim = this.threadDim;
    return json;
  }
}

module.exports = {
  WebGL2Kernel
};
},{"../../utils":114,"../function-builder":9,"../web-gl/kernel":70,"./fragment-shader":72,"./function-node":73,"./kernel-value-maps":74,"./vertex-shader":106}],106:[function(require,module,exports){
const vertexShader = `#version 300 es
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

in vec2 aPos;
in vec2 aTexCoord;

out vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

module.exports = {
  vertexShader
};
},{}],107:[function(require,module,exports){
const lib = require('./index');
const GPU = lib.GPU;
for (const p in lib) {
  if (!lib.hasOwnProperty(p)) continue;
  if (p === 'GPU') continue; 
  GPU[p] = lib[p];
}

if (typeof window !== 'undefined') {
  bindTo(window);
}
if (typeof self !== 'undefined') {
  bindTo(self);
}

function bindTo(target) {
  if (target.GPU) return;
  Object.defineProperty(target, 'GPU', {
    get() {
      return GPU;
    }
  });
}

module.exports = lib;
},{"./index":109}],108:[function(require,module,exports){
const { gpuMock } = require('gpu-mock.js');
const { utils } = require('./utils');
const { Kernel } = require('./backend/kernel');
const { CPUKernel } = require('./backend/cpu/kernel');
const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');
const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
const { WebGLKernel } = require('./backend/web-gl/kernel');
const { kernelRunShortcut } = require('./kernel-run-shortcut');


const kernelOrder = [HeadlessGLKernel, WebGL2Kernel, WebGLKernel];

const kernelTypes = ['gpu', 'cpu'];

const internalKernels = {
  'headlessgl': HeadlessGLKernel,
  'webgl2': WebGL2Kernel,
  'webgl': WebGLKernel,
};

let validate = true;

class GPU {
  static disableValidation() {
    validate = false;
  }

  static enableValidation() {
    validate = true;
  }

  static get isGPUSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported);
  }

  static get isKernelMapSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.kernelMap);
  }

  static get isOffscreenCanvasSupported() {
    return (typeof Worker !== 'undefined' && typeof OffscreenCanvas !== 'undefined') || typeof importScripts !== 'undefined';
  }

  static get isWebGLSupported() {
    return WebGLKernel.isSupported;
  }

  static get isWebGL2Supported() {
    return WebGL2Kernel.isSupported;
  }

  static get isHeadlessGLSupported() {
    return HeadlessGLKernel.isSupported;
  }

  static get isCanvasSupported() {
    return typeof HTMLCanvasElement !== 'undefined';
  }

  static get isGPUHTMLImageArraySupported() {
    return WebGL2Kernel.isSupported;
  }

  static get isSinglePrecisionSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.isFloatRead && Kernel.features.isTextureFloat);
  }

  constructor(settings) {
    settings = settings || {};
    this.canvas = settings.canvas || null;
    this.context = settings.context || null;
    this.mode = settings.mode;
    this.Kernel = null;
    this.kernels = [];
    this.functions = [];
    this.nativeFunctions = [];
    this.injectedNative = null;
    if (this.mode === 'dev') return;
    this.chooseKernel();
    if (settings.functions) {
      for (let i = 0; i < settings.functions.length; i++) {
        this.addFunction(settings.functions[i]);
      }
    }

    if (settings.nativeFunctions) {
      for (const p in settings.nativeFunctions) {
        if (!settings.nativeFunctions.hasOwnProperty(p)) continue;
        const s = settings.nativeFunctions[p];
        const { name, source } = s;
        this.addNativeFunction(name, source, s);
      }
    }
  }

  chooseKernel() {
    if (this.Kernel) return;

    let Kernel = null;

    if (this.context) {
      for (let i = 0; i < kernelOrder.length; i++) {
        const ExternalKernel = kernelOrder[i];
        if (ExternalKernel.isContextMatch(this.context)) {
          if (!ExternalKernel.isSupported) {
            throw new Error(`Kernel type ${ExternalKernel.name} not supported`);
          }
          Kernel = ExternalKernel;
          break;
        }
      }
      if (Kernel === null) {
        throw new Error('unknown Context');
      }
    } else if (this.mode) {
      if (this.mode in internalKernels) {
        if (!validate || internalKernels[this.mode].isSupported) {
          Kernel = internalKernels[this.mode];
        }
      } else if (this.mode === 'gpu') {
        for (let i = 0; i < kernelOrder.length; i++) {
          if (kernelOrder[i].isSupported) {
            Kernel = kernelOrder[i];
            break;
          }
        }
      } else if (this.mode === 'cpu') {
        Kernel = CPUKernel;
      }
      if (!Kernel) {
        throw new Error(`A requested mode of "${this.mode}" and is not supported`);
      }
    } else {
      for (let i = 0; i < kernelOrder.length; i++) {
        if (kernelOrder[i].isSupported) {
          Kernel = kernelOrder[i];
          break;
        }
      }
      if (!Kernel) {
        Kernel = CPUKernel;
      }
    }

    if (!this.mode) {
      this.mode = Kernel.mode;
    }
    this.Kernel = Kernel;
  }

  createKernel(source, settings) {
    if (typeof source === 'undefined') {
      throw new Error('Missing source parameter');
    }
    if (typeof source !== 'object' && !utils.isFunction(source) && typeof source !== 'string') {
      throw new Error('source parameter not a function');
    }

    const kernels = this.kernels;
    if (this.mode === 'dev') {
      const devKernel = gpuMock(source, upgradeDeprecatedCreateKernelSettings(settings));
      kernels.push(devKernel);
      return devKernel;
    }

    source = typeof source === 'function' ? source.toString() : source;
    const switchableKernels = {};
    const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings) || {};
    if (settings && typeof settings.argumentTypes === 'object') {
      settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
    }

    function onRequestFallback(args) {
      console.warn('Falling back to CPU');
      const fallbackKernel = new CPUKernel(source, {
        argumentTypes: kernelRun.argumentTypes,
        constantTypes: kernelRun.constantTypes,
        graphical: kernelRun.graphical,
        loopMaxIterations: kernelRun.loopMaxIterations,
        constants: kernelRun.constants,
        dynamicOutput: kernelRun.dynamicOutput,
        dynamicArgument: kernelRun.dynamicArguments,
        output: kernelRun.output,
        precision: kernelRun.precision,
        pipeline: kernelRun.pipeline,
        immutable: kernelRun.immutable,
        optimizeFloatMemory: kernelRun.optimizeFloatMemory,
        fixIntegerDivisionAccuracy: kernelRun.fixIntegerDivisionAccuracy,
        functions: kernelRun.functions,
        nativeFunctions: kernelRun.nativeFunctions,
        injectedNative: kernelRun.injectedNative,
        subKernels: kernelRun.subKernels,
        strictIntegers: kernelRun.strictIntegers,
        debug: kernelRun.debug,
      });
      fallbackKernel.build.apply(fallbackKernel, args);
      const result = fallbackKernel.run.apply(fallbackKernel, args);
      kernelRun.replaceKernel(fallbackKernel);
      return result;
    }

    function onRequestSwitchKernel(reasons, args, _kernel) {
      if (_kernel.debug) {
        console.warn('Switching kernels');
      }
      let newOutput = null;
      if (_kernel.signature && !switchableKernels[_kernel.signature]) {
        switchableKernels[_kernel.signature] = _kernel;
      }
      if (_kernel.dynamicOutput) {
        for (let i = reasons.length - 1; i >= 0; i--) {
          const reason = reasons[i];
          if (reason.type === 'outputPrecisionMismatch') {
            newOutput = reason.needed;
          }
        }
      }

      const Constructor = _kernel.constructor;
      const argumentTypes = Constructor.getArgumentTypes(_kernel, args);
      const signature = Constructor.getSignature(_kernel, argumentTypes);
      const existingKernel = switchableKernels[signature];
      if (existingKernel) {
        existingKernel.onActivate(_kernel);
        return existingKernel;
      }

      const newKernel = switchableKernels[signature] = new Constructor(source, {
        argumentTypes,
        constantTypes: _kernel.constantTypes,
        graphical: _kernel.graphical,
        loopMaxIterations: _kernel.loopMaxIterations,
        constants: _kernel.constants,
        dynamicOutput: _kernel.dynamicOutput,
        dynamicArgument: _kernel.dynamicArguments,
        context: _kernel.context,
        canvas: _kernel.canvas,
        output: newOutput || _kernel.output,
        precision: _kernel.precision,
        pipeline: _kernel.pipeline,
        immutable: _kernel.immutable,
        optimizeFloatMemory: _kernel.optimizeFloatMemory,
        fixIntegerDivisionAccuracy: _kernel.fixIntegerDivisionAccuracy,
        functions: _kernel.functions,
        nativeFunctions: _kernel.nativeFunctions,
        injectedNative: _kernel.injectedNative,
        subKernels: _kernel.subKernels,
        strictIntegers: _kernel.strictIntegers,
        debug: _kernel.debug,
        gpu: _kernel.gpu,
        validate,
        returnType: _kernel.returnType,
        tactic: _kernel.tactic,
        onRequestFallback,
        onRequestSwitchKernel,
        texture: _kernel.texture,
        mappedTextures: _kernel.mappedTextures,
        drawBuffersMap: _kernel.drawBuffersMap,
      });
      newKernel.build.apply(newKernel, args);
      kernelRun.replaceKernel(newKernel);
      kernels.push(newKernel);
      return newKernel;
    }
    const mergedSettings = Object.assign({
      context: this.context,
      canvas: this.canvas,
      functions: this.functions,
      nativeFunctions: this.nativeFunctions,
      injectedNative: this.injectedNative,
      gpu: this,
      validate,
      onRequestFallback,
      onRequestSwitchKernel
    }, settingsCopy);

    const kernel = new this.Kernel(source, mergedSettings);
    const kernelRun = kernelRunShortcut(kernel);

    if (!this.canvas) {
      this.canvas = kernel.canvas;
    }

    if (!this.context) {
      this.context = kernel.context;
    }

    kernels.push(kernel);

    return kernelRun;
  }

  createKernelMap() {
    let fn;
    let settings;
    const argument2Type = typeof arguments[arguments.length - 2];
    if (argument2Type === 'function' || argument2Type === 'string') {
      fn = arguments[arguments.length - 2];
      settings = arguments[arguments.length - 1];
    } else {
      fn = arguments[arguments.length - 1];
    }

    if (this.mode !== 'dev') {
      if (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) {
        if (this.mode && kernelTypes.indexOf(this.mode) < 0) {
          throw new Error(`kernelMap not supported on ${this.Kernel.name}`);
        }
      }
    }

    const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings);
    if (settings && typeof settings.argumentTypes === 'object') {
      settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
    }

    if (Array.isArray(arguments[0])) {
      settingsCopy.subKernels = [];
      const functions = arguments[0];
      for (let i = 0; i < functions.length; i++) {
        const source = functions[i].toString();
        const name = utils.getFunctionNameFromString(source);
        settingsCopy.subKernels.push({
          name,
          source,
          property: i,
        });
      }
    } else {
      settingsCopy.subKernels = [];
      const functions = arguments[0];
      for (let p in functions) {
        if (!functions.hasOwnProperty(p)) continue;
        const source = functions[p].toString();
        const name = utils.getFunctionNameFromString(source);
        settingsCopy.subKernels.push({
          name: name || p,
          source,
          property: p,
        });
      }
    }
    return this.createKernel(fn, settingsCopy);
  }

  combineKernels() {
    const firstKernel = arguments[0];
    const combinedKernel = arguments[arguments.length - 1];
    if (firstKernel.kernel.constructor.mode === 'cpu') return combinedKernel;
    const canvas = arguments[0].canvas;
    const context = arguments[0].context;
    const max = arguments.length - 1;
    for (let i = 0; i < max; i++) {
      arguments[i]
        .setCanvas(canvas)
        .setContext(context)
        .setPipeline(true);
    }

    return function() {
      const texture = combinedKernel.apply(this, arguments);
      if (texture.toArray) {
        return texture.toArray();
      }
      return texture;
    };
  }

  setFunctions(functions) {
    this.functions = functions;
    return this;
  }

  setNativeFunctions(nativeFunctions) {
    this.nativeFunctions = nativeFunctions;
    return this;
  }

  addFunction(source, settings) {
    this.functions.push({ source, settings });
    return this;
  }

  addNativeFunction(name, source, settings) {
    if (this.kernels.length > 0) {
      throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');
    }
    this.nativeFunctions.push(Object.assign({ name, source }, settings));
    return this;
  }

  injectNative(source) {
    this.injectedNative = source;
    return this;
  }

  destroy() {
    return new Promise((resolve, reject) => {
      if (!this.kernels) {
        resolve();
      }
      setTimeout(() => {
        try {
          for (let i = 0; i < this.kernels.length; i++) {
            this.kernels[i].destroy(true); 
          }
          let firstKernel = this.kernels[0];
          if (firstKernel) {
            if (firstKernel.kernel) {
              firstKernel = firstKernel.kernel;
            }
            if (firstKernel.constructor.destroyContext) {
              firstKernel.constructor.destroyContext(this.context);
            }
          }
        } catch (e) {
          reject(e);
        }
        resolve();
      }, 0);
    });
  }
}


function upgradeDeprecatedCreateKernelSettings(settings) {
  if (!settings) {
    return {};
  }
  const upgradedSettings = Object.assign({}, settings);

  if (settings.hasOwnProperty('floatOutput')) {
    utils.warnDeprecated('setting', 'floatOutput', 'precision');
    upgradedSettings.precision = settings.floatOutput ? 'single' : 'unsigned';
  }
  if (settings.hasOwnProperty('outputToTexture')) {
    utils.warnDeprecated('setting', 'outputToTexture', 'pipeline');
    upgradedSettings.pipeline = Boolean(settings.outputToTexture);
  }
  if (settings.hasOwnProperty('outputImmutable')) {
    utils.warnDeprecated('setting', 'outputImmutable', 'immutable');
    upgradedSettings.immutable = Boolean(settings.outputImmutable);
  }
  if (settings.hasOwnProperty('floatTextures')) {
    utils.warnDeprecated('setting', 'floatTextures', 'optimizeFloatMemory');
    upgradedSettings.optimizeFloatMemory = Boolean(settings.floatTextures);
  }
  return upgradedSettings;
}

module.exports = {
  GPU,
  kernelOrder,
  kernelTypes
};
},{"./backend/cpu/kernel":8,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/kernel":70,"./backend/web-gl2/kernel":105,"./kernel-run-shortcut":111,"./utils":114,"gpu-mock.js":4}],109:[function(require,module,exports){
const { GPU } = require('./gpu');
const { alias } = require('./alias');
const { utils } = require('./utils');
const { Input, input } = require('./input');
const { Texture } = require('./texture');
const { FunctionBuilder } = require('./backend/function-builder');
const { FunctionNode } = require('./backend/function-node');
const { CPUFunctionNode } = require('./backend/cpu/function-node');
const { CPUKernel } = require('./backend/cpu/kernel');

const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');

const { WebGLFunctionNode } = require('./backend/web-gl/function-node');
const { WebGLKernel } = require('./backend/web-gl/kernel');
const { kernelValueMaps: webGLKernelValueMaps } = require('./backend/web-gl/kernel-value-maps');

const { WebGL2FunctionNode } = require('./backend/web-gl2/function-node');
const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
const { kernelValueMaps: webGL2KernelValueMaps } = require('./backend/web-gl2/kernel-value-maps');

const { GLKernel } = require('./backend/gl/kernel');

const { Kernel } = require('./backend/kernel');

const { FunctionTracer } = require('./backend/function-tracer');

const mathRandom = require('./plugins/math-random-uniformly-distributed');

module.exports = {
  alias,
  CPUFunctionNode,
  CPUKernel,
  GPU,
  FunctionBuilder,
  FunctionNode,
  HeadlessGLKernel,
  Input,
  input,
  Texture,
  utils,

  WebGL2FunctionNode,
  WebGL2Kernel,
  webGL2KernelValueMaps,

  WebGLFunctionNode,
  WebGLKernel,
  webGLKernelValueMaps,

  GLKernel,
  Kernel,
  FunctionTracer,

  plugins: {
    mathRandom
  }
};
},{"./alias":5,"./backend/cpu/function-node":6,"./backend/cpu/kernel":8,"./backend/function-builder":9,"./backend/function-node":10,"./backend/function-tracer":11,"./backend/gl/kernel":13,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/function-node":38,"./backend/web-gl/kernel":70,"./backend/web-gl/kernel-value-maps":39,"./backend/web-gl2/function-node":73,"./backend/web-gl2/kernel":105,"./backend/web-gl2/kernel-value-maps":74,"./gpu":108,"./input":110,"./plugins/math-random-uniformly-distributed":112,"./texture":113,"./utils":114}],110:[function(require,module,exports){
class Input {
  constructor(value, size) {
    this.value = value;
    if (Array.isArray(size)) {
      this.size = size;
    } else {
      this.size = new Int32Array(3);
      if (size.z) {
        this.size = new Int32Array([size.x, size.y, size.z]);
      } else if (size.y) {
        this.size = new Int32Array([size.x, size.y]);
      } else {
        this.size = new Int32Array([size.x]);
      }
    }

    const [w, h, d] = this.size;
    if (d) {
      if (this.value.length !== (w * h * d)) {
        throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} * ${d} = ${(h * w * d)}`);
      }
    } else if (h) {
      if (this.value.length !== (w * h)) {
        throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} = ${(h * w)}`);
      }
    } else {
      if (this.value.length !== w) {
        throw new Error(`Input size ${this.value.length} does not match ${w}`);
      }
    }

  }

  toArray() {
    const { utils } = require('./utils');
    const [w, h, d] = this.size;
    if (d) {
      return utils.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h, d);
    } else if (h) {
      return utils.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h);
    } else {
      return this.value;
    }
  }
}

function input(value, size) {
  return new Input(value, size);
}

module.exports = {
  Input,
  input
};
},{"./utils":114}],111:[function(require,module,exports){
const { utils } = require('./utils');

function kernelRunShortcut(kernel) {
  let run = function() {
    kernel.build.apply(kernel, arguments);
    run = function() {
      let result = kernel.run.apply(kernel, arguments);
      if (kernel.switchingKernels) {
        const reasons = kernel.resetSwitchingKernels();
        const newKernel = kernel.onRequestSwitchKernel(reasons, arguments, kernel);
        shortcut.kernel = kernel = newKernel;
        result = newKernel.run.apply(newKernel, arguments);
      }
      if (kernel.renderKernels) {
        return kernel.renderKernels();
      } else if (kernel.renderOutput) {
        return kernel.renderOutput();
      } else {
        return result;
      }
    };
    return run.apply(kernel, arguments);
  };
  const shortcut = function() {
    return run.apply(kernel, arguments);
  };
  shortcut.exec = function() {
    return new Promise((accept, reject) => {
      try {
        accept(run.apply(this, arguments));
      } catch (e) {
        reject(e);
      }
    });
  };
  shortcut.replaceKernel = function(replacementKernel) {
    kernel = replacementKernel;
    bindKernelToShortcut(kernel, shortcut);
  };

  bindKernelToShortcut(kernel, shortcut);
  return shortcut;
}

function bindKernelToShortcut(kernel, shortcut) {
  if (shortcut.kernel) {
    shortcut.kernel = kernel;
    return;
  }
  const properties = utils.allPropertiesOf(kernel);
  for (let i = 0; i < properties.length; i++) {
    const property = properties[i];
    if (property[0] === '_' && property[1] === '_') continue;
    if (typeof kernel[property] === 'function') {
      if (property.substring(0, 3) === 'add' || property.substring(0, 3) === 'set') {
        shortcut[property] = function() {
          shortcut.kernel[property].apply(shortcut.kernel, arguments);
          return shortcut;
        };
      } else {
        shortcut[property] = function() {
          return shortcut.kernel[property].apply(shortcut.kernel, arguments);
        };
      }
    } else {
      shortcut.__defineGetter__(property, () => shortcut.kernel[property]);
      shortcut.__defineSetter__(property, (value) => {
        shortcut.kernel[property] = value;
      });
    }
  }
  shortcut.kernel = kernel;
}
module.exports = {
  kernelRunShortcut
};
},{"./utils":114}],112:[function(require,module,exports){
const source = `// https://www.shadertoy.com/view/4t2SDh
//note: uniformly distributed, normalized rand, [0,1]
highp float randomSeedShift = 1.0;
highp float slide = 1.0;
uniform highp float randomSeed1;
uniform highp float randomSeed2;

highp float nrand(highp vec2 n) {
  highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);
  randomSeedShift = result;
  if (randomSeedShift > 0.5) {
    slide += 0.00009; 
  } else {
    slide += 0.0009;
  }
  return result;
}`;

const name = 'math-random-uniformly-distributed';

const functionMatch = `Math.random()`;

const functionReplace = `nrand(vTexCoord)`;

const functionReturnType = 'Number';
const onBeforeRun = (kernel) => {
  kernel.setUniform1f('randomSeed1', Math.random());
  kernel.setUniform1f('randomSeed2', Math.random());
};

const plugin = {
  name,
  onBeforeRun,
  functionMatch,
  functionReplace,
  functionReturnType,
  source
};

module.exports = plugin;
},{}],113:[function(require,module,exports){
class Texture {
  constructor(settings) {
    const {
      texture,
      size,
      dimensions,
      output,
      context,
      type = 'NumberTexture',
      kernel,
      internalFormat,
      textureFormat
    } = settings;
    if (!output) throw new Error('settings property "output" required.');
    if (!context) throw new Error('settings property "context" required.');
    if (!texture) throw new Error('settings property "texture" required.');
    if (!kernel) throw new Error('settings property "kernel" required.');
    this.texture = texture;
    if (texture._refs) {
      texture._refs++;
    } else {
      texture._refs = 1;
    }
    this.size = size;
    this.dimensions = dimensions;
    this.output = output;
    this.context = context;
    this.kernel = kernel;
    this.type = type;
    this._deleted = false;
    this.internalFormat = internalFormat;
    this.textureFormat = textureFormat;
  }

  toArray() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  clone() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  delete() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  clear() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }
}

module.exports = {
  Texture
};
},{}],114:[function(require,module,exports){
const acorn = require('acorn');
const { Input } = require('./input');
const { Texture } = require('./texture');

const FUNCTION_NAME = /function ([^(]*)/;
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
const ARGUMENT_NAMES = /([^\s,]+)/g;

const utils = {
  systemEndianness() {
    return _systemEndianness;
  },
  getSystemEndianness() {
    const b = new ArrayBuffer(4);
    const a = new Uint32Array(b);
    const c = new Uint8Array(b);
    a[0] = 0xdeadbeef;
    if (c[0] === 0xef) return 'LE';
    if (c[0] === 0xde) return 'BE';
    throw new Error('unknown endianness');
  },

  isFunction(funcObj) {
    return typeof(funcObj) === 'function';
  },

  isFunctionString(fn) {
    if (typeof fn === 'string') {
      return (fn
        .slice(0, 'function'.length)
        .toLowerCase() === 'function');
    }
    return false;
  },

  getFunctionNameFromString(funcStr) {
    const result = FUNCTION_NAME.exec(funcStr);
    if (!result || result.length === 0) return null;
    return result[1].trim();
  },

  getFunctionBodyFromString(funcStr) {
    return funcStr.substring(funcStr.indexOf('{') + 1, funcStr.lastIndexOf('}'));
  },

  getArgumentNamesFromString(fn) {
    const fnStr = fn.replace(STRIP_COMMENTS, '');
    let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
    if (result === null) {
      result = [];
    }
    return result;
  },

  clone(obj) {
    if (obj === null || typeof obj !== 'object' || obj.hasOwnProperty('isActiveClone')) return obj;

    const temp = obj.constructor(); 

    for (let key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        obj.isActiveClone = null;
        temp[key] = utils.clone(obj[key]);
        delete obj.isActiveClone;
      }
    }

    return temp;
  },

  isArray(array) {
    return !isNaN(array.length);
  },

  getVariableType(value, strictIntegers) {
    if (utils.isArray(value)) {
      if (value.length > 0 && value[0].nodeName === 'IMG') {
        return 'HTMLImageArray';
      }
      return 'Array';
    }

    switch (value.constructor) {
      case Boolean:
        return 'Boolean';
      case Number:
        if (strictIntegers && Number.isInteger(value)) {
          return 'Integer';
        }
        return 'Float';
      case Texture:
        return value.type;
      case Input:
        return 'Input';
    }
    if ('nodeName'  in value) {
      switch (value.nodeName) {
        case 'IMG':
          return 'HTMLImage';
        case 'CANVAS':
          return 'HTMLImage';
        case 'VIDEO':
          return 'HTMLVideo';
      }
    } else if (value.hasOwnProperty('type')) {
      return value.type;
    } else if (typeof OffscreenCanvas !== 'undefined' && value instanceof OffscreenCanvas) {
      return 'OffscreenCanvas';
    } else if (typeof ImageBitmap !== 'undefined' && value instanceof ImageBitmap) {
      return 'ImageBitmap';
    } else if (typeof ImageData !== 'undefined' && value instanceof ImageData) {
      return 'ImageData';
    }
    return 'Unknown';
  },

  getKernelTextureSize(settings, dimensions) {
    let [w, h, d] = dimensions;
    let texelCount = (w || 1) * (h || 1) * (d || 1);

    if (settings.optimizeFloatMemory && settings.precision === 'single') {
      w = texelCount = Math.ceil(texelCount / 4);
    }
    if (h > 1 && w * h === texelCount) {
      return new Int32Array([w, h]);
    }
    return utils.closestSquareDimensions(texelCount);
  },

  closestSquareDimensions(length) {
    const sqrt = Math.sqrt(length);
    let high = Math.ceil(sqrt);
    let low = Math.floor(sqrt);
    while (high * low < length) {
      high--;
      low = Math.ceil(length / high);
    }
    return new Int32Array([low, Math.ceil(length / low)]);
  },

  getMemoryOptimizedFloatTextureSize(dimensions, bitRatio) {
    const totalArea = utils.roundTo((dimensions[0] || 1) * (dimensions[1] || 1) * (dimensions[2] || 1) * (dimensions[3] || 1), 4);
    const texelCount = totalArea / bitRatio;
    return utils.closestSquareDimensions(texelCount);
  },

  getMemoryOptimizedPackedTextureSize(dimensions, bitRatio) {
    const [w, h, d] = dimensions;
    const totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);
    const texelCount = totalArea / (4 / bitRatio);
    return utils.closestSquareDimensions(texelCount);
  },

  roundTo(n, d) {
    return Math.floor((n + d - 1) / d) * d;
  },
  getDimensions(x, pad) {
    let ret;
    if (utils.isArray(x)) {
      const dim = [];
      let temp = x;
      while (utils.isArray(temp)) {
        dim.push(temp.length);
        temp = temp[0];
      }
      ret = dim.reverse();
    } else if (x instanceof Texture) {
      ret = x.output;
    } else if (x instanceof Input) {
      ret = x.size;
    } else {
      throw new Error(`Unknown dimensions of ${x}`);
    }

    if (pad) {
      ret = Array.from(ret);
      while (ret.length < 3) {
        ret.push(1);
      }
    }

    return new Int32Array(ret);
  },

  flatten2dArrayTo(array, target) {
    let offset = 0;
    for (let y = 0; y < array.length; y++) {
      target.set(array[y], offset);
      offset += array[y].length;
    }
  },

  flatten3dArrayTo(array, target) {
    let offset = 0;
    for (let z = 0; z < array.length; z++) {
      for (let y = 0; y < array[z].length; y++) {
        target.set(array[z][y], offset);
        offset += array[z][y].length;
      }
    }
  },

  flatten4dArrayTo(array, target) {
    let offset = 0;
    for (let l = 0; l < array.length; l++) {
      for (let z = 0; z < array[l].length; z++) {
        for (let y = 0; y < array[l][z].length; y++) {
          target.set(array[l][z][y], offset);
          offset += array[l][z][y].length;
        }
      }
    }
  },

  flattenTo(array, target) {
    if (utils.isArray(array[0])) {
      if (utils.isArray(array[0][0])) {
        if (utils.isArray(array[0][0][0])) {
          utils.flatten4dArrayTo(array, target);
        } else {
          utils.flatten3dArrayTo(array, target);
        }
      } else {
        utils.flatten2dArrayTo(array, target);
      }
    } else {
      target.set(array);
    }
  },

  splitArray(array, part) {
    const result = [];
    for (let i = 0; i < array.length; i += part) {
      result.push(new array.constructor(array.buffer, i * 4 + array.byteOffset, part));
    }
    return result;
  },

  getAstString(source, ast) {
    const lines = Array.isArray(source) ? source : source.split(/\r?\n/g);
    const start = ast.loc.start;
    const end = ast.loc.end;
    const result = [];
    if (start.line === end.line) {
      result.push(lines[start.line - 1].substring(start.column, end.column));
    } else {
      result.push(lines[start.line - 1].slice(start.column));
      for (let i = start.line; i < end.line; i++) {
        result.push(lines[i]);
      }
      result.push(lines[end.line - 1].slice(0, end.column));
    }
    return result.join('\n');
  },

  allPropertiesOf(obj) {
    const props = [];

    do {
      props.push.apply(props, Object.getOwnPropertyNames(obj));
    } while (obj = Object.getPrototypeOf(obj));

    return props;
  },

  linesToString(lines) {
    if (lines.length > 0) {
      return lines.join(';\n') + ';\n';
    } else {
      return '\n';
    }
  },
  warnDeprecated(type, oldName, newName) {
    if (newName) {
      console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been replaced with "${ newName }". Fixing, but please upgrade as it will soon be removed.`);
    } else {
      console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been removed. Fixing, but please upgrade as it will soon be removed.`);
    }
  },
  flipPixels: (pixels, width, height) => {
    const halfHeight = height / 2 | 0; 
    const bytesPerRow = width * 4;
    const temp = new Uint8ClampedArray(width * 4);
    const result = pixels.slice(0);
    for (let y = 0; y < halfHeight; ++y) {
      const topOffset = y * bytesPerRow;
      const bottomOffset = (height - y - 1) * bytesPerRow;

      temp.set(result.subarray(topOffset, topOffset + bytesPerRow));

      result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);

      result.set(temp, bottomOffset);
    }
    return result;
  },
  erectPackedFloat: (array, width) => {
    return array.subarray(0, width);
  },
  erect2DPackedFloat: (array, width, height) => {
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xStart = y * width;
      const xEnd = xStart + width;
      yResults[y] = array.subarray(xStart, xEnd);
    }
    return yResults;
  },
  erect3DPackedFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xStart = (z * height * width) + y * width;
        const xEnd = xStart + width;
        yResults[y] = array.subarray(xStart, xEnd);
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectMemoryOptimizedFloat: (array, width) => {
    return array.subarray(0, width);
  },
  erectMemoryOptimized2DFloat: (array, width, height) => {
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const offset = y * width;
      yResults[y] = array.subarray(offset, offset + width);
    }
    return yResults;
  },
  erectMemoryOptimized3DFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const offset = (z * height * width) + (y * width);
        yResults[y] = array.subarray(offset, offset + width);
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectFloat: (array, width) => {
    const xResults = new Float32Array(width);
    let i = 0;
    for (let x = 0; x < width; x++) {
      xResults[x] = array[i];
      i += 4;
    }
    return xResults;
  },
  erect2DFloat: (array, width, height) => {
    const yResults = new Array(height);
    let i = 0;
    for (let y = 0; y < height; y++) {
      const xResults = new Float32Array(width);
      for (let x = 0; x < width; x++) {
        xResults[x] = array[i];
        i += 4;
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    let i = 0;
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Float32Array(width);
        for (let x = 0; x < width; x++) {
          xResults[x] = array[i];
          i += 4;
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray2: (array, width) => {
    const xResults = new Array(width);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 2);
    }
    return xResults;
  },
  erect2DArray2: (array, width, height) => {
    const yResults = new Array(height);
    const XResultsMax = width * 4;
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * XResultsMax;
      let i = 0;
      for (let x = 0; x < XResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 2);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray2: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 2);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray3: (array, width) => {
    const xResults = new Array(width);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 3);
    }
    return xResults;
  },
  erect2DArray3: (array, width, height) => {
    const xResultsMax = width * 4;
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * xResultsMax;
      let i = 0;
      for (let x = 0; x < xResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 3);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray3: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 3);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray4: (array, width) => {
    const xResults = new Array(array);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 4);
    }
    return xResults;
  },
  erect2DArray4: (array, width, height) => {
    const xResultsMax = width * 4;
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * xResultsMax;
      let i = 0;
      for (let x = 0; x < xResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 4);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray4: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 4);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },

  flattenFunctionToString: (source, settings) => {
    const { findDependency, thisLookup, doNotDefine } = settings;
    let flattened = settings.flattened;
    if (!flattened) {
      flattened = settings.flattened = {};
    }
    const ast = acorn.parse(source);
    const functionDependencies = [];
    let indent = 0;

    function flatten(ast) {
      if (Array.isArray(ast)) {
        const results = [];
        for (let i = 0; i < ast.length; i++) {
          results.push(flatten(ast[i]));
        }
        return results.join('');
      }
      switch (ast.type) {
        case 'Program':
          return flatten(ast.body) + (ast.body[0].type === 'VariableDeclaration' ? ';' : '');
        case 'FunctionDeclaration':
          return `function ${ast.id.name}(${ast.params.map(flatten).join(', ')}) ${ flatten(ast.body) }`;
        case 'BlockStatement': {
          const result = [];
          indent += 2;
          for (let i = 0; i < ast.body.length; i++) {
            const flat = flatten(ast.body[i]);
            if (flat) {
              result.push(' '.repeat(indent) + flat, ';\n');
            }
          }
          indent -= 2;
          return `{\n${result.join('')}}`;
        }
        case 'VariableDeclaration':
          const declarations = utils.normalizeDeclarations(ast)
            .map(flatten)
            .filter(r => r !== null);
          if (declarations.length < 1) {
            return '';
          } else {
            return `${ast.kind} ${declarations.join(',')}`;
          }
          case 'VariableDeclarator':
            if (ast.init.object && ast.init.object.type === 'ThisExpression') {
              const lookup = thisLookup(ast.init.property.name, true);
              if (lookup) {
                return `${ast.id.name} = ${flatten(ast.init)}`;
              } else {
                return null;
              }
            } else {
              return `${ast.id.name} = ${flatten(ast.init)}`;
            }
            case 'CallExpression': {
              if (ast.callee.property.name === 'subarray') {
                return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              }
              if (ast.callee.object.name === 'gl' || ast.callee.object.name === 'context') {
                return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              }
              if (ast.callee.object.type === 'ThisExpression') {
                functionDependencies.push(findDependency('this', ast.callee.property.name));
                return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              } else if (ast.callee.object.name) {
                const foundSource = findDependency(ast.callee.object.name, ast.callee.property.name);
                if (foundSource === null) {
                  return `${ast.callee.object.name}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                } else {
                  functionDependencies.push(foundSource);
                  return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                }
              } else if (ast.callee.object.type === 'MemberExpression') {
                return `${flatten(ast.callee.object)}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              } else {
                throw new Error('unknown ast.callee');
              }
            }
            case 'ReturnStatement':
              return `return ${flatten(ast.argument)}`;
            case 'BinaryExpression':
              return `(${flatten(ast.left)}${ast.operator}${flatten(ast.right)})`;
            case 'UnaryExpression':
              if (ast.prefix) {
                return `${ast.operator} ${flatten(ast.argument)}`;
              } else {
                return `${flatten(ast.argument)} ${ast.operator}`;
              }
              case 'ExpressionStatement':
                return `${flatten(ast.expression)}`;
              case 'SequenceExpression':
                return `(${flatten(ast.expressions)})`;
              case 'ArrowFunctionExpression':
                return `(${ast.params.map(flatten).join(', ')}) => ${flatten(ast.body)}`;
              case 'Literal':
                return ast.raw;
              case 'Identifier':
                return ast.name;
              case 'MemberExpression':
                if (ast.object.type === 'ThisExpression') {
                  return thisLookup(ast.property.name);
                }
                if (ast.computed) {
                  return `${flatten(ast.object)}[${flatten(ast.property)}]`;
                }
                return flatten(ast.object) + '.' + flatten(ast.property);
              case 'ThisExpression':
                return 'this';
              case 'NewExpression':
                return `new ${flatten(ast.callee)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              case 'ForStatement':
                return `for (${flatten(ast.init)};${flatten(ast.test)};${flatten(ast.update)}) ${flatten(ast.body)}`;
              case 'AssignmentExpression':
                return `${flatten(ast.left)}${ast.operator}${flatten(ast.right)}`;
              case 'UpdateExpression':
                return `${flatten(ast.argument)}${ast.operator}`;
              case 'IfStatement':
                return `if (${flatten(ast.test)}) ${flatten(ast.consequent)}`;
              case 'ThrowStatement':
                return `throw ${flatten(ast.argument)}`;
              case 'ObjectPattern':
                return ast.properties.map(flatten).join(', ');
              case 'ArrayPattern':
                return ast.elements.map(flatten).join(', ');
              case 'DebuggerStatement':
                return 'debugger;';
              case 'ConditionalExpression':
                return `${flatten(ast.test)}?${flatten(ast.consequent)}:${flatten(ast.alternate)}`;
              case 'Property':
                if (ast.kind === 'init') {
                  return flatten(ast.key);
                }
      }
      throw new Error(`unhandled ast.type of ${ ast.type }`);
    }
    const result = flatten(ast);
    if (functionDependencies.length > 0) {
      const flattenedFunctionDependencies = [];
      for (let i = 0; i < functionDependencies.length; i++) {
        const functionDependency = functionDependencies[i];
        if (!flattened[functionDependency]) {
          flattened[functionDependency] = true;
        }
        functionDependency ? flattenedFunctionDependencies.push(utils.flattenFunctionToString(functionDependency, settings) + '\n') : '';
      }
      return flattenedFunctionDependencies.join('') + result;
    }
    return result;
  },

  normalizeDeclarations: (ast) => {
    if (ast.type !== 'VariableDeclaration') throw new Error('Ast is not of type "VariableDeclaration"');
    const normalizedDeclarations = [];
    for (let declarationIndex = 0; declarationIndex < ast.declarations.length; declarationIndex++) {
      const declaration = ast.declarations[declarationIndex];
      if (declaration.id && declaration.id.type === 'ObjectPattern' && declaration.id.properties) {
        const { properties } = declaration.id;
        for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {
          const property = properties[propertyIndex];
          if (property.value.type === 'ObjectPattern' && property.value.properties) {
            for (let subPropertyIndex = 0; subPropertyIndex < property.value.properties.length; subPropertyIndex++) {
              const subProperty = property.value.properties[subPropertyIndex];
              if (subProperty.type === 'Property') {
                normalizedDeclarations.push({
                  type: 'VariableDeclarator',
                  id: {
                    type: 'Identifier',
                    name: subProperty.key.name
                  },
                  init: {
                    type: 'MemberExpression',
                    object: {
                      type: 'MemberExpression',
                      object: declaration.init,
                      property: {
                        type: 'Identifier',
                        name: property.key.name
                      },
                      computed: false
                    },
                    property: {
                      type: 'Identifier',
                      name: subProperty.key.name
                    },
                    computed: false
                  }
                });
              } else {
                throw new Error('unexpected state');
              }
            }
          } else if (property.value.type === 'Identifier') {
            normalizedDeclarations.push({
              type: 'VariableDeclarator',
              id: {
                type: 'Identifier',
                name: property.value && property.value.name ? property.value.name : property.key.name
              },
              init: {
                type: 'MemberExpression',
                object: declaration.init,
                property: {
                  type: 'Identifier',
                  name: property.key.name
                },
                computed: false
              }
            });
          } else {
            throw new Error('unexpected state');
          }
        }
      } else if (declaration.id && declaration.id.type === 'ArrayPattern' && declaration.id.elements) {
        const { elements } = declaration.id;
        for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {
          const element = elements[elementIndex];
          if (element.type === 'Identifier') {
            normalizedDeclarations.push({
              type: 'VariableDeclarator',
              id: {
                type: 'Identifier',
                name: element.name
              },
              init: {
                type: 'MemberExpression',
                object: declaration.init,
                property: {
                  type: 'Literal',
                  value: elementIndex,
                  raw: elementIndex.toString(),
                  start: element.start,
                  end: element.end
                },
                computed: true
              }
            });
          } else {
            throw new Error('unexpected state');
          }
        }
      } else {
        normalizedDeclarations.push(declaration);
      }
    }
    return normalizedDeclarations;
  },

  splitHTMLImageToRGB: (gpu, image) => {
    const rKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.r * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const gKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.g * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const bKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.b * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const aKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.a * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const result = [
      rKernel(image),
      gKernel(image),
      bKernel(image),
      aKernel(image),
    ];
    result.rKernel = rKernel;
    result.gKernel = gKernel;
    result.bKernel = bKernel;
    result.aKernel = aKernel;
    result.gpu = gpu;
    return result;
  },

  splitRGBAToCanvases: (gpu, rgba, width, height) => {
    const visualKernelR = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(pixel.r / 255, 0, 0, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelR(rgba);

    const visualKernelG = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(0, pixel.g / 255, 0, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelG(rgba);

    const visualKernelB = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(0, 0, pixel.b / 255, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelB(rgba);

    const visualKernelA = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(255, 255, 255, pixel.a / 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelA(rgba);
    return [
      visualKernelR.canvas,
      visualKernelG.canvas,
      visualKernelB.canvas,
      visualKernelA.canvas,
    ];
  },

  getMinifySafeName: (fn) => {
    try {
      const ast = acorn.parse(`const value = ${fn.toString()}`);
      const { init } = ast.body[0].declarations[0];
      return init.body.name || init.body.body[0].argument.name;
    } catch (e) {
      throw new Error('Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }');
    }
  },
  sanitizeName: function(name) {
    if (dollarSign.test(name)) {
      name = name.replace(dollarSign, 'S_S');
    }
    if (doubleUnderscore.test(name)) {
      name = name.replace(doubleUnderscore, 'U_U');
    } else if (singleUnderscore.test(name)) {
      name = name.replace(singleUnderscore, 'u_u');
    }
    return name;
  }
};

const dollarSign = /\$/;
const doubleUnderscore = /__/;
const singleUnderscore = /_/;

const _systemEndianness = utils.getSystemEndianness();

module.exports = {
  utils
};

},{"./input":110,"./texture":113,"acorn":1}]},{},[107])(107)
});


/***/ }),

/***/ "./src/renderer.ts":
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Renderer": () => (/* binding */ Renderer)
/* harmony export */ });
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var Renderer = /** @class */ (function () {
    function Renderer() {
        this.renderSettings = {
            mouseX: 1,
            mouseY: 1,
        };
        this.isDrawing = false;
    }
    Renderer.prototype.createRenderer = function (gpu, canvas) {
        return __awaiter(this, void 0, void 0, function () {
            var redr, redraw;
            var _this = this;
            return __generator(this, function (_a) {
                redr = gpu
                    .createKernel(function (mouseX, mouseY) {
                    function num(a) {
                        return a;
                    }
                    function dist(x, y) {
                        return x + y;
                    }
                    var dst = dist(this.thread.x - num(mouseX), this.thread.y - num(mouseY)) /
                        dist(this.output.x, this.output.y);
                    /*
                      Math.sqrt(
                        (this.thread.x - num(mouseX)) *
                          (this.thread.x - (mouseX as number)) +
                          (this.output.y - this.thread.y - (mouseY as number)) *
                            (this.output.y - this.thread.y - (mouseY as number))
                      ) /
                      Math.sqrt(
                        this.output.x * this.output.x + this.output.y * this.output.y
                      )*/
                    this.color(0.3, Math.max(1 - 2 * dst, 0), Math.max(1 - 2 * dst, 0), 1);
                })
                    .setOutput([canvas.width, canvas.height])
                    .setDynamicOutput(true)
                    .setGraphical(true);
                redraw = (function () {
                    redr(_this.renderSettings.mouseX, _this.renderSettings.mouseY);
                });
                redraw.change = redr;
                this.redraw = redraw;
                redraw();
                return [2 /*return*/];
            });
        });
    };
    Renderer.prototype.setVar = function (name, val) {
        this.renderSettings["".concat(name)] = val;
    };
    return Renderer;
}());



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var gpu_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gpu.js */ "./node_modules/gpu.js/dist/gpu-browser.js");
/* harmony import */ var gpu_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gpu_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/renderer */ "./src/renderer.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


// interface Physics {}
var DrawingApp = /** @class */ (function (_super) {
    __extends(DrawingApp, _super);
    function DrawingApp() {
        var _this = _super.call(this) || this;
        // private context: WebGL2RenderingContext
        _this.pressed = false;
        _this.focusEventHandler = function () {
            requestAnimationFrame(_this.redraw);
        };
        _this.resizeEventHandler = function () {
            _this.redraw.change.setOutput([window.innerWidth, window.innerHeight]);
            _this.canvas.width = window.innerWidth;
            _this.canvas.height = window.innerHeight;
        };
        _this.releaseEventHandler = function () {
            _this.pressed = false;
        };
        _this.cancelEventHandler = function () {
            _this.pressed = false;
        };
        _this.pressEventHandler = function (e) {
            var mouseX = e.changedTouches
                ? e.changedTouches[0].pageX
                : e.pageX;
            var mouseY = e.changedTouches
                ? e.changedTouches[0].pageY
                : e.pageY;
            mouseX -= _this.canvas.offsetLeft;
            mouseY -= _this.canvas.offsetTop;
            _this.pressed = true;
            _this.clickX = mouseX;
            _this.clickY = mouseY;
            _this.setVar('mouseX', mouseX);
            _this.setVar('mouseY', mouseY);
            e.preventDefault();
        };
        _this.dragEventHandler = function (e) {
            var mouseX = e.changedTouches
                ? e.changedTouches[0].pageX
                : e.pageX;
            var mouseY = e.changedTouches
                ? e.changedTouches[0].pageY
                : e.pageY;
            mouseX -= _this.canvas.offsetLeft;
            mouseY -= _this.canvas.offsetTop;
            if (_this.pressed) {
                _this.clickX = mouseX;
                _this.clickY = mouseY;
                _this.setVar('mouseX', mouseX);
                _this.setVar('mouseY', mouseY);
            }
            // game.redraw()
            e.preventDefault();
        };
        var body = document.getElementsByTagName('body')[0];
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('webgl2');
        var gpu = new gpu_js__WEBPACK_IMPORTED_MODULE_0__.GPU({ canvas: canvas, context: context });
        body.style.margin = '0px';
        body.style.overflow = 'hidden';
        body.appendChild(canvas);
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        _this.canvas = canvas;
        // this.context = context
        _this.gpu = gpu;
        _this.createUserEvents();
        _this.createRenderer(gpu, canvas);
        return _this;
    }
    DrawingApp.prototype.createUserEvents = function () {
        var _this = this;
        var canvas = this.canvas;
        document.addEventListener('pointe', this.focusEventHandler);
        document.addEventListener('pointerout', function () { return (_this.isDrawing = false); });
        canvas.addEventListener('mousedown', this.pressEventHandler);
        canvas.addEventListener('mousemove', this.dragEventHandler);
        canvas.addEventListener('mouseup', this.releaseEventHandler);
        canvas.addEventListener('mouseout', this.cancelEventHandler);
        canvas.addEventListener('touchstart', this.pressEventHandler);
        canvas.addEventListener('touchmove', this.dragEventHandler);
        canvas.addEventListener('touchend', this.releaseEventHandler);
        canvas.addEventListener('touchcancel', this.cancelEventHandler);
        window.addEventListener('resize', this.resizeEventHandler);
    };
    return DrawingApp;
}(_renderer__WEBPACK_IMPORTED_MODULE_1__.Renderer));
var game = new DrawingApp();
(function loop() {
    game.redraw();
    requestAnimationFrame(loop);
})();

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFD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QzdCLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDJEQUEyRCxrQ0FBa0M7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTs7QUFFUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7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UztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1YsNERBQTRELFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsVUFBVSxFQUFFLFVBQVUsRUFBRSxRQUFRO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLGdEQUFnRDtBQUNuRCxRQUFRLFFBQVE7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMERBQTBELE1BQU07QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qyw2QkFBNkI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDBEQUEwRDtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUMvRDs7QUFFQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQSx1Q0FBdUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLHVEQUF1RCx3QkFBd0IsR0FBRyx3QkFBd0I7QUFDcEw7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxzQkFBc0I7QUFDOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FB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QUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFLElBQUk7QUFDN0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxvRUFBb0U7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKLFFBQVEsUUFBUTtBQUNoQixRQUFRLG9CQUFvQjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEMsUUFBUTtBQUNSLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0EsTUFBTTtBQUNOLDBCQUEwQixLQUFLO0FBQy9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsK0NBQStDO0FBQ2xELFFBQVEsMkJBQTJCO0FBQ25DLFFBQVEseUJBQXlCO0FBQ2pDLFFBQVEsMkJBQTJCOztBQUVuQyxRQUFRLDZCQUE2QjtBQUNyQyxRQUFRLG9DQUFvQzs7QUFFNUMsUUFBUSxrQ0FBa0M7QUFDMUMsUUFBUSx5Q0FBeUM7O0FBRWpELFFBQVEsNkJBQTZCO0FBQ3JDLFFBQVEsb0NBQW9DOztBQUU1QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLHNDQUFzQzs7QUFFOUMsUUFBUSxpQ0FBaUM7QUFDekMsUUFBUSx3Q0FBd0M7O0FBRWhELFFBQVEsZ0RBQWdEO0FBQ3hELFFBQVEsdURBQXVEOztBQUUvRCxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLHdDQUF3Qzs7QUFFaEQsUUFBUSwrQkFBK0I7QUFDdkMsUUFBUSxzQ0FBc0M7O0FBRTlDLFFBQVEsa0NBQWtDO0FBQzFDLFFBQVEseUNBQXlDOztBQUVqRCxRQUFRLGtDQUFrQztBQUMxQyxRQUFRLHlDQUF5Qzs7QUFFakQsUUFBUSxrQ0FBa0M7QUFDMUMsUUFBUSx5Q0FBeUM7O0FBRWpELFFBQVEsMEJBQTBCO0FBQ2xDLFFBQVEsMEJBQTBCO0FBQ2xDLFFBQVEsMEJBQTBCOztBQUVsQyxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLHdDQUF3Qzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHlEQUF5RCxNQUFNO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSwwbUNBQTBtQztBQUM3bUMsUUFBUSx5QkFBeUI7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxzQ0FBc0M7QUFDekMsUUFBUSx5QkFBeUI7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxzQ0FBc0M7QUFDekMsUUFBUSx5QkFBeUI7O0FBRWpDOztBQUVBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxpQkFBaUI7QUFDekU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RTVELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDO1FBQzdELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDO1FBQzNELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixDQUFDO1FBQzdELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixDQUFDO1FBRS9ELE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixDQUFDO0lBQzVELENBQUM7SUF5REgsaUJBQUM7QUFBRCxDQUFDLENBekd3QiwrQ0FBUSxHQXlHaEM7QUFFRCxJQUFNLElBQUksR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUM1QjtBQUFBLENBQUMsU0FBUyxJQUFJO0lBQ2IsSUFBSSxDQUFDLE1BQU0sRUFBRTtJQUNiLHFCQUFxQixDQUFDLElBQUksQ0FBQztBQUM3QixDQUFDLENBQUMsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtdGgvLi9ub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvZ3B1LWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vc210aC8uL3NyYy9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly9zbXRoL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3NtdGgvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vc210aC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vc210aC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3NtdGgvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9zbXRoLy4vc3JjL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZ3B1LmpzXG4gKiBodHRwOi8vZ3B1LnJvY2tzL1xuICpcbiAqIEdQVSBBY2NlbGVyYXRlZCBKYXZhU2NyaXB0XG4gKlxuICogQHZlcnNpb24gMi4xNS4yXG4gKiBAZGF0ZSBNb24gTWFyIDI4IDIwMjIgMTA6NTE6MDYgR01ULTA0MDAgKEVhc3Rlcm4gRGF5bGlnaHQgVGltZSlcbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqIFRoZSBNSVQgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMiBncHUuanMgVGVhbVxuICovKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuR1BVID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuYWNvcm4gPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgdmFyIHJlc2VydmVkV29yZHMgPSB7XG4gICAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gICAgNTogXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiLFxuICAgIDY6IFwiZW51bVwiLFxuICAgIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gICAgc3RyaWN0QmluZDogXCJldmFsIGFyZ3VtZW50c1wiXG4gIH07XG5cblxuICB2YXIgZWNtYTVBbmRMZXNzS2V5d29yZHMgPSBcImJyZWFrIGNhc2UgY2F0Y2ggY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHZhciB3aGlsZSB3aXRoIG51bGwgdHJ1ZSBmYWxzZSBpbnN0YW5jZW9mIHR5cGVvZiB2b2lkIGRlbGV0ZSBuZXcgaW4gdGhpc1wiO1xuXG4gIHZhciBrZXl3b3JkcyA9IHtcbiAgICA1OiBlY21hNUFuZExlc3NLZXl3b3JkcyxcbiAgICBcIjVtb2R1bGVcIjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBleHBvcnQgaW1wb3J0XCIsXG4gICAgNjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBjb25zdCBjbGFzcyBleHRlbmRzIGV4cG9ydCBpbXBvcnQgc3VwZXJcIlxuICB9O1xuXG4gIHZhciBrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yID0gL15pbihzdGFuY2VvZik/JC87XG5cblxuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1ZDAtXFx1MDVlYVxcdTA1ZWYtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NmFcXHUwOGEwLVxcdTA4YjRcXHUwOGI2LVxcdTA4YzdcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTA5ZmNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYWY5XFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzVhXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNC1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDU0LVxcdTBkNTZcXHUwZDVmLVxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg2LVxcdTBlOGFcXHUwZThjLVxcdTBlYTNcXHUwZWE1XFx1MGVhNy1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjVcXHUxM2Y4LVxcdTEzZmRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjhcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3OFxcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWVcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWIwLVxcdTE5YzlcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxYzgwLVxcdTFjODhcXHUxYzkwLVxcdTFjYmFcXHUxY2JkLVxcdTFjYmZcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjNcXHUxY2Y1XFx1MWNmNlxcdTFjZmFcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDliLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmZcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmZcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYmZcXHU0ZTAwLVxcdTlmZmNcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5ZFxcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTdiZlxcdWE3YzItXFx1YTdjYVxcdWE3ZjUtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOGZkXFx1YThmZVxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhOWUwLVxcdWE5ZTRcXHVhOWU2LVxcdWE5ZWZcXHVhOWZhLVxcdWE5ZmVcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE3ZS1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYjMwLVxcdWFiNWFcXHVhYjVjLVxcdWFiNjlcXHVhYjcwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUyMDBjXFx1MjAwZFxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDhkMy1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzZS1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODEtXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMC1cXHUwZDAzXFx1MGQzYlxcdTBkM2NcXHUwZDNlLVxcdTBkNDRcXHUwZDQ2LVxcdTBkNDhcXHUwZDRhLVxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgxLVxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZTYtXFx1MGRlZlxcdTBkZjJcXHUwZGYzXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlNTAtXFx1MGU1OVxcdTBlYjFcXHUwZWI0LVxcdTBlYmNcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmM2VcXHUwZjNmXFx1MGY3MS1cXHUwZjg0XFx1MGY4NlxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAyYi1cXHUxMDNlXFx1MTA0MC1cXHUxMDQ5XFx1MTA1Ni1cXHUxMDU5XFx1MTA1ZS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTM2OS1cXHUxMzcxXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3YjQtXFx1MTdkM1xcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOGE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk0Ni1cXHUxOTRmXFx1MTlkMC1cXHUxOWRhXFx1MWExNy1cXHUxYTFiXFx1MWE1NS1cXHUxYTVlXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWFiMC1cXHUxYWJkXFx1MWFiZlxcdTFhYzBcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmOVxcdTFkZmItXFx1MWRmZlxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZDdmXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xuXG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuICBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBudWxsO1xuXG5cbiAgdmFyIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsMTEsMiwyNSwyLDE4LDIsMSwyLDE0LDMsMTMsMzUsMTIyLDcwLDUyLDI2OCwyOCw0LDQ4LDQ4LDMxLDE0LDI5LDYsMzcsMTEsMjksMywzNSw1LDcsMiw0LDQzLDE1NywxOSwzNSw1LDM1LDUsMzksOSw1MSwxNTcsMzEwLDEwLDIxLDExLDcsMTUzLDUsMywwLDIsNDMsMiwxLDQsMCwzLDIyLDExLDIyLDEwLDMwLDY2LDE4LDIsMSwxMSwyMSwxMSwyNSw3MSw1NSw3LDEsNjUsMCwxNiwzLDIsMiwyLDI4LDQzLDI4LDQsMjgsMzYsNywyLDI3LDI4LDUzLDExLDIxLDExLDE4LDE0LDE3LDExMSw3Miw1Niw1MCwxNCw1MCwxNCwzNSwzNDksNDEsNywxLDc5LDI4LDExLDAsOSwyMSwxMDcsMjAsMjgsMjIsMTMsNTIsNzYsNDQsMzMsMjQsMjcsMzUsMzAsMCwzLDAsOSwzNCw0LDAsMTMsNDcsMTUsMywyMiwwLDIsMCwzNiwxNywyLDI0LDg1LDYsMiwwLDIsMywyLDE0LDIsOSw4LDQ2LDM5LDcsMywxLDMsMjEsMiw2LDIsMSwyLDQsNCwwLDE5LDAsMTMsNCwxNTksNTIsMTksMywyMSwyLDMxLDQ3LDIxLDEsMiwwLDE4NSw0Niw0MiwzLDM3LDQ3LDIxLDAsNjAsNDIsMTQsMCw3MiwyNiwyMzAsNDMsMTE3LDYzLDMyLDcsMywwLDMsNywyLDEsMiwyMywxNiwwLDIsMCw5NSw3LDMsMzgsMTcsMCwyLDAsMjksMCwxMSwzOSw4LDAsMjIsMCwxMiw0NSwyMCwwLDM1LDU2LDI2NCw4LDIsMzYsMTgsMCw1MCwyOSwxMTMsNiwyLDEsMiwzNywyMiwwLDI2LDUsMiwxLDIsMzEsMTUsMCwzMjgsMTgsMTkwLDAsODAsOTIxLDEwMywxMTAsMTgsMTk1LDI3NDksMTA3MCw0MDUwLDU4Miw4NjM0LDU2OCw4LDMwLDExNCwyOSwxOSw0NywxNywzLDMyLDIwLDYsMTgsNjg5LDYzLDEyOSw3NCw2LDAsNjcsMTIsNjUsMSwyLDAsMjksNjEzNSw5LDEyMzcsNDMsOCw4OTUyLDI4Niw1MCwyLDE4LDMsOSwzOTUsMjMwOSwxMDYsNiwxMiw0LDgsOCw5LDU5OTEsODQsMiw3MCwyLDEsMywwLDMsMSwzLDMsMiwxMSwyLDAsMiw2LDIsNjQsMiwzLDMsNywyLDYsMiwyNywyLDMsMiw0LDIsMCw0LDYsMiwzMzksMywyNCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDcsMjM1Nyw0NCwxMSw2LDE3LDAsMzcwLDQzLDEzMDEsMTk2LDYwLDY3LDgsMCwxMjA1LDMsMiwyNiwyLDEsMiwwLDMsMCwyLDksMiwzLDIsMCwyLDAsNywwLDUsMCwyLDAsMiwwLDIsMiwyLDEsMiwwLDMsMCwyLDAsMiwwLDIsMCwyLDAsMiwxLDIsMCwzLDMsMiw2LDIsMywyLDMsMiwwLDIsOSwyLDE2LDYsMiwyLDQsMiwxNiw0NDIxLDQyNzE3LDM1LDQxNDgsMTIsMjIxLDMsNTc2MSwxNSw3NDcyLDMxMDQsNTQxLDE1MDcsNDkzOF07XG5cbiAgdmFyIGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksMCwyMjcsMCwxNTAsNCwyOTQsOSwxMzY4LDIsMiwxLDYsMyw0MSwyLDUsMCwxNjYsMSw1NzQsMyw5LDksMzcwLDEsMTU0LDEwLDE3NiwyLDU0LDE0LDMyLDksMTYsMyw0NiwxMCw1NCw5LDcsMiwzNywxMywyLDksNiwxLDQ1LDAsMTMsMiw0OSwxMyw5LDMsMiwxMSw4MywxMSw3LDAsMTYxLDExLDYsOSw3LDMsNTYsMSwyLDYsMywxLDMsMiwxMCwwLDExLDEsMyw2LDQsNCwxOTMsMTcsMTAsOSw1LDAsODIsMTksMTMsOSwyMTQsNiwzLDgsMjgsMSw4MywxNiwxNiw5LDgyLDEyLDksOSw4NCwxNCw1LDksMjQzLDE0LDE2Niw5LDcxLDUsMiwxLDMsMywyLDAsMiwxLDEzLDksMTIwLDYsMyw2LDQsMCwyOSw5LDQxLDYsMiwzLDksMCwxMCwxMCw0NywxNSw0MDYsNywyLDcsMTcsOSw1NywyMSwyLDEzLDEyMyw1LDQsMCwyLDEsMiw2LDIsMCw5LDksNDksNCwyLDEsMiw0LDksOSwzMzAsMywxOTMwNiw5LDEzNSw0LDYwLDYsMjYsOSwxMDE0LDAsMiw1NCw4LDMsODIsMCwxMiwxLDE5NjI4LDEsNTMxOSw0LDQsNSw5LDcsMyw2LDMxLDMsMTQ5LDIsMTQxOCw0OSw1MTMsNTQsNSw0OSw5LDAsMTUsMCwyMyw0LDIsMTQsMTM2MSw2LDIsMTYsMyw2LDIsMSwyLDQsMjYyLDYsMTAsOSw0MTksMTMsMTQ5NSw2LDExMCw2LDYsOSw0NzU5LDksNzg3NzE5LDIzOV07XG5cbiAgZnVuY3Rpb24gaXNJbkFzdHJhbFNldChjb2RlLCBzZXQpIHtcbiAgICB2YXIgcG9zID0gMHgxMDAwMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgcG9zICs9IHNldFtpXTtcbiAgICAgIGlmIChwb3MgPiBjb2RlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBwb3MgKz0gc2V0W2kgKyAxXTtcbiAgICAgIGlmIChwb3MgPj0gY29kZSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlLCBhc3RyYWwpIHtcbiAgICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBjb2RlID09PSAzNiB9XG4gICAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICAgIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKVxuICB9XG5cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNvZGUsIGFzdHJhbCkge1xuICAgIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgICBpZiAoY29kZSA8IDU4KSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICAgIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gICAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpXG4gIH1cblxuXG5cblxuXG4gIHZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgICBpZiAoIGNvbmYgPT09IHZvaWQgMCApIGNvbmYgPSB7fTtcblxuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gICAgdGhpcy5iZWZvcmVFeHByID0gISFjb25mLmJlZm9yZUV4cHI7XG4gICAgdGhpcy5zdGFydHNFeHByID0gISFjb25mLnN0YXJ0c0V4cHI7XG4gICAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICAgIHRoaXMuaXNBc3NpZ24gPSAhIWNvbmYuaXNBc3NpZ247XG4gICAgdGhpcy5wcmVmaXggPSAhIWNvbmYucHJlZml4O1xuICAgIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICAgIHRoaXMuYmlub3AgPSBjb25mLmJpbm9wIHx8IG51bGw7XG4gICAgdGhpcy51cGRhdGVDb250ZXh0ID0gbnVsbDtcbiAgfTtcblxuICBmdW5jdGlvbiBiaW5vcChuYW1lLCBwcmVjKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlblR5cGUobmFtZSwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiBwcmVjfSlcbiAgfVxuICB2YXIgYmVmb3JlRXhwciA9IHtiZWZvcmVFeHByOiB0cnVlfSwgc3RhcnRzRXhwciA9IHtzdGFydHNFeHByOiB0cnVlfTtcblxuXG4gIHZhciBrZXl3b3JkcyQxID0ge307XG5cbiAgZnVuY3Rpb24ga3cobmFtZSwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgICByZXR1cm4ga2V5d29yZHMkMVtuYW1lXSA9IG5ldyBUb2tlblR5cGUobmFtZSwgb3B0aW9ucylcbiAgfVxuXG4gIHZhciB0eXBlcyA9IHtcbiAgICBudW06IG5ldyBUb2tlblR5cGUoXCJudW1cIiwgc3RhcnRzRXhwciksXG4gICAgcmVnZXhwOiBuZXcgVG9rZW5UeXBlKFwicmVnZXhwXCIsIHN0YXJ0c0V4cHIpLFxuICAgIHN0cmluZzogbmV3IFRva2VuVHlwZShcInN0cmluZ1wiLCBzdGFydHNFeHByKSxcbiAgICBuYW1lOiBuZXcgVG9rZW5UeXBlKFwibmFtZVwiLCBzdGFydHNFeHByKSxcbiAgICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG5cbiAgICBicmFja2V0TDogbmV3IFRva2VuVHlwZShcIltcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBicmFja2V0UjogbmV3IFRva2VuVHlwZShcIl1cIiksXG4gICAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIGJyYWNlUjogbmV3IFRva2VuVHlwZShcIn1cIiksXG4gICAgcGFyZW5MOiBuZXcgVG9rZW5UeXBlKFwiKFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIHBhcmVuUjogbmV3IFRva2VuVHlwZShcIilcIiksXG4gICAgY29tbWE6IG5ldyBUb2tlblR5cGUoXCIsXCIsIGJlZm9yZUV4cHIpLFxuICAgIHNlbWk6IG5ldyBUb2tlblR5cGUoXCI7XCIsIGJlZm9yZUV4cHIpLFxuICAgIGNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOlwiLCBiZWZvcmVFeHByKSxcbiAgICBkb3Q6IG5ldyBUb2tlblR5cGUoXCIuXCIpLFxuICAgIHF1ZXN0aW9uOiBuZXcgVG9rZW5UeXBlKFwiP1wiLCBiZWZvcmVFeHByKSxcbiAgICBxdWVzdGlvbkRvdDogbmV3IFRva2VuVHlwZShcIj8uXCIpLFxuICAgIGFycm93OiBuZXcgVG9rZW5UeXBlKFwiPT5cIiwgYmVmb3JlRXhwciksXG4gICAgdGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJ0ZW1wbGF0ZVwiKSxcbiAgICBpbnZhbGlkVGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJpbnZhbGlkVGVtcGxhdGVcIiksXG4gICAgZWxsaXBzaXM6IG5ldyBUb2tlblR5cGUoXCIuLi5cIiwgYmVmb3JlRXhwciksXG4gICAgYmFja1F1b3RlOiBuZXcgVG9rZW5UeXBlKFwiYFwiLCBzdGFydHNFeHByKSxcbiAgICBkb2xsYXJCcmFjZUw6IG5ldyBUb2tlblR5cGUoXCIke1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuXG5cbiAgICBlcTogbmV3IFRva2VuVHlwZShcIj1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gICAgYXNzaWduOiBuZXcgVG9rZW5UeXBlKFwiXz1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gICAgaW5jRGVjOiBuZXcgVG9rZW5UeXBlKFwiKysvLS1cIiwge3ByZWZpeDogdHJ1ZSwgcG9zdGZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIHByZWZpeDogbmV3IFRva2VuVHlwZShcIiEvflwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgbG9naWNhbE9SOiBiaW5vcChcInx8XCIsIDEpLFxuICAgIGxvZ2ljYWxBTkQ6IGJpbm9wKFwiJiZcIiwgMiksXG4gICAgYml0d2lzZU9SOiBiaW5vcChcInxcIiwgMyksXG4gICAgYml0d2lzZVhPUjogYmlub3AoXCJeXCIsIDQpLFxuICAgIGJpdHdpc2VBTkQ6IGJpbm9wKFwiJlwiLCA1KSxcbiAgICBlcXVhbGl0eTogYmlub3AoXCI9PS8hPS89PT0vIT09XCIsIDYpLFxuICAgIHJlbGF0aW9uYWw6IGJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICAgIGJpdFNoaWZ0OiBiaW5vcChcIjw8Lz4+Lz4+PlwiLCA4KSxcbiAgICBwbHVzTWluOiBuZXcgVG9rZW5UeXBlKFwiKy8tXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogOSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgbW9kdWxvOiBiaW5vcChcIiVcIiwgMTApLFxuICAgIHN0YXI6IGJpbm9wKFwiKlwiLCAxMCksXG4gICAgc2xhc2g6IGJpbm9wKFwiL1wiLCAxMCksXG4gICAgc3RhcnN0YXI6IG5ldyBUb2tlblR5cGUoXCIqKlwiLCB7YmVmb3JlRXhwcjogdHJ1ZX0pLFxuICAgIGNvYWxlc2NlOiBiaW5vcChcIj8/XCIsIDEpLFxuXG4gICAgX2JyZWFrOiBrdyhcImJyZWFrXCIpLFxuICAgIF9jYXNlOiBrdyhcImNhc2VcIiwgYmVmb3JlRXhwciksXG4gICAgX2NhdGNoOiBrdyhcImNhdGNoXCIpLFxuICAgIF9jb250aW51ZToga3coXCJjb250aW51ZVwiKSxcbiAgICBfZGVidWdnZXI6IGt3KFwiZGVidWdnZXJcIiksXG4gICAgX2RlZmF1bHQ6IGt3KFwiZGVmYXVsdFwiLCBiZWZvcmVFeHByKSxcbiAgICBfZG86IGt3KFwiZG9cIiwge2lzTG9vcDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0pLFxuICAgIF9lbHNlOiBrdyhcImVsc2VcIiwgYmVmb3JlRXhwciksXG4gICAgX2ZpbmFsbHk6IGt3KFwiZmluYWxseVwiKSxcbiAgICBfZm9yOiBrdyhcImZvclwiLCB7aXNMb29wOiB0cnVlfSksXG4gICAgX2Z1bmN0aW9uOiBrdyhcImZ1bmN0aW9uXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9pZjoga3coXCJpZlwiKSxcbiAgICBfcmV0dXJuOiBrdyhcInJldHVyblwiLCBiZWZvcmVFeHByKSxcbiAgICBfc3dpdGNoOiBrdyhcInN3aXRjaFwiKSxcbiAgICBfdGhyb3c6IGt3KFwidGhyb3dcIiwgYmVmb3JlRXhwciksXG4gICAgX3RyeToga3coXCJ0cnlcIiksXG4gICAgX3Zhcjoga3coXCJ2YXJcIiksXG4gICAgX2NvbnN0OiBrdyhcImNvbnN0XCIpLFxuICAgIF93aGlsZToga3coXCJ3aGlsZVwiLCB7aXNMb29wOiB0cnVlfSksXG4gICAgX3dpdGg6IGt3KFwid2l0aFwiKSxcbiAgICBfbmV3OiBrdyhcIm5ld1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIF90aGlzOiBrdyhcInRoaXNcIiwgc3RhcnRzRXhwciksXG4gICAgX3N1cGVyOiBrdyhcInN1cGVyXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9jbGFzczoga3coXCJjbGFzc1wiLCBzdGFydHNFeHByKSxcbiAgICBfZXh0ZW5kczoga3coXCJleHRlbmRzXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9leHBvcnQ6IGt3KFwiZXhwb3J0XCIpLFxuICAgIF9pbXBvcnQ6IGt3KFwiaW1wb3J0XCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9udWxsOiBrdyhcIm51bGxcIiwgc3RhcnRzRXhwciksXG4gICAgX3RydWU6IGt3KFwidHJ1ZVwiLCBzdGFydHNFeHByKSxcbiAgICBfZmFsc2U6IGt3KFwiZmFsc2VcIiwgc3RhcnRzRXhwciksXG4gICAgX2luOiBrdyhcImluXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICAgIF9pbnN0YW5jZW9mOiBrdyhcImluc3RhbmNlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gICAgX3R5cGVvZjoga3coXCJ0eXBlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIF92b2lkOiBrdyhcInZvaWRcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIF9kZWxldGU6IGt3KFwiZGVsZXRlXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KVxuICB9O1xuXG5cbiAgdmFyIGxpbmVCcmVhayA9IC9cXHJcXG4/fFxcbnxcXHUyMDI4fFxcdTIwMjkvO1xuICB2YXIgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuXG4gIGZ1bmN0aW9uIGlzTmV3TGluZShjb2RlLCBlY21hMjAxOVN0cmluZykge1xuICAgIHJldHVybiBjb2RlID09PSAxMCB8fCBjb2RlID09PSAxMyB8fCAoIWVjbWEyMDE5U3RyaW5nICYmIChjb2RlID09PSAweDIwMjggfHwgY29kZSA9PT0gMHgyMDI5KSlcbiAgfVxuXG4gIHZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG5cbiAgdmFyIHNraXBXaGl0ZVNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKnxcXC9cXCpbXl0qP1xcKlxcLykqL2c7XG5cbiAgdmFyIHJlZiA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IHJlZi5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHRvU3RyaW5nID0gcmVmLnRvU3RyaW5nO1xuXG5cbiAgZnVuY3Rpb24gaGFzKG9iaiwgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BOYW1lKVxuICB9XG5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gICAgdG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCJcbiAgKTsgfSk7XG5cbiAgZnVuY3Rpb24gd29yZHNSZWdleHAod29yZHMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHdvcmRzLnJlcGxhY2UoLyAvZywgXCJ8XCIpICsgXCIpJFwiKVxuICB9XG5cblxuICB2YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2wpIHtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sO1xuICB9O1xuXG4gIFBvc2l0aW9uLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQgKG4pIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKVxuICB9O1xuXG4gIHZhciBTb3VyY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKHAsIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgaWYgKHAuc291cmNlRmlsZSAhPT0gbnVsbCkgeyB0aGlzLnNvdXJjZSA9IHAuc291cmNlRmlsZTsgfVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gZ2V0TGluZUluZm8oaW5wdXQsIG9mZnNldCkge1xuICAgIGZvciAodmFyIGxpbmUgPSAxLCBjdXIgPSAwOzspIHtcbiAgICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gY3VyO1xuICAgICAgdmFyIG1hdGNoID0gbGluZUJyZWFrRy5leGVjKGlucHV0KTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA8IG9mZnNldCkge1xuICAgICAgICArK2xpbmU7XG4gICAgICAgIGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lLCBvZmZzZXQgLSBjdXIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgZWNtYVZlcnNpb246IDEwLFxuICAgIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gICAgb25JbnNlcnRlZFNlbWljb2xvbjogbnVsbCxcbiAgICBvblRyYWlsaW5nQ29tbWE6IG51bGwsXG4gICAgYWxsb3dSZXNlcnZlZDogbnVsbCxcbiAgICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgICBhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICBhbGxvd0hhc2hCYW5nOiBmYWxzZSxcbiAgICBsb2NhdGlvbnM6IGZhbHNlLFxuICAgIG9uVG9rZW46IG51bGwsXG4gICAgb25Db21tZW50OiBudWxsLFxuICAgIHJhbmdlczogZmFsc2UsXG4gICAgcHJvZ3JhbTogbnVsbCxcbiAgICBzb3VyY2VGaWxlOiBudWxsLFxuICAgIGRpcmVjdFNvdXJjZUZpbGU6IG51bGwsXG4gICAgcHJlc2VydmVQYXJlbnM6IGZhbHNlXG4gIH07XG5cblxuICBmdW5jdGlvbiBnZXRPcHRpb25zKG9wdHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKVxuICAgICAgeyBvcHRpb25zW29wdF0gPSBvcHRzICYmIGhhcyhvcHRzLCBvcHQpID8gb3B0c1tvcHRdIDogZGVmYXVsdE9wdGlvbnNbb3B0XTsgfVxuXG4gICAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMjAxNSlcbiAgICAgIHsgb3B0aW9ucy5lY21hVmVyc2lvbiAtPSAyMDA5OyB9XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09IG51bGwpXG4gICAgICB7IG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9IG9wdGlvbnMuZWNtYVZlcnNpb24gPCA1OyB9XG5cbiAgICBpZiAoaXNBcnJheShvcHRpb25zLm9uVG9rZW4pKSB7XG4gICAgICB2YXIgdG9rZW5zID0gb3B0aW9ucy5vblRva2VuO1xuICAgICAgb3B0aW9ucy5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbnMucHVzaCh0b2tlbik7IH07XG4gICAgfVxuICAgIGlmIChpc0FycmF5KG9wdGlvbnMub25Db21tZW50KSlcbiAgICAgIHsgb3B0aW9ucy5vbkNvbW1lbnQgPSBwdXNoQ29tbWVudChvcHRpb25zLCBvcHRpb25zLm9uQ29tbWVudCk7IH1cblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBmdW5jdGlvbiBwdXNoQ29tbWVudChvcHRpb25zLCBhcnJheSkge1xuICAgIHJldHVybiBmdW5jdGlvbihibG9jaywgdGV4dCwgc3RhcnQsIGVuZCwgc3RhcnRMb2MsIGVuZExvYykge1xuICAgICAgdmFyIGNvbW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IGJsb2NrID8gXCJCbG9ja1wiIDogXCJMaW5lXCIsXG4gICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kXG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgICB7IGNvbW1lbnQubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHN0YXJ0TG9jLCBlbmRMb2MpOyB9XG4gICAgICBpZiAob3B0aW9ucy5yYW5nZXMpXG4gICAgICAgIHsgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTsgfVxuICAgICAgYXJyYXkucHVzaChjb21tZW50KTtcbiAgICB9XG4gIH1cblxuICB2YXJcbiAgICAgIFNDT1BFX1RPUCA9IDEsXG4gICAgICBTQ09QRV9GVU5DVElPTiA9IDIsXG4gICAgICBTQ09QRV9WQVIgPSBTQ09QRV9UT1AgfCBTQ09QRV9GVU5DVElPTixcbiAgICAgIFNDT1BFX0FTWU5DID0gNCxcbiAgICAgIFNDT1BFX0dFTkVSQVRPUiA9IDgsXG4gICAgICBTQ09QRV9BUlJPVyA9IDE2LFxuICAgICAgU0NPUEVfU0lNUExFX0NBVENIID0gMzIsXG4gICAgICBTQ09QRV9TVVBFUiA9IDY0LFxuICAgICAgU0NPUEVfRElSRUNUX1NVUEVSID0gMTI4O1xuXG4gIGZ1bmN0aW9uIGZ1bmN0aW9uRmxhZ3MoYXN5bmMsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBTQ09QRV9GVU5DVElPTiB8IChhc3luYyA/IFNDT1BFX0FTWU5DIDogMCkgfCAoZ2VuZXJhdG9yID8gU0NPUEVfR0VORVJBVE9SIDogMClcbiAgfVxuXG4gIHZhclxuICAgICAgQklORF9OT05FID0gMCwgXG4gICAgICBCSU5EX1ZBUiA9IDEsIFxuICAgICAgQklORF9MRVhJQ0FMID0gMiwgXG4gICAgICBCSU5EX0ZVTkNUSU9OID0gMywgXG4gICAgICBCSU5EX1NJTVBMRV9DQVRDSCA9IDQsIFxuICAgICAgQklORF9PVVRTSURFID0gNTsgXG5cbiAgdmFyIFBhcnNlciA9IGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zLCBpbnB1dCwgc3RhcnRQb3MpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGU7XG4gICAgdGhpcy5rZXl3b3JkcyA9IHdvcmRzUmVnZXhwKGtleXdvcmRzW29wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IDYgOiBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIgPyBcIjVtb2R1bGVcIiA6IDVdKTtcbiAgICB2YXIgcmVzZXJ2ZWQgPSBcIlwiO1xuICAgIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IHRydWUpIHtcbiAgICAgIGZvciAodmFyIHYgPSBvcHRpb25zLmVjbWFWZXJzaW9uOzsgdi0tKVxuICAgICAgICB7IGlmIChyZXNlcnZlZCA9IHJlc2VydmVkV29yZHNbdl0pIHsgYnJlYWsgfSB9XG4gICAgICBpZiAob3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiKSB7IHJlc2VydmVkICs9IFwiIGF3YWl0XCI7IH1cbiAgICB9XG4gICAgdGhpcy5yZXNlcnZlZFdvcmRzID0gd29yZHNSZWdleHAocmVzZXJ2ZWQpO1xuICAgIHZhciByZXNlcnZlZFN0cmljdCA9IChyZXNlcnZlZCA/IHJlc2VydmVkICsgXCIgXCIgOiBcIlwiKSArIHJlc2VydmVkV29yZHMuc3RyaWN0O1xuICAgIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0KTtcbiAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kID0gd29yZHNSZWdleHAocmVzZXJ2ZWRTdHJpY3QgKyBcIiBcIiArIHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG4gICAgdGhpcy5pbnB1dCA9IFN0cmluZyhpbnB1dCk7XG5cbiAgICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG5cblxuICAgIGlmIChzdGFydFBvcykge1xuICAgICAgdGhpcy5wb3MgPSBzdGFydFBvcztcbiAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCBzdGFydFBvcyAtIDEpICsgMTtcbiAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaW5wdXQuc2xpY2UoMCwgdGhpcy5saW5lU3RhcnQpLnNwbGl0KGxpbmVCcmVhaykubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvcyA9IHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICAgIHRoaXMuY3VyTGluZSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gdHlwZXMuZW9mO1xuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIHRoaXMuc3RhcnQgPSB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAgIHRoaXMuc3RhcnRMb2MgPSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcblxuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMubGFzdFRva0VuZCA9IHRoaXMucG9zO1xuXG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5pbml0aWFsQ29udGV4dCgpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5pbk1vZHVsZSA9IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIjtcbiAgICB0aGlzLnN0cmljdCA9IHRoaXMuaW5Nb2R1bGUgfHwgdGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5wb3MpO1xuXG4gICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gLTE7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gdGhpcy5hd2FpdFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMgPSB7fTtcblxuICAgIGlmICh0aGlzLnBvcyA9PT0gMCAmJiBvcHRpb25zLmFsbG93SGFzaEJhbmcgJiYgdGhpcy5pbnB1dC5zbGljZSgwLCAyKSA9PT0gXCIjIVwiKVxuICAgICAgeyB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTsgfVxuXG4gICAgdGhpcy5zY29wZVN0YWNrID0gW107XG4gICAgdGhpcy5lbnRlclNjb3BlKFNDT1BFX1RPUCk7XG5cbiAgICB0aGlzLnJlZ2V4cFN0YXRlID0gbnVsbDtcbiAgfTtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBpbkZ1bmN0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluR2VuZXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluQXN5bmM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxhbGxvd0RpcmVjdFN1cGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHRyZWF0RnVuY3Rpb25zQXNWYXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5vcHRpb25zLnByb2dyYW0gfHwgdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlVG9wTGV2ZWwobm9kZSlcbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMuaW5GdW5jdGlvbi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSA+IDAgfTtcbiAgcHJvdG90eXBlQWNjZXNzb3JzLmluR2VuZXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfR0VORVJBVE9SKSA+IDAgfTtcbiAgcHJvdG90eXBlQWNjZXNzb3JzLmluQXN5bmMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9BU1lOQykgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd1N1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX1NVUEVSKSA+IDAgfTtcbiAgcHJvdG90eXBlQWNjZXNzb3JzLmFsbG93RGlyZWN0U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRElSRUNUX1NVUEVSKSA+IDAgfTtcbiAgcHJvdG90eXBlQWNjZXNzb3JzLnRyZWF0RnVuY3Rpb25zQXNWYXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSh0aGlzLmN1cnJlbnRTY29wZSgpKSB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuaW5Ob25BcnJvd0Z1bmN0aW9uID0gZnVuY3Rpb24gaW5Ob25BcnJvd0Z1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSA+IDAgfTtcblxuICBQYXJzZXIuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kICgpIHtcbiAgICAgIHZhciBwbHVnaW5zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgcGx1Z2luc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIGNscyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7IGNscyA9IHBsdWdpbnNbaV0oY2xzKTsgfVxuICAgIHJldHVybiBjbHNcbiAgfTtcblxuICBQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQpLnBhcnNlKClcbiAgfTtcblxuICBQYXJzZXIucGFyc2VFeHByZXNzaW9uQXQgPSBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdCAoaW5wdXQsIHBvcywgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZXIgPSBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCwgcG9zKTtcbiAgICBwYXJzZXIubmV4dFRva2VuKCk7XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUV4cHJlc3Npb24oKVxuICB9O1xuXG4gIFBhcnNlci50b2tlbml6ZXIgPSBmdW5jdGlvbiB0b2tlbml6ZXIgKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0KVxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQYXJzZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuICB2YXIgcHAgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5cbiAgdmFyIGxpdGVyYWwgPSAvXig/OicoKD86XFxcXC58W14nXSkqPyknfFwiKCg/OlxcXFwufFteXCJdKSo/KVwiKS87XG4gIHBwLnN0cmljdERpcmVjdGl2ZSA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgICBzdGFydCArPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpWzBdLmxlbmd0aDtcbiAgICAgIHZhciBtYXRjaCA9IGxpdGVyYWwuZXhlYyh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0KSk7XG4gICAgICBpZiAoIW1hdGNoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBpZiAoKG1hdGNoWzFdIHx8IG1hdGNoWzJdKSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHtcbiAgICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQgKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIHZhciBzcGFjZUFmdGVyID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KSwgZW5kID0gc3BhY2VBZnRlci5pbmRleCArIHNwYWNlQWZ0ZXJbMF0ubGVuZ3RoO1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckF0KGVuZCk7XG4gICAgICAgIHJldHVybiBuZXh0ID09PSBcIjtcIiB8fCBuZXh0ID09PSBcIn1cIiB8fFxuICAgICAgICAgIChsaW5lQnJlYWsudGVzdChzcGFjZUFmdGVyWzBdKSAmJlxuICAgICAgICAgICAhKC9bKGAuWytcXC0vKiU8Pj0sP14mXS8udGVzdChuZXh0KSB8fCBuZXh0ID09PSBcIiFcIiAmJiB0aGlzLmlucHV0LmNoYXJBdChlbmQgKyAxKSA9PT0gXCI9XCIpKVxuICAgICAgfVxuICAgICAgc3RhcnQgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuXG4gICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuaW5wdXRbc3RhcnRdID09PSBcIjtcIilcbiAgICAgICAgeyBzdGFydCsrOyB9XG4gICAgfVxuICB9O1xuXG5cbiAgcHAuZWF0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9O1xuXG5cbiAgcHAuaXNDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiAhdGhpcy5jb250YWluc0VzY1xuICB9O1xuXG5cbiAgcHAuZWF0Q29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKG5hbWUpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuXG4gIHBwLmV4cGVjdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmVhdENvbnRleHR1YWwobmFtZSkpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfTtcblxuXG4gIHBwLmNhbkluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLmVvZiB8fFxuICAgICAgdGhpcy50eXBlID09PSB0eXBlcy5icmFjZVIgfHxcbiAgICAgIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbiAgfTtcblxuICBwcC5pbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKVxuICAgICAgICB7IHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH07XG5cblxuICBwcC5zZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLnNlbWkpICYmICF0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cbiAgcHAuYWZ0ZXJUcmFpbGluZ0NvbW1hID0gZnVuY3Rpb24odG9rVHlwZSwgbm90TmV4dCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHRva1R5cGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKVxuICAgICAgICB7IHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva1N0YXJ0TG9jKTsgfVxuICAgICAgaWYgKCFub3ROZXh0KVxuICAgICAgICB7IHRoaXMubmV4dCgpOyB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfTtcblxuXG4gIHBwLmV4cGVjdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB0aGlzLmVhdCh0eXBlKSB8fCB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfTtcblxuXG4gIHBwLnVuZXhwZWN0ZWQgPSBmdW5jdGlvbihwb3MpIHtcbiAgICB0aGlzLnJhaXNlKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIERlc3RydWN0dXJpbmdFcnJvcnMoKSB7XG4gICAgdGhpcy5zaG9ydGhhbmRBc3NpZ24gPVxuICAgIHRoaXMudHJhaWxpbmdDb21tYSA9XG4gICAgdGhpcy5wYXJlbnRoZXNpemVkQXNzaWduID1cbiAgICB0aGlzLnBhcmVudGhlc2l6ZWRCaW5kID1cbiAgICB0aGlzLmRvdWJsZVByb3RvID1cbiAgICAgIC0xO1xuICB9XG5cbiAgcHAuY2hlY2tQYXR0ZXJuRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgaXNBc3NpZ24pIHtcbiAgICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIH1cbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID4gLTEpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgdmFyIHBhcmVucyA9IGlzQXNzaWduID8gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDogcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZDtcbiAgICBpZiAocGFyZW5zID4gLTEpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBhcmVucywgXCJQYXJlbnRoZXNpemVkIHBhdHRlcm5cIik7IH1cbiAgfTtcblxuICBwcC5jaGVja0V4cHJlc3Npb25FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhbmRUaHJvdykge1xuICAgIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBzaG9ydGhhbmRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbjtcbiAgICB2YXIgZG91YmxlUHJvdG8gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvO1xuICAgIGlmICghYW5kVGhyb3cpIHsgcmV0dXJuIHNob3J0aGFuZEFzc2lnbiA+PSAwIHx8IGRvdWJsZVByb3RvID49IDAgfVxuICAgIGlmIChzaG9ydGhhbmRBc3NpZ24gPj0gMClcbiAgICAgIHsgdGhpcy5yYWlzZShzaG9ydGhhbmRBc3NpZ24sIFwiU2hvcnRoYW5kIHByb3BlcnR5IGFzc2lnbm1lbnRzIGFyZSB2YWxpZCBvbmx5IGluIGRlc3RydWN0dXJpbmcgcGF0dGVybnNcIik7IH1cbiAgICBpZiAoZG91YmxlUHJvdG8gPj0gMClcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGRvdWJsZVByb3RvLCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbiAgfTtcblxuICBwcC5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy55aWVsZFBvcyAmJiAoIXRoaXMuYXdhaXRQb3MgfHwgdGhpcy55aWVsZFBvcyA8IHRoaXMuYXdhaXRQb3MpKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMueWllbGRQb3MsIFwiWWllbGQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gICAgaWYgKHRoaXMuYXdhaXRQb3MpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5hd2FpdFBvcywgXCJBd2FpdCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgfTtcblxuICBwcC5pc1NpbXBsZUFzc2lnblRhcmdldCA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICBpZiAoZXhwci50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgICB7IHJldHVybiB0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIuZXhwcmVzc2lvbikgfVxuICAgIHJldHVybiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8IGV4cHIudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCJcbiAgfTtcblxuICB2YXIgcHAkMSA9IFBhcnNlci5wcm90b3R5cGU7XG5cblxuXG4gIHBwJDEucGFyc2VUb3BMZXZlbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgZXhwb3J0cyA9IHt9O1xuICAgIGlmICghbm9kZS5ib2R5KSB7IG5vZGUuYm9keSA9IFtdOyB9XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMuZW9mKSB7XG4gICAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCwgdHJ1ZSwgZXhwb3J0cyk7XG4gICAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5Nb2R1bGUpXG4gICAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gT2JqZWN0LmtleXModGhpcy51bmRlZmluZWRFeHBvcnRzKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdLnN0YXJ0LCAoXCJFeHBvcnQgJ1wiICsgbmFtZSArIFwiJyBpcyBub3QgZGVmaW5lZFwiKSk7XG4gICAgICAgIH0gfVxuICAgIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJQcm9ncmFtXCIpXG4gIH07XG5cbiAgdmFyIGxvb3BMYWJlbCA9IHtraW5kOiBcImxvb3BcIn0sIHN3aXRjaExhYmVsID0ge2tpbmQ6IFwic3dpdGNoXCJ9O1xuXG4gIHBwJDEuaXNMZXQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwibGV0XCIpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgIGlmIChuZXh0Q2ggPT09IDkxKSB7IHJldHVybiB0cnVlIH0gXG4gICAgaWYgKGNvbnRleHQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmIChuZXh0Q2ggPT09IDEyMykgeyByZXR1cm4gdHJ1ZSB9IFxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0Q2gsIHRydWUpKSB7XG4gICAgICB2YXIgcG9zID0gbmV4dCArIDE7XG4gICAgICB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSkpIHsgKytwb3M7IH1cbiAgICAgIHZhciBpZGVudCA9IHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgcG9zKTtcbiAgICAgIGlmICgha2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvci50ZXN0KGlkZW50KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDEuaXNBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDggfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwiYXN5bmNcIikpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoO1xuICAgIHJldHVybiAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgbmV4dCkpICYmXG4gICAgICB0aGlzLmlucHV0LnNsaWNlKG5leHQsIG5leHQgKyA4KSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAobmV4dCArIDggPT09IHRoaXMuaW5wdXQubGVuZ3RoIHx8ICFpc0lkZW50aWZpZXJDaGFyKHRoaXMuaW5wdXQuY2hhckF0KG5leHQgKyA4KSkpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24oY29udGV4dCwgdG9wTGV2ZWwsIGV4cG9ydHMpIHtcbiAgICB2YXIgc3RhcnR0eXBlID0gdGhpcy50eXBlLCBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwga2luZDtcblxuICAgIGlmICh0aGlzLmlzTGV0KGNvbnRleHQpKSB7XG4gICAgICBzdGFydHR5cGUgPSB0eXBlcy5fdmFyO1xuICAgICAga2luZCA9IFwibGV0XCI7XG4gICAgfVxuXG5cbiAgICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICAgIGNhc2UgdHlwZXMuX2JyZWFrOiBjYXNlIHR5cGVzLl9jb250aW51ZTogcmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHN0YXJ0dHlwZS5rZXl3b3JkKVxuICAgIGNhc2UgdHlwZXMuX2RlYnVnZ2VyOiByZXR1cm4gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fZG86IHJldHVybiB0aGlzLnBhcnNlRG9TdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9mb3I6IHJldHVybiB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgICBpZiAoKGNvbnRleHQgJiYgKHRoaXMuc3RyaWN0IHx8IGNvbnRleHQgIT09IFwiaWZcIiAmJiBjb250ZXh0ICE9PSBcImxhYmVsXCIpKSAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSwgIWNvbnRleHQpXG4gICAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgICBpZiAoY29udGV4dCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyhub2RlLCB0cnVlKVxuICAgIGNhc2UgdHlwZXMuX2lmOiByZXR1cm4gdGhpcy5wYXJzZUlmU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fcmV0dXJuOiByZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX3N3aXRjaDogcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl90aHJvdzogcmV0dXJuIHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX3RyeTogcmV0dXJuIHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9jb25zdDogY2FzZSB0eXBlcy5fdmFyOlxuICAgICAga2luZCA9IGtpbmQgfHwgdGhpcy52YWx1ZTtcbiAgICAgIGlmIChjb250ZXh0ICYmIGtpbmQgIT09IFwidmFyXCIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQpXG4gICAgY2FzZSB0eXBlcy5fd2hpbGU6IHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl93aXRoOiByZXR1cm4gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLmJyYWNlTDogcmV0dXJuIHRoaXMucGFyc2VCbG9jayh0cnVlLCBub2RlKVxuICAgIGNhc2UgdHlwZXMuc2VtaTogcmV0dXJuIHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX2V4cG9ydDpcbiAgICBjYXNlIHR5cGVzLl9pbXBvcnQ6XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID4gMTAgJiYgc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0KSB7XG4gICAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICAgICAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICBpZiAobmV4dENoID09PSA0MCB8fCBuZXh0Q2ggPT09IDQ2KSBcbiAgICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCB0aGlzLnBhcnNlRXhwcmVzc2lvbigpKSB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgICBpZiAoIXRvcExldmVsKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbFwiKTsgfVxuICAgICAgICBpZiAoIXRoaXMuaW5Nb2R1bGUpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBtb2R1bGUnXCIpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0ID8gdGhpcy5wYXJzZUltcG9ydChub2RlKSA6IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgZXhwb3J0cylcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgICBpZiAoY29udGV4dCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dClcbiAgICAgIH1cblxuICAgICAgdmFyIG1heWJlTmFtZSA9IHRoaXMudmFsdWUsIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMubmFtZSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHRoaXMuZWF0KHR5cGVzLmNvbG9uKSlcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQobm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KSB9XG4gICAgICBlbHNlIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIH1cbiAgICB9XG4gIH07XG5cbiAgcHAkMS5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBrZXl3b3JkKSB7XG4gICAgdmFyIGlzQnJlYWsgPSBrZXl3b3JkID09PSBcImJyZWFrXCI7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5sYWJlbCA9IG51bGw7IH1cbiAgICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBlbHNlIHtcbiAgICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsYWIgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gXCJsb29wXCIpKSB7IGJyZWFrIH1cbiAgICAgICAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSB0aGlzLmxhYmVscy5sZW5ndGgpIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIlVuc3ludGFjdGljIFwiICsga2V5d29yZCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZURvU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZG9cIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuX3doaWxlKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgICAgeyB0aGlzLmVhdCh0eXBlcy5zZW1pKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5zZW1pY29sb24oKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHZhciBhd2FpdEF0ID0gKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmICh0aGlzLmluQXN5bmMgfHwgKCF0aGlzLmluRnVuY3Rpb24gJiYgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24pKSAmJiB0aGlzLmVhdENvbnRleHR1YWwoXCJhd2FpdFwiKSkgPyB0aGlzLmxhc3RUb2tTdGFydCA6IC0xO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zZW1pKSB7XG4gICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgbnVsbClcbiAgICB9XG4gICAgdmFyIGlzTGV0ID0gdGhpcy5pc0xldCgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl92YXIgfHwgdGhpcy50eXBlID09PSB0eXBlcy5fY29uc3QgfHwgaXNMZXQpIHtcbiAgICAgIHZhciBpbml0JDEgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kID0gaXNMZXQgPyBcImxldFwiIDogdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5wYXJzZVZhcihpbml0JDEsIHRydWUsIGtpbmQpO1xuICAgICAgdGhpcy5maW5pc2hOb2RlKGluaXQkMSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICAgICAgaWYgKCh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpICYmIGluaXQkMS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbikge1xuICAgICAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0JDEpXG4gICAgICB9XG4gICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCQxKVxuICAgIH1cbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICAgIHZhciBpbml0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbikge1xuICAgICAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICAgIH0gZWxzZSB7IG5vZGUuYXdhaXQgPSBhd2FpdEF0ID4gLTE7IH1cbiAgICAgIH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGluaXQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGluaXQpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0KVxuICB9O1xuXG4gIHBwJDEucGFyc2VGdW5jdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMsIGRlY2xhcmF0aW9uUG9zaXRpb24pIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIEZVTkNfU1RBVEVNRU5UIHwgKGRlY2xhcmF0aW9uUG9zaXRpb24gPyAwIDogRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCksIGZhbHNlLCBpc0FzeW5jKVxuICB9O1xuXG4gIHBwJDEucGFyc2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5lYXQodHlwZXMuX2Vsc2UpID8gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpIDogbnVsbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWZTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghdGhpcy5pbkZ1bmN0aW9uICYmICF0aGlzLm9wdGlvbnMuYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb24pXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpOyB9XG4gICAgdGhpcy5uZXh0KCk7XG5cblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSB8fCB0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IG5vZGUuYXJndW1lbnQgPSBudWxsOyB9XG4gICAgZWxzZSB7IG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpOyB0aGlzLnNlbWljb2xvbigpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5kaXNjcmltaW5hbnQgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgbm9kZS5jYXNlcyA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgdGhpcy5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG4gICAgdGhpcy5lbnRlclNjb3BlKDApO1xuXG5cbiAgICB2YXIgY3VyO1xuICAgIGZvciAodmFyIHNhd0RlZmF1bHQgPSBmYWxzZTsgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZVI7KSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2FzZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLl9kZWZhdWx0KSB7XG4gICAgICAgIHZhciBpc0Nhc2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9jYXNlO1xuICAgICAgICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICAgICAgICBub2RlLmNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICAgIGN1ci5jb25zZXF1ZW50ID0gW107XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgICAgY3VyLnRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzYXdEZWZhdWx0KSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLmxhc3RUb2tTdGFydCwgXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXNcIik7IH1cbiAgICAgICAgICBzYXdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICBjdXIudGVzdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjdXIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgY3VyLmNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICAgIHRoaXMubmV4dCgpOyBcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3dpdGNoU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVRocm93U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmIChsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3dcIik7IH1cbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKVxuICB9O1xuXG5cbiAgdmFyIGVtcHR5ID0gW107XG5cbiAgcHAkMS5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2F0Y2gpIHtcbiAgICAgIHZhciBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMucGFyZW5MKSkge1xuICAgICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICAgICAgdmFyIHNpbXBsZSA9IGNsYXVzZS5wYXJhbS50eXBlID09PSBcIklkZW50aWZpZXJcIjtcbiAgICAgICAgdGhpcy5lbnRlclNjb3BlKHNpbXBsZSA/IFNDT1BFX1NJTVBMRV9DQVRDSCA6IDApO1xuICAgICAgICB0aGlzLmNoZWNrTFZhbChjbGF1c2UucGFyYW0sIHNpbXBsZSA/IEJJTkRfU0lNUExFX0NBVENIIDogQklORF9MRVhJQ0FMKTtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxMCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgICB9XG4gICAgICBjbGF1c2UuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgICB9XG4gICAgbm9kZS5maW5hbGl6ZXIgPSB0aGlzLmVhdCh0eXBlcy5fZmluYWxseSkgPyB0aGlzLnBhcnNlQmxvY2soKSA6IG51bGw7XG4gICAgaWYgKCFub2RlLmhhbmRsZXIgJiYgIW5vZGUuZmluYWxpemVyKVxuICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlVmFyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2luZCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgfTtcblxuICBwcCQxLnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2hpbGVcIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldoaWxlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2l0aFwiKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QgPSB0aGlzLmxhYmVsczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIGxhYmVsID0gbGlzdFtpJDFdO1xuXG4gICAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKVxuICAgICAgICB7IHRoaXMucmFpc2UoZXhwci5zdGFydCwgXCJMYWJlbCAnXCIgKyBtYXliZU5hbWUgKyBcIicgaXMgYWxyZWFkeSBkZWNsYXJlZFwiKTtcbiAgICB9IH1cbiAgICB2YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHlwZXMuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGxhYmVsJDEgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICAgIGlmIChsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID09PSBub2RlLnN0YXJ0KSB7XG4gICAgICAgIGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBsYWJlbCQxLmtpbmQgPSBraW5kO1xuICAgICAgfSBlbHNlIHsgYnJlYWsgfVxuICAgIH1cbiAgICB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXJ0fSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChjb250ZXh0ID8gY29udGV4dC5pbmRleE9mKFwibGFiZWxcIikgPT09IC0xID8gY29udGV4dCArIFwibGFiZWxcIiA6IGNvbnRleHQgOiBcImxhYmVsXCIpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIG5vZGUubGFiZWwgPSBleHByO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBleHByKSB7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZXhwcjtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlQmxvY2sgPSBmdW5jdGlvbihjcmVhdGVOZXdMZXhpY2FsU2NvcGUsIG5vZGUsIGV4aXRTdHJpY3QpIHtcbiAgICBpZiAoIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9PT0gdm9pZCAwICkgY3JlYXRlTmV3TGV4aWNhbFNjb3BlID0gdHJ1ZTtcbiAgICBpZiAoIG5vZGUgPT09IHZvaWQgMCApIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgbm9kZS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZW50ZXJTY29wZSgwKTsgfVxuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlUikge1xuICAgICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpO1xuICAgICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gICAgfVxuICAgIGlmIChleGl0U3RyaWN0KSB7IHRoaXMuc3RyaWN0ID0gZmFsc2U7IH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZXhpdFNjb3BlKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VGb3IgPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gICAgbm9kZS5pbml0ID0gaW5pdDtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgICBub2RlLnVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5SID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZm9yXCIpO1xuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZvclN0YXRlbWVudFwiKVxuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUZvckluID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICAgIHZhciBpc0ZvckluID0gdGhpcy50eXBlID09PSB0eXBlcy5faW47XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAoXG4gICAgICBpbml0LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmXG4gICAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pbml0ICE9IG51bGwgJiZcbiAgICAgIChcbiAgICAgICAgIWlzRm9ySW4gfHxcbiAgICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fFxuICAgICAgICB0aGlzLnN0cmljdCB8fFxuICAgICAgICBpbml0LmtpbmQgIT09IFwidmFyXCIgfHxcbiAgICAgICAgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCJcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRoaXMucmFpc2UoXG4gICAgICAgIGluaXQuc3RhcnQsXG4gICAgICAgICgoaXNGb3JJbiA/IFwiZm9yLWluXCIgOiBcImZvci1vZlwiKSArIFwiIGxvb3AgdmFyaWFibGUgZGVjbGFyYXRpb24gbWF5IG5vdCBoYXZlIGFuIGluaXRpYWxpemVyXCIpXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaW5pdC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoaW5pdC5zdGFydCwgXCJJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1sb29wXCIpO1xuICAgIH1cbiAgICBub2RlLmxlZnQgPSBpbml0O1xuICAgIG5vZGUucmlnaHQgPSBpc0ZvckluID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNGb3JJbiA/IFwiRm9ySW5TdGF0ZW1lbnRcIiA6IFwiRm9yT2ZTdGF0ZW1lbnRcIilcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VWYXIgPSBmdW5jdGlvbihub2RlLCBpc0Zvciwga2luZCkge1xuICAgIG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gICAgbm9kZS5raW5kID0ga2luZDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZGVjbCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLnBhcnNlVmFySWQoZGVjbCwga2luZCk7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMuZXEpKSB7XG4gICAgICAgIGRlY2wuaW5pdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihpc0Zvcik7XG4gICAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwiY29uc3RcIiAmJiAhKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9IGVsc2UgaWYgKGRlY2wuaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgIShpc0ZvciAmJiAodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIkNvbXBsZXggYmluZGluZyBwYXR0ZXJucyByZXF1aXJlIGFuIGluaXRpYWxpemF0aW9uIHZhbHVlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVjbC5pbml0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUuZGVjbGFyYXRpb25zLnB1c2godGhpcy5maW5pc2hOb2RlKGRlY2wsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKTtcbiAgICAgIGlmICghdGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IGJyZWFrIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBwcCQxLnBhcnNlVmFySWQgPSBmdW5jdGlvbihkZWNsLCBraW5kKSB7XG4gICAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKGRlY2wuaWQsIGtpbmQgPT09IFwidmFyXCIgPyBCSU5EX1ZBUiA6IEJJTkRfTEVYSUNBTCwgZmFsc2UpO1xuICB9O1xuXG4gIHZhciBGVU5DX1NUQVRFTUVOVCA9IDEsIEZVTkNfSEFOR0lOR19TVEFURU1FTlQgPSAyLCBGVU5DX05VTExBQkxFX0lEID0gNDtcblxuXG4gIHBwJDEucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIHN0YXRlbWVudCwgYWxsb3dFeHByZXNzaW9uQm9keSwgaXNBc3luYykge1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhaXNBc3luYykge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3RhciAmJiAoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuZ2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgaWYgKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSB7XG4gICAgICBub2RlLmlkID0gKHN0YXRlbWVudCAmIEZVTkNfTlVMTEFCTEVfSUQpICYmIHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSA/IG51bGwgOiB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIGlmIChub2RlLmlkICYmICEoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAgIHsgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgKHRoaXMuc3RyaWN0IHx8IG5vZGUuZ2VuZXJhdG9yIHx8IG5vZGUuYXN5bmMpID8gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFyID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwgOiBCSU5EX0ZVTkNUSU9OKTsgfVxuICAgIH1cblxuICAgIHZhciBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKG5vZGUuYXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSk7XG5cbiAgICBpZiAoIShzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkpXG4gICAgICB7IG5vZGUuaWQgPSB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IG51bGw7IH1cblxuICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbkJvZHksIGZhbHNlKTtcblxuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gIH07XG5cblxuICBwcCQxLnBhcnNlQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0O1xuICAgIHRoaXMuc3RyaWN0ID0gdHJ1ZTtcblxuICAgIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50KTtcbiAgICB0aGlzLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIgaGFkQ29uc3RydWN0b3IgPSBmYWxzZTtcbiAgICBjbGFzc0JvZHkuYm9keSA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VDbGFzc0VsZW1lbnQobm9kZS5zdXBlckNsYXNzICE9PSBudWxsKTtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIGVsZW1lbnQua2luZCA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgaWYgKGhhZENvbnN0cnVjdG9yKSB7IHRoaXMucmFpc2UoZWxlbWVudC5zdGFydCwgXCJEdXBsaWNhdGUgY29uc3RydWN0b3IgaW4gdGhlIHNhbWUgY2xhc3NcIik7IH1cbiAgICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQxLnBhcnNlQ2xhc3NFbGVtZW50ID0gZnVuY3Rpb24oY29uc3RydWN0b3JBbGxvd3NTdXBlcikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpKSB7IHJldHVybiBudWxsIH1cblxuICAgIHZhciBtZXRob2QgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciB0cnlDb250ZXh0dWFsID0gZnVuY3Rpb24gKGssIG5vTGluZUJyZWFrKSB7XG4gICAgICBpZiAoIG5vTGluZUJyZWFrID09PSB2b2lkIDAgKSBub0xpbmVCcmVhayA9IGZhbHNlO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzJDEuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcyQxLnN0YXJ0TG9jO1xuICAgICAgaWYgKCF0aGlzJDEuZWF0Q29udGV4dHVhbChrKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKHRoaXMkMS50eXBlICE9PSB0eXBlcy5wYXJlbkwgJiYgKCFub0xpbmVCcmVhayB8fCAhdGhpcyQxLmNhbkluc2VydFNlbWljb2xvbigpKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBpZiAobWV0aG9kLmtleSkgeyB0aGlzJDEudW5leHBlY3RlZCgpOyB9XG4gICAgICBtZXRob2QuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIG1ldGhvZC5rZXkgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnQsIHN0YXJ0TG9jKTtcbiAgICAgIG1ldGhvZC5rZXkubmFtZSA9IGs7XG4gICAgICB0aGlzJDEuZmluaXNoTm9kZShtZXRob2Qua2V5LCBcIklkZW50aWZpZXJcIik7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9O1xuXG4gICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgIG1ldGhvZC5zdGF0aWMgPSB0cnlDb250ZXh0dWFsKFwic3RhdGljXCIpO1xuICAgIHZhciBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIHZhciBpc0FzeW5jID0gZmFsc2U7XG4gICAgaWYgKCFpc0dlbmVyYXRvcikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIHRyeUNvbnRleHR1YWwoXCJhc3luY1wiLCB0cnVlKSkge1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICAgIH0gZWxzZSBpZiAodHJ5Q29udGV4dHVhbChcImdldFwiKSkge1xuICAgICAgICBtZXRob2Qua2luZCA9IFwiZ2V0XCI7XG4gICAgICB9IGVsc2UgaWYgKHRyeUNvbnRleHR1YWwoXCJzZXRcIikpIHtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcInNldFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1ldGhvZC5rZXkpIHsgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpOyB9XG4gICAgdmFyIGtleSA9IG1ldGhvZC5rZXk7XG4gICAgdmFyIGFsbG93c0RpcmVjdFN1cGVyID0gZmFsc2U7XG4gICAgaWYgKCFtZXRob2QuY29tcHV0ZWQgJiYgIW1ldGhvZC5zdGF0aWMgJiYgKGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8XG4gICAgICAgIGtleS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgIGlmIChtZXRob2Qua2luZCAhPT0gXCJtZXRob2RcIikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7IH1cbiAgICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgbWV0aG9kXCIpOyB9XG4gICAgICBtZXRob2Qua2luZCA9IFwiY29uc3RydWN0b3JcIjtcbiAgICAgIGFsbG93c0RpcmVjdFN1cGVyID0gY29uc3RydWN0b3JBbGxvd3NTdXBlcjtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZC5zdGF0aWMgJiYga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGVcIik7XG4gICAgfVxuICAgIHRoaXMucGFyc2VDbGFzc01ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDEpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShtZXRob2QudmFsdWUuc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICAgIHJldHVybiBtZXRob2RcbiAgfTtcblxuICBwcCQxLnBhcnNlQ2xhc3NNZXRob2QgPSBmdW5jdGlvbihtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIG1ldGhvZC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJNZXRob2REZWZpbml0aW9uXCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUNsYXNzSWQgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIGlmIChpc1N0YXRlbWVudClcbiAgICAgICAgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBCSU5EX0xFWElDQUwsIGZhbHNlKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNTdGF0ZW1lbnQgPT09IHRydWUpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBwcCQxLnBhcnNlQ2xhc3NTdXBlciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCh0eXBlcy5fZXh0ZW5kcykgPyB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoKSA6IG51bGw7XG4gIH07XG5cblxuICBwcCQxLnBhcnNlRXhwb3J0ID0gZnVuY3Rpb24obm9kZSwgZXhwb3J0cykge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5zdGFyKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSkge1xuICAgICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgICAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5leHBvcnRlZC5uYW1lLCB0aGlzLmxhc3RUb2tTdGFydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5leHBvcnRlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpXG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5fZGVmYXVsdCkpIHsgXG4gICAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB0aGlzLmxhc3RUb2tTdGFydCk7XG4gICAgICB2YXIgaXNBc3luYztcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbiB8fCAoaXNBc3luYyA9IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpKSB7XG4gICAgICAgIHZhciBmTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAoaXNBc3luYykgeyB0aGlzLm5leHQoKTsgfVxuICAgICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGZOb2RlLCBGVU5DX1NUQVRFTUVOVCB8IEZVTkNfTlVMTEFCTEVfSUQsIGZhbHNlLCBpc0FzeW5jKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2xhc3MpIHtcbiAgICAgICAgdmFyIGNOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VDbGFzcyhjTm9kZSwgXCJudWxsYWJsZUlEXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCgpKSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICAgIGlmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxuICAgICAgICB7IHRoaXMuY2hlY2tWYXJpYWJsZUV4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucyk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uaWQubmFtZSwgbm9kZS5kZWNsYXJhdGlvbi5pZC5zdGFydCk7IH1cbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgIH0gZWxzZSB7IFxuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IG51bGw7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyhleHBvcnRzKTtcbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJmcm9tXCIpKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnNwZWNpZmllcnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIHNwZWMgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQoc3BlYy5sb2NhbCk7XG4gICAgICAgICAgdGhpcy5jaGVja0xvY2FsRXhwb3J0KHNwZWMubG9jYWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIilcbiAgfTtcblxuICBwcCQxLmNoZWNrRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgcG9zKSB7XG4gICAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gICAgaWYgKGhhcyhleHBvcnRzLCBuYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgXCJEdXBsaWNhdGUgZXhwb3J0ICdcIiArIG5hbWUgKyBcIidcIik7IH1cbiAgICBleHBvcnRzW25hbWVdID0gdHJ1ZTtcbiAgfTtcblxuICBwcCQxLmNoZWNrUGF0dGVybkV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIHBhdCkge1xuICAgIHZhciB0eXBlID0gcGF0LnR5cGU7XG4gICAgaWYgKHR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIHBhdC5uYW1lLCBwYXQuc3RhcnQpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGF0LnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcHJvcCk7XG4gICAgICAgIH0gfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpXG4gICAgICB7IGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHBhdC5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIGVsdCA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICAgICAgaWYgKGVsdCkgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBlbHQpOyB9XG4gICAgICB9IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIlByb3BlcnR5XCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC52YWx1ZSk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5sZWZ0KTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmFyZ3VtZW50KTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmV4cHJlc3Npb24pOyB9XG4gIH07XG5cbiAgcHAkMS5jaGVja1ZhcmlhYmxlRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgZGVjbHMpIHtcbiAgICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGRlY2xzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBkZWNsID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZGVjbC5pZCk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDEuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlLmtleXdvcmQgPT09IFwidmFyXCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNvbnN0XCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNsYXNzXCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgIHRoaXMuaXNMZXQoKSB8fFxuICAgICAgdGhpcy5pc0FzeW5jRnVuY3Rpb24oKVxuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUV4cG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSA/IHRoaXMucGFyc2VJZGVudCh0cnVlKSA6IG5vZGUubG9jYWw7XG4gICAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZXhwb3J0ZWQubmFtZSwgbm9kZS5leHBvcnRlZC5zdGFydCk7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydFNwZWNpZmllclwiKSk7XG4gICAgfVxuICAgIHJldHVybiBub2Rlc1xuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcpIHtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IGVtcHR5O1xuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcnMoKTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VJbXBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChub2RlLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpKTtcbiAgICAgIGlmICghdGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IHJldHVybiBub2RlcyB9XG4gICAgfVxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIpIHtcbiAgICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICAgIG5vZGUkMS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgdGhpcy5jaGVja0xWYWwobm9kZSQxLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSk7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBub2RlJDIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZSQyLmltcG9ydGVkID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICAgIG5vZGUkMi5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQobm9kZSQyLmltcG9ydGVkKTtcbiAgICAgICAgbm9kZSQyLmxvY2FsID0gbm9kZSQyLmltcG9ydGVkO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0xWYWwobm9kZSQyLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSQyLCBcIkltcG9ydFNwZWNpZmllclwiKSk7XG4gICAgfVxuICAgIHJldHVybiBub2Rlc1xuICB9O1xuXG4gIHBwJDEuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZSA9IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoICYmIHRoaXMuaXNEaXJlY3RpdmVDYW5kaWRhdGUoc3RhdGVtZW50c1tpXSk7ICsraSkge1xuICAgICAgc3RhdGVtZW50c1tpXS5kaXJlY3RpdmUgPSBzdGF0ZW1lbnRzW2ldLmV4cHJlc3Npb24ucmF3LnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gIH07XG4gIHBwJDEuaXNEaXJlY3RpdmVDYW5kaWRhdGUgPSBmdW5jdGlvbihzdGF0ZW1lbnQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgc3RhdGVtZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmXG4gICAgICBzdGF0ZW1lbnQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJlxuICAgICAgdHlwZW9mIHN0YXRlbWVudC5leHByZXNzaW9uLnZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAodGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIlxcXCJcIiB8fCB0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiJ1wiKVxuICAgIClcbiAgfTtcblxuICB2YXIgcHAkMiA9IFBhcnNlci5wcm90b3R5cGU7XG5cblxuICBwcCQyLnRvQXNzaWduYWJsZSA9IGZ1bmN0aW9uKG5vZGUsIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBub2RlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgaWYgKHRoaXMuaW5Bc3luYyAmJiBub2RlLm5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIk9iamVjdFBhdHRlcm5cIjtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHByb3AsIGlzQmluZGluZyk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcHJvcC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiZcbiAgICAgICAgICAgIChwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIgfHwgcHJvcC5hcmd1bWVudC50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UocHJvcC5hcmd1bWVudC5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJpbml0XCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXJcIik7IH1cbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS52YWx1ZSwgaXNCaW5kaW5nKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIkFycmF5UGF0dGVyblwiO1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3Qobm9kZS5lbGVtZW50cywgaXNCaW5kaW5nKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmFyZ3VtZW50LCBpc0JpbmRpbmcpO1xuICAgICAgICBpZiAobm9kZS5hcmd1bWVudC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuYXJndW1lbnQuc3RhcnQsIFwiUmVzdCBlbGVtZW50cyBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIj1cIikgeyB0aGlzLnJhaXNlKG5vZGUubGVmdC5lbmQsIFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIik7IH1cbiAgICAgICAgbm9kZS50eXBlID0gXCJBc3NpZ25tZW50UGF0dGVyblwiO1xuICAgICAgICBkZWxldGUgbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5sZWZ0LCBpc0JpbmRpbmcpO1xuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNCaW5kaW5nLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIkNoYWluRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIGxlZnQtaGFuZCBzaWRlXCIpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAoIWlzQmluZGluZykgeyBicmVhayB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cblxuICBwcCQyLnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gICAgdmFyIGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoZWx0KSB7IHRoaXMudG9Bc3NpZ25hYmxlKGVsdCwgaXNCaW5kaW5nKTsgfVxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICB2YXIgbGFzdCA9IGV4cHJMaXN0W2VuZCAtIDFdO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiBpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZChsYXN0LmFyZ3VtZW50LnN0YXJ0KTsgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwckxpc3RcbiAgfTtcblxuXG4gIHBwJDIucGFyc2VTcHJlYWQgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTcHJlYWRFbGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMi5wYXJzZVJlc3RCaW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVzdEVsZW1lbnRcIilcbiAgfTtcblxuXG4gIHBwJDIucGFyc2VCaW5kaW5nQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlQYXR0ZXJuXCIpXG5cbiAgICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaih0cnVlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50KClcbiAgfTtcblxuICBwcCQyLnBhcnNlQmluZGluZ0xpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dFbXB0eSwgYWxsb3dUcmFpbGluZ0NvbW1hKSB7XG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBmYWxzZTsgfVxuICAgICAgZWxzZSB7IHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTsgfVxuICAgICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgICAgICBlbHRzLnB1c2gobnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgICB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKHJlc3QpO1xuICAgICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICAgICAgdGhpcy5leHBlY3QoY2xvc2UpO1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpO1xuICAgICAgICB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKGVsZW0pO1xuICAgICAgICBlbHRzLnB1c2goZWxlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbHRzXG4gIH07XG5cbiAgcHAkMi5wYXJzZUJpbmRpbmdMaXN0SXRlbSA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtXG4gIH07XG5cblxuICBwcCQyLnBhcnNlTWF5YmVEZWZhdWx0ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0KSB7XG4gICAgbGVmdCA9IGxlZnQgfHwgdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgIXRoaXMuZWF0KHR5cGVzLmVxKSkgeyByZXR1cm4gbGVmdCB9XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gIH07XG5cblxuICBwcCQyLmNoZWNrTFZhbCA9IGZ1bmN0aW9uKGV4cHIsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpIHtcbiAgICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMICYmIGV4cHIubmFtZSA9PT0gXCJsZXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJsZXQgaXMgZGlzYWxsb3dlZCBhcyBhIGxleGljYWxseSBib3VuZCBuYW1lXCIpOyB9XG4gICAgICBpZiAodGhpcy5zdHJpY3QgJiYgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZC50ZXN0KGV4cHIubmFtZSkpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIChiaW5kaW5nVHlwZSA/IFwiQmluZGluZyBcIiA6IFwiQXNzaWduaW5nIHRvIFwiKSArIGV4cHIubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgIGlmIChoYXMoY2hlY2tDbGFzaGVzLCBleHByLm5hbWUpKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQXJndW1lbnQgbmFtZSBjbGFzaFwiKTsgfVxuICAgICAgICBjaGVja0NsYXNoZXNbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYmluZGluZ1R5cGUgIT09IEJJTkRfTk9ORSAmJiBiaW5kaW5nVHlwZSAhPT0gQklORF9PVVRTSURFKSB7IHRoaXMuZGVjbGFyZU5hbWUoZXhwci5uYW1lLCBiaW5kaW5nVHlwZSwgZXhwci5zdGFydCk7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQ2hhaW5FeHByZXNzaW9uXCI6XG4gICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIGxlZnQtaGFuZCBzaWRlXCIpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBpZiAoYmluZGluZ1R5cGUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGV4cHIucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIHtcbiAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5jaGVja0xWYWwocHJvcCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci52YWx1ZSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gZXhwci5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIGVsZW0gPSBsaXN0JDFbaSQxXTtcblxuICAgICAgaWYgKGVsZW0pIHsgdGhpcy5jaGVja0xWYWwoZWxlbSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7IH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIubGVmdCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLmFyZ3VtZW50LCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMucmFpc2UoZXhwci5zdGFydCwgKGJpbmRpbmdUeXBlID8gXCJCaW5kaW5nXCIgOiBcIkFzc2lnbmluZyB0b1wiKSArIFwiIHJ2YWx1ZVwiKTtcbiAgICB9XG4gIH07XG5cblxuICB2YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGU7XG5cblxuICBwcCQzLmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24ocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICAgIHsgcmV0dXJuIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgKHByb3AuY29tcHV0ZWQgfHwgcHJvcC5tZXRob2QgfHwgcHJvcC5zaG9ydGhhbmQpKVxuICAgICAgeyByZXR1cm4gfVxuICAgIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgICB2YXIgbmFtZTtcbiAgICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjogbmFtZSA9IGtleS5uYW1lOyBicmVha1xuICAgIGNhc2UgXCJMaXRlcmFsXCI6IG5hbWUgPSBTdHJpbmcoa2V5LnZhbHVlKTsgYnJlYWtcbiAgICBkZWZhdWx0OiByZXR1cm5cbiAgICB9XG4gICAgdmFyIGtpbmQgPSBwcm9wLmtpbmQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIiAmJiBraW5kID09PSBcImluaXRcIikge1xuICAgICAgICBpZiAocHJvcEhhc2gucHJvdG8pIHtcbiAgICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPCAwKVxuICAgICAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSBrZXkuc3RhcnQ7IH1cbiAgICAgICAgICB9IGVsc2UgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbiAgICAgICAgfVxuICAgICAgICBwcm9wSGFzaC5wcm90byA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbmFtZSA9IFwiJFwiICsgbmFtZTtcbiAgICB2YXIgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXTtcbiAgICBpZiAob3RoZXIpIHtcbiAgICAgIHZhciByZWRlZmluaXRpb247XG4gICAgICBpZiAoa2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgICAgcmVkZWZpbml0aW9uID0gdGhpcy5zdHJpY3QgJiYgb3RoZXIuaW5pdCB8fCBvdGhlci5nZXQgfHwgb3RoZXIuc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVkZWZpbml0aW9uID0gb3RoZXIuaW5pdCB8fCBvdGhlcltraW5kXTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWRlZmluaXRpb24pXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXSA9IHtcbiAgICAgICAgaW5pdDogZmFsc2UsXG4gICAgICAgIGdldDogZmFsc2UsXG4gICAgICAgIHNldDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIG90aGVyW2tpbmRdID0gdHJ1ZTtcbiAgfTtcblxuXG5cblxuICBwcCQzLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICAgIHdoaWxlICh0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHsgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSk7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIilcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwieWllbGRcIikpIHtcbiAgICAgIGlmICh0aGlzLmluR2VuZXJhdG9yKSB7IHJldHVybiB0aGlzLnBhcnNlWWllbGQobm9JbikgfVxuICAgICAgZWxzZSB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICAgIH1cblxuICAgIHZhciBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gZmFsc2UsIG9sZFBhcmVuQXNzaWduID0gLTEsIG9sZFRyYWlsaW5nQ29tbWEgPSAtMTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgICBvbGRUcmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hO1xuICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgfHwgdGhpcy50eXBlID09PSB0eXBlcy5uYW1lKVxuICAgICAgeyB0aGlzLnBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXJ0OyB9XG4gICAgdmFyIGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbChub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHsgbGVmdCA9IGFmdGVyTGVmdFBhcnNlLmNhbGwodGhpcywgbGVmdCwgc3RhcnRQb3MsIHN0YXJ0TG9jKTsgfVxuICAgIGlmICh0aGlzLnR5cGUuaXNBc3NpZ24pIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmVxID8gdGhpcy50b0Fzc2lnbmFibGUobGVmdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIDogbGVmdDtcbiAgICAgIGlmICghb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0gLTE7XG4gICAgICB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPj0gbm9kZS5sZWZ0LnN0YXJ0KVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IH0gXG4gICAgICB0aGlzLmNoZWNrTFZhbChsZWZ0KTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgIH1cbiAgICBpZiAob2xkUGFyZW5Bc3NpZ24gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBvbGRQYXJlbkFzc2lnbjsgfVxuICAgIGlmIChvbGRUcmFpbGluZ0NvbW1hID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gb2xkVHJhaWxpbmdDb21tYTsgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cblxuICBwcCQzLnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH07XG5cblxuICBwcCQzLnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgICByZXR1cm4gZXhwci5zdGFydCA9PT0gc3RhcnRQb3MgJiYgZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgPyBleHByIDogdGhpcy5wYXJzZUV4cHJPcChleHByLCBzdGFydFBvcywgc3RhcnRMb2MsIC0xLCBub0luKVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKSB7XG4gICAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gICAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgdGhpcy50eXBlICE9PSB0eXBlcy5faW4pKSB7XG4gICAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgICAgdmFyIGxvZ2ljYWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxPUiB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxBTkQ7XG4gICAgICAgIHZhciBjb2FsZXNjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuY29hbGVzY2U7XG4gICAgICAgIGlmIChjb2FsZXNjZSkge1xuICAgICAgICAgIHByZWMgPSB0eXBlcy5sb2dpY2FsQU5ELmJpbm9wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcCA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBzdGFydFBvcywgc3RhcnRMb2MsIHByZWMsIG5vSW4pO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYnVpbGRCaW5hcnkobGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCB8fCBjb2FsZXNjZSk7XG4gICAgICAgIGlmICgobG9naWNhbCAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvYWxlc2NlKSB8fCAoY29hbGVzY2UgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMubG9naWNhbE9SIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubG9naWNhbEFORCkpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiTG9naWNhbCBleHByZXNzaW9ucyBhbmQgY29hbGVzY2UgZXhwcmVzc2lvbnMgY2Fubm90IGJlIG1peGVkLiBXcmFwIGVpdGhlciBieSBwYXJlbnRoZXNlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChub2RlLCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9JbilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlZnRcbiAgfTtcblxuICBwcCQzLmJ1aWxkQmluYXJ5ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG4gIH07XG5cblxuICBwcCQzLnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHNhd1VuYXJ5KSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBleHByO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpICYmICh0aGlzLmluQXN5bmMgfHwgKCF0aGlzLmluRnVuY3Rpb24gJiYgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24pKSkge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdCgpO1xuICAgICAgc2F3VW5hcnkgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLnByZWZpeCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmluY0RlYztcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSk7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgIGlmICh1cGRhdGUpIHsgdGhpcy5jaGVja0xWYWwobm9kZS5hcmd1bWVudCk7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiZcbiAgICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICAgIGVsc2UgeyBzYXdVbmFyeSA9IHRydWU7IH1cbiAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgICB3aGlsZSAodGhpcy50eXBlLnBvc3RmaXggJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgbm9kZSQxLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbm9kZSQxLnByZWZpeCA9IGZhbHNlO1xuICAgICAgICBub2RlJDEuYXJndW1lbnQgPSBleHByO1xuICAgICAgICB0aGlzLmNoZWNrTFZhbChleHByKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIlVwZGF0ZUV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzYXdVbmFyeSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyc3RhcikpXG4gICAgICB7IHJldHVybiB0aGlzLmJ1aWxkQmluYXJ5KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwciwgdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBcIioqXCIsIGZhbHNlKSB9XG4gICAgZWxzZVxuICAgICAgeyByZXR1cm4gZXhwciB9XG4gIH07XG5cblxuICBwcCQzLnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJBdG9tKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmIChleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiB0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tFbmQpICE9PSBcIilcIilcbiAgICAgIHsgcmV0dXJuIGV4cHIgfVxuICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyhleHByLCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlc3VsdC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gLTE7IH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID49IHJlc3VsdC5zdGFydCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gLTE7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9O1xuXG4gIHBwJDMucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gICAgdmFyIG1heWJlQXN5bmNBcnJvdyA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAgICAgdGhpcy5sYXN0VG9rRW5kID09PSBiYXNlLmVuZCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiBiYXNlLmVuZCAtIGJhc2Uuc3RhcnQgPT09IDUgJiZcbiAgICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSBiYXNlLnN0YXJ0O1xuICAgIHZhciBvcHRpb25hbENoYWluZWQgPSBmYWxzZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3csIG9wdGlvbmFsQ2hhaW5lZCk7XG5cbiAgICAgIGlmIChlbGVtZW50Lm9wdGlvbmFsKSB7IG9wdGlvbmFsQ2hhaW5lZCA9IHRydWU7IH1cbiAgICAgIGlmIChlbGVtZW50ID09PSBiYXNlIHx8IGVsZW1lbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmIChvcHRpb25hbENoYWluZWQpIHtcbiAgICAgICAgICB2YXIgY2hhaW5Ob2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICAgIGNoYWluTm9kZS5leHByZXNzaW9uID0gZWxlbWVudDtcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy5maW5pc2hOb2RlKGNoYWluTm9kZSwgXCJDaGFpbkV4cHJlc3Npb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICAgIH1cblxuICAgICAgYmFzZSA9IGVsZW1lbnQ7XG4gICAgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VTdWJzY3JpcHQgPSBmdW5jdGlvbihiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIG1heWJlQXN5bmNBcnJvdywgb3B0aW9uYWxDaGFpbmVkKSB7XG4gICAgdmFyIG9wdGlvbmFsU3VwcG9ydGVkID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExO1xuICAgIHZhciBvcHRpb25hbCA9IG9wdGlvbmFsU3VwcG9ydGVkICYmIHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uRG90KTtcbiAgICBpZiAobm9DYWxscyAmJiBvcHRpb25hbCkgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gdGhlIGNhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbnNcIik7IH1cblxuICAgIHZhciBjb21wdXRlZCA9IHRoaXMuZWF0KHR5cGVzLmJyYWNrZXRMKTtcbiAgICBpZiAoY29tcHV0ZWQgfHwgKG9wdGlvbmFsICYmIHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5MICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYmFja1F1b3RlKSB8fCB0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICAgIG5vZGUucHJvcGVydHkgPSBjb21wdXRlZCA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IFwibmV2ZXJcIik7XG4gICAgICBub2RlLmNvbXB1dGVkID0gISFjb21wdXRlZDtcbiAgICAgIGlmIChjb21wdXRlZCkgeyB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7IH1cbiAgICAgIGlmIChvcHRpb25hbFN1cHBvcnRlZCkge1xuICAgICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICB9XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICAgICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgICB2YXIgZXhwckxpc3QgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiAhb3B0aW9uYWwgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMuYXJyb3cpKSB7XG4gICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgICAgaWYgKHRoaXMuYXdhaXRJZGVudFBvcyA+IDApXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRJZGVudFBvcywgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZXhwckxpc3QsIHRydWUpXG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcyB8fCB0aGlzLnlpZWxkUG9zO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG4gICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zIHx8IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlJDEuY2FsbGVlID0gYmFzZTtcbiAgICAgIG5vZGUkMS5hcmd1bWVudHMgPSBleHByTGlzdDtcbiAgICAgIGlmIChvcHRpb25hbFN1cHBvcnRlZCkge1xuICAgICAgICBub2RlJDEub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgIH1cbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5iYWNrUXVvdGUpIHtcbiAgICAgIGlmIChvcHRpb25hbCB8fCBvcHRpb25hbENoYWluZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gdGhlIHRhZyBvZiB0YWdnZWQgdGVtcGxhdGUgZXhwcmVzc2lvbnNcIik7XG4gICAgICB9XG4gICAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQyLnRhZyA9IGJhc2U7XG4gICAgICBub2RlJDIucXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGUoe2lzVGFnZ2VkOiB0cnVlfSk7XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBiYXNlXG4gIH07XG5cblxuICBwcCQzLnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2xhc2gpIHsgdGhpcy5yZWFkUmVnZXhwKCk7IH1cblxuICAgIHZhciBub2RlLCBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXJ0O1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgY2FzZSB0eXBlcy5fc3VwZXI6XG4gICAgICBpZiAoIXRoaXMuYWxsb3dTdXBlcilcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBrZXl3b3JkIG91dHNpZGUgYSBtZXRob2RcIik7IH1cbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgJiYgIXRoaXMuYWxsb3dEaXJlY3RTdXBlcilcbiAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwic3VwZXIoKSBjYWxsIG91dHNpZGUgY29uc3RydWN0b3Igb2YgYSBzdWJjbGFzc1wiKTsgfVxuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuZG90ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2tldEwgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5wYXJlbkwpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdXBlclwiKVxuXG4gICAgY2FzZSB0eXBlcy5fdGhpczpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIilcblxuICAgIGNhc2UgdHlwZXMubmFtZTpcbiAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhY29udGFpbnNFc2MgJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLl9mdW5jdGlvbikpXG4gICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIDAsIGZhbHNlLCB0cnVlKSB9XG4gICAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICBpZiAodGhpcy5lYXQodHlwZXMuYXJyb3cpKVxuICAgICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdLCBmYWxzZSkgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmIHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSAmJiAhY29udGFpbnNFc2MpIHtcbiAgICAgICAgICBpZCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgIXRoaXMuZWF0KHR5cGVzLmFycm93KSlcbiAgICAgICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZFxuXG4gICAgY2FzZSB0eXBlcy5yZWdleHA6XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZSA9IHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLnZhbHVlKTtcbiAgICAgIG5vZGUucmVnZXggPSB7cGF0dGVybjogdmFsdWUucGF0dGVybiwgZmxhZ3M6IHZhbHVlLmZsYWdzfTtcbiAgICAgIHJldHVybiBub2RlXG5cbiAgICBjYXNlIHR5cGVzLm51bTogY2FzZSB0eXBlcy5zdHJpbmc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSlcblxuICAgIGNhc2UgdHlwZXMuX251bGw6IGNhc2UgdHlwZXMuX3RydWU6IGNhc2UgdHlwZXMuX2ZhbHNlOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy50eXBlID09PSB0eXBlcy5fbnVsbCA/IG51bGwgOiB0aGlzLnR5cGUgPT09IHR5cGVzLl90cnVlO1xuICAgICAgbm9kZS5yYXcgPSB0aGlzLnR5cGUua2V5d29yZDtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcblxuICAgIGNhc2UgdHlwZXMucGFyZW5MOlxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KTtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwICYmICF0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIpKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHN0YXJ0OyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwclxuXG4gICAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlLCB0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheUV4cHJlc3Npb25cIilcblxuICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmooZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpXG5cbiAgICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIDApXG5cbiAgICBjYXNlIHR5cGVzLl9jbGFzczpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5zdGFydE5vZGUoKSwgZmFsc2UpXG5cbiAgICBjYXNlIHR5cGVzLl9uZXc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU5ldygpXG5cbiAgICBjYXNlIHR5cGVzLmJhY2tRdW90ZTpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGUoKVxuXG4gICAgY2FzZSB0eXBlcy5faW1wb3J0OlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJJbXBvcnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5leHBlY3RlZCgpXG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VFeHBySW1wb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgaW1wb3J0XCIpOyB9XG4gICAgdmFyIG1ldGEgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMucGFyZW5MOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VEeW5hbWljSW1wb3J0KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5kb3Q6XG4gICAgICBub2RlLm1ldGEgPSBtZXRhO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRNZXRhKG5vZGUpXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfTtcblxuICBwcCQzLnBhcnNlRHluYW1pY0ltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTsgXG5cbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuXG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5wYXJlblIpKSB7XG4gICAgICB2YXIgZXJyb3JQb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSAmJiB0aGlzLmVhdCh0eXBlcy5wYXJlblIpKSB7XG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShlcnJvclBvcywgXCJUcmFpbGluZyBjb21tYSBpcyBub3QgYWxsb3dlZCBpbiBpbXBvcnQoKVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChlcnJvclBvcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydEV4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQzLnBhcnNlSW1wb3J0TWV0YSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTsgXG5cbiAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG5cbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcIm1ldGFcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgaW1wb3J0IGlzICdpbXBvcnQubWV0YSdcIik7IH1cbiAgICBpZiAoY29udGFpbnNFc2MpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIidpbXBvcnQubWV0YScgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnNcIik7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgIT09IFwibW9kdWxlXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2ltcG9ydC5tZXRhJyBvdXRzaWRlIGEgbW9kdWxlXCIpOyB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZUxpdGVyYWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgbm9kZS5yYXcgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICBpZiAobm9kZS5yYXcuY2hhckNvZGVBdChub2RlLnJhdy5sZW5ndGggLSAxKSA9PT0gMTEwKSB7IG5vZGUuYmlnaW50ID0gbm9kZS5yYXcuc2xpY2UoMCwgLTEpLnJlcGxhY2UoL18vZywgXCJcIik7IH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIHZhciB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgcmV0dXJuIHZhbFxuICB9O1xuXG4gIHBwJDMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNhbkJlQXJyb3cpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIHZhbCwgYWxsb3dUcmFpbGluZ0NvbW1hID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDg7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgdmFyIGlubmVyU3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lclN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgIHZhciBleHByTGlzdCA9IFtdLCBmaXJzdCA9IHRydWUsIGxhc3RJc0NvbW1hID0gZmFsc2U7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgc3ByZWFkU3RhcnQ7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5SKSB7XG4gICAgICAgIGZpcnN0ID8gZmlyc3QgPSBmYWxzZSA6IHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5wYXJlblIsIHRydWUpKSB7XG4gICAgICAgICAgbGFzdElzQ29tbWEgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICAgIHNwcmVhZFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVJlc3RCaW5kaW5nKCkpKTtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdGhpcy5wYXJzZVBhcmVuSXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaW5uZXJFbmRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lckVuZExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuXG4gICAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFycm93TGlzdChzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KVxuICAgICAgfVxuXG4gICAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgICBpZiAoc3ByZWFkU3RhcnQpIHsgdGhpcy51bmV4cGVjdGVkKHNwcmVhZFN0YXJ0KTsgfVxuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuXG4gICAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgICB2YWwuZXhwcmVzc2lvbnMgPSBleHByTGlzdDtcbiAgICAgICAgdGhpcy5maW5pc2hOb2RlQXQodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBpbm5lckVuZFBvcywgaW5uZXJFbmRMb2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgICB2YXIgcGFyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgcGFyLmV4cHJlc3Npb24gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VQYXJlbkl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1cbiAgfTtcblxuICBwcCQzLnBhcnNlUGFyZW5BcnJvd0xpc3QgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdClcbiAgfTtcblxuXG4gIHZhciBlbXB0eSQxID0gW107XG5cbiAgcHAkMy5wYXJzZU5ldyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIG5ld1wiKTsgfVxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIgbWV0YSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgICAgbm9kZS5tZXRhID0gbWV0YTtcbiAgICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgaWYgKG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJ0YXJnZXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5wcm9wZXJ0eS5zdGFydCwgXCJUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciBuZXcgaXMgJ25ldy50YXJnZXQnXCIpOyB9XG4gICAgICBpZiAoY29udGFpbnNFc2MpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiJ25ldy50YXJnZXQnIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzXCIpOyB9XG4gICAgICBpZiAoIXRoaXMuaW5Ob25BcnJvd0Z1bmN0aW9uKCkpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiJ25ldy50YXJnZXQnIGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zXCIpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG4gICAgfVxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgaXNJbXBvcnQgPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9pbXBvcnQ7XG4gICAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20oKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCB0cnVlKTtcbiAgICBpZiAoaXNJbXBvcnQgJiYgbm9kZS5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRFeHByZXNzaW9uXCIpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhcnRQb3MsIFwiQ2Fubm90IHVzZSBuZXcgd2l0aCBpbXBvcnQoKVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHsgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UpOyB9XG4gICAgZWxzZSB7IG5vZGUuYXJndW1lbnRzID0gZW1wdHkkMTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOZXdFeHByZXNzaW9uXCIpXG4gIH07XG5cblxuICBwcCQzLnBhcnNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkO1xuXG4gICAgdmFyIGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmludmFsaWRUZW1wbGF0ZSkge1xuICAgICAgaWYgKCFpc1RhZ2dlZCkge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJCYWQgZXNjYXBlIHNlcXVlbmNlIGluIHVudGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxcIik7XG4gICAgICB9XG4gICAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgICByYXc6IHRoaXMudmFsdWUsXG4gICAgICAgIGNvb2tlZDogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgICBjb29rZWQ6IHRoaXMudmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIGVsZW0udGFpbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuYmFja1F1b3RlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIilcbiAgfTtcblxuICBwcCQzLnBhcnNlVGVtcGxhdGUgPSBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gICAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkOyBpZiAoIGlzVGFnZ2VkID09PSB2b2lkIDAgKSBpc1RhZ2dlZCA9IGZhbHNlO1xuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbXTtcbiAgICB2YXIgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSk7XG4gICAgbm9kZS5xdWFzaXMgPSBbY3VyRWx0XTtcbiAgICB3aGlsZSAoIWN1ckVsdC50YWlsKSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lb2YpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTsgfVxuICAgICAgdGhpcy5leHBlY3QodHlwZXMuZG9sbGFyQnJhY2VMKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlUik7XG4gICAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRlbXBsYXRlTGl0ZXJhbFwiKVxuICB9O1xuXG4gIHBwJDMuaXNBc3luY1Byb3AgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHByb3Aua2V5Lm5hbWUgPT09IFwiYXN5bmNcIiAmJlxuICAgICAgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmJyYWNrZXRMIHx8IHRoaXMudHlwZS5rZXl3b3JkIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIpKSAmJlxuICAgICAgIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VPYmogPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgcHJvcEhhc2ggPSB7fTtcbiAgICBub2RlLnByb3BlcnRpZXMgPSBbXTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBwcm9wID0gdGhpcy5wYXJzZVByb3BlcnR5KGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAoIWlzUGF0dGVybikgeyB0aGlzLmNoZWNrUHJvcENsYXNoKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQzLnBhcnNlUHJvcGVydHkgPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLmVsbGlwc2lzKSkge1xuICAgICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJSZXN0RWxlbWVudFwiKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDApIHtcbiAgICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMCkge1xuICAgICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMCkge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuICAgICAgcHJvcC5zaG9ydGhhbmQgPSBmYWxzZTtcbiAgICAgIGlmIChpc1BhdHRlcm4gfHwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICBzdGFydFBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgIH1cbiAgICAgIGlmICghaXNQYXR0ZXJuKVxuICAgICAgICB7IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7IH1cbiAgICB9XG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhaXNHZW5lcmF0b3IgJiYgdGhpcy5pc0FzeW5jUHJvcChwcm9wKSkge1xuICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlUHJvcGVydHlWYWx1ZShwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUHJvcGVydHlcIilcbiAgfTtcblxuICBwcCQzLnBhcnNlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpIHtcbiAgICBpZiAoKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29sb24pXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuY29sb24pKSB7XG4gICAgICBwcm9wLnZhbHVlID0gaXNQYXR0ZXJuID8gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MKSB7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgICB9IGVsc2UgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmXG4gICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuICAgICAgICAgICAgICAgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgICAgICAgICAgICh0aGlzLnR5cGUgIT09IHR5cGVzLmNvbW1hICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuZXEpKSB7XG4gICAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcHJvcC5raW5kID0gcHJvcC5rZXkubmFtZTtcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChmYWxzZSk7XG4gICAgICB2YXIgcGFyYW1Db3VudCA9IHByb3Aua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICAgICAgaWYgKHByb3AudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBwcm9wLnZhbHVlLnN0YXJ0O1xuICAgICAgICBpZiAocHJvcC5raW5kID09PSBcImdldFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJzZXRcIiAmJiBwcm9wLnZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocHJvcC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQocHJvcC5rZXkpO1xuICAgICAgaWYgKHByb3Aua2V5Lm5hbWUgPT09IFwiYXdhaXRcIiAmJiAhdGhpcy5hd2FpdElkZW50UG9zKVxuICAgICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IHN0YXJ0UG9zOyB9XG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcm9wLmtleSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZXEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSB0aGlzLnN0YXJ0OyB9XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC52YWx1ZSA9IHByb3Aua2V5O1xuICAgICAgfVxuICAgICAgcHJvcC5zaG9ydGhhbmQgPSB0cnVlO1xuICAgIH0gZWxzZSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cbiAgcHAkMy5wYXJzZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5icmFja2V0TCkpIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IHRydWU7XG4gICAgICAgIHByb3Aua2V5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgICAgICAgcmV0dXJuIHByb3Aua2V5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wLmtleSA9IHRoaXMudHlwZSA9PT0gdHlwZXMubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IFwibmV2ZXJcIilcbiAgfTtcblxuXG4gIHBwJDMuaW5pdEZ1bmN0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyBub2RlLmdlbmVyYXRvciA9IG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSBmYWxzZTsgfVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZU1ldGhvZCA9IGZ1bmN0aW9uKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd0RpcmVjdFN1cGVyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICAgIHsgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikgfCBTQ09QRV9TVVBFUiB8IChhbGxvd0RpcmVjdFN1cGVyID8gU0NPUEVfRElSRUNUX1NVUEVSIDogMCkpO1xuXG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCB0cnVlKTtcblxuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cblxuICBwcCQzLnBhcnNlQXJyb3dFeHByZXNzaW9uID0gZnVuY3Rpb24obm9kZSwgcGFyYW1zLCBpc0FzeW5jKSB7XG4gICAgdmFyIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuXG4gICAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgZmFsc2UpIHwgU0NPUEVfQVJST1cpO1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCkgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuXG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnRvQXNzaWduYWJsZUxpc3QocGFyYW1zLCB0cnVlKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUsIGZhbHNlKTtcblxuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIilcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VGdW5jdGlvbkJvZHkgPSBmdW5jdGlvbihub2RlLCBpc0Fycm93RnVuY3Rpb24sIGlzTWV0aG9kKSB7XG4gICAgdmFyIGlzRXhwcmVzc2lvbiA9IGlzQXJyb3dGdW5jdGlvbiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlTDtcbiAgICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3QsIHVzZVN0cmljdCA9IGZhbHNlO1xuXG4gICAgaWYgKGlzRXhwcmVzc2lvbikge1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSB0cnVlO1xuICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub25TaW1wbGUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiAhdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcyk7XG4gICAgICBpZiAoIW9sZFN0cmljdCB8fCBub25TaW1wbGUpIHtcbiAgICAgICAgdXNlU3RyaWN0ID0gdGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5lbmQpO1xuICAgICAgICBpZiAodXNlU3RyaWN0ICYmIG5vblNpbXBsZSlcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIklsbGVnYWwgJ3VzZSBzdHJpY3QnIGRpcmVjdGl2ZSBpbiBmdW5jdGlvbiB3aXRoIG5vbi1zaW1wbGUgcGFyYW1ldGVyIGxpc3RcIik7IH1cbiAgICAgIH1cbiAgICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgICBpZiAodXNlU3RyaWN0KSB7IHRoaXMuc3RyaWN0ID0gdHJ1ZTsgfVxuXG4gICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsICFvbGRTdHJpY3QgJiYgIXVzZVN0cmljdCAmJiAhaXNBcnJvd0Z1bmN0aW9uICYmICFpc01ldGhvZCAmJiB0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKSk7XG4gICAgICBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5pZCkgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBCSU5EX09VVFNJREUpOyB9XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UsIHVuZGVmaW5lZCwgdXNlU3RyaWN0ICYmICFvbGRTdHJpY3QpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5LmJvZHkpO1xuICAgICAgdGhpcy5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgfVxuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gIH07XG5cbiAgcHAkMy5pc1NpbXBsZVBhcmFtTGlzdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICAgIGlmIChwYXJhbS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgeyByZXR1cm4gZmFsc2VcbiAgICB9IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG5cbiAgcHAkMy5jaGVja1BhcmFtcyA9IGZ1bmN0aW9uKG5vZGUsIGFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBuYW1lSGFzaCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5jaGVja0xWYWwocGFyYW0sIEJJTkRfVkFSLCBhbGxvd0R1cGxpY2F0ZXMgPyBudWxsIDogbmFtZUhhc2gpO1xuICAgIH1cbiAgfTtcblxuXG4gIHBwJDMucGFyc2VFeHByTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHksIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBlbHQgPSAodm9pZCAwKTtcbiAgICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpXG4gICAgICAgIHsgZWx0ID0gbnVsbDsgfVxuICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICBlbHQgPSB0aGlzLnBhcnNlU3ByZWFkKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApXG4gICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0OyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgfVxuICAgICAgZWx0cy5wdXNoKGVsdCk7XG4gICAgfVxuICAgIHJldHVybiBlbHRzXG4gIH07XG5cbiAgcHAkMy5jaGVja1VucmVzZXJ2ZWQgPSBmdW5jdGlvbihyZWYpIHtcbiAgICB2YXIgc3RhcnQgPSByZWYuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IHJlZi5lbmQ7XG4gICAgdmFyIG5hbWUgPSByZWYubmFtZTtcblxuICAgIGlmICh0aGlzLmluR2VuZXJhdG9yICYmIG5hbWUgPT09IFwieWllbGRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ3lpZWxkJyBhcyBpZGVudGlmaWVyIGluc2lkZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgIGlmICh0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgaWYgKHRoaXMua2V5d29yZHMudGVzdChuYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZShzdGFydCwgKFwiVW5leHBlY3RlZCBrZXl3b3JkICdcIiArIG5hbWUgKyBcIidcIikpOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgJiZcbiAgICAgIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCkuaW5kZXhPZihcIlxcXFxcIikgIT09IC0xKSB7IHJldHVybiB9XG4gICAgdmFyIHJlID0gdGhpcy5zdHJpY3QgPyB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgOiB0aGlzLnJlc2VydmVkV29yZHM7XG4gICAgaWYgKHJlLnRlc3QobmFtZSkpIHtcbiAgICAgIGlmICghdGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSBrZXl3b3JkICdhd2FpdCcgb3V0c2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCAoXCJUaGUga2V5d29yZCAnXCIgKyBuYW1lICsgXCInIGlzIHJlc2VydmVkXCIpKTtcbiAgICB9XG4gIH07XG5cblxuICBwcCQzLnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsLCBpc0JpbmRpbmcpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSkge1xuICAgICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5rZXl3b3JkKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnR5cGUua2V5d29yZDtcblxuICAgICAgaWYgKChub2RlLm5hbWUgPT09IFwiY2xhc3NcIiB8fCBub2RlLm5hbWUgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgICAodGhpcy5sYXN0VG9rRW5kICE9PSB0aGlzLmxhc3RUb2tTdGFydCArIDEgfHwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubGFzdFRva1N0YXJ0KSAhPT0gNDYpKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRoaXMubmV4dCghIWxpYmVyYWwpO1xuICAgIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gICAgaWYgKCFsaWJlcmFsKSB7XG4gICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChub2RlKTtcbiAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiYXdhaXRcIiAmJiAhdGhpcy5hd2FpdElkZW50UG9zKVxuICAgICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IG5vZGUuc3RhcnQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VZaWVsZCA9IGZ1bmN0aW9uKG5vSW4pIHtcbiAgICBpZiAoIXRoaXMueWllbGRQb3MpIHsgdGhpcy55aWVsZFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zZW1pIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RhciAmJiAhdGhpcy50eXBlLnN0YXJ0c0V4cHIpKSB7XG4gICAgICBub2RlLmRlbGVnYXRlID0gZmFsc2U7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kZWxlZ2F0ZSA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VBd2FpdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5hd2FpdFBvcykgeyB0aGlzLmF3YWl0UG9zID0gdGhpcy5zdGFydDsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkF3YWl0RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHZhciBwcCQ0ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuXG4gIHBwJDQucmFpc2UgPSBmdW5jdGlvbihwb3MsIG1lc3NhZ2UpIHtcbiAgICB2YXIgbG9jID0gZ2V0TGluZUluZm8odGhpcy5pbnB1dCwgcG9zKTtcbiAgICBtZXNzYWdlICs9IFwiIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIpXCI7XG4gICAgdmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcbiAgICBlcnIucG9zID0gcG9zOyBlcnIubG9jID0gbG9jOyBlcnIucmFpc2VkQXQgPSB0aGlzLnBvcztcbiAgICB0aHJvdyBlcnJcbiAgfTtcblxuICBwcCQ0LnJhaXNlUmVjb3ZlcmFibGUgPSBwcCQ0LnJhaXNlO1xuXG4gIHBwJDQuY3VyUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmN1ckxpbmUsIHRoaXMucG9zIC0gdGhpcy5saW5lU3RhcnQpXG4gICAgfVxuICB9O1xuXG4gIHZhciBwcCQ1ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICB2YXIgU2NvcGUgPSBmdW5jdGlvbiBTY29wZShmbGFncykge1xuICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB0aGlzLnZhciA9IFtdO1xuICAgIHRoaXMubGV4aWNhbCA9IFtdO1xuICAgIHRoaXMuZnVuY3Rpb25zID0gW107XG4gIH07XG5cblxuICBwcCQ1LmVudGVyU2NvcGUgPSBmdW5jdGlvbihmbGFncykge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wdXNoKG5ldyBTY29wZShmbGFncykpO1xuICB9O1xuXG4gIHBwJDUuZXhpdFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICB9O1xuXG4gIHBwJDUudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUgPSBmdW5jdGlvbihzY29wZSkge1xuICAgIHJldHVybiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgfHwgIXRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKVxuICB9O1xuXG4gIHBwJDUuZGVjbGFyZU5hbWUgPSBmdW5jdGlvbihuYW1lLCBiaW5kaW5nVHlwZSwgcG9zKSB7XG4gICAgdmFyIHJlZGVjbGFyZWQgPSBmYWxzZTtcbiAgICBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfTEVYSUNBTCkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIHJlZGVjbGFyZWQgPSBzY29wZS5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLnZhci5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgICBzY29wZS5sZXhpY2FsLnB1c2gobmFtZSk7XG4gICAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgICB7IGRlbGV0ZSB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV07IH1cbiAgICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX1NJTVBMRV9DQVRDSCkge1xuICAgICAgdmFyIHNjb3BlJDEgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgICAgc2NvcGUkMS5sZXhpY2FsLnB1c2gobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9GVU5DVElPTikge1xuICAgICAgdmFyIHNjb3BlJDIgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgICAgaWYgKHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhcilcbiAgICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlJDIudmFyLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgICAgc2NvcGUkMi5mdW5jdGlvbnMucHVzaChuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgc2NvcGUkMyA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgICAgaWYgKHNjb3BlJDMubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgJiYgISgoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1NJTVBMRV9DQVRDSCkgJiYgc2NvcGUkMy5sZXhpY2FsWzBdID09PSBuYW1lKSB8fFxuICAgICAgICAgICAgIXRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUoc2NvcGUkMykgJiYgc2NvcGUkMy5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgICAgcmVkZWNsYXJlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzY29wZSQzLnZhci5wdXNoKG5hbWUpO1xuICAgICAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gICAgICAgIGlmIChzY29wZSQzLmZsYWdzICYgU0NPUEVfVkFSKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZGVjbGFyZWQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgKFwiSWRlbnRpZmllciAnXCIgKyBuYW1lICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWRcIikpOyB9XG4gIH07XG5cbiAgcHAkNS5jaGVja0xvY2FsRXhwb3J0ID0gZnVuY3Rpb24oaWQpIHtcbiAgICBpZiAodGhpcy5zY29wZVN0YWNrWzBdLmxleGljYWwuaW5kZXhPZihpZC5uYW1lKSA9PT0gLTEgJiZcbiAgICAgICAgdGhpcy5zY29wZVN0YWNrWzBdLnZhci5pbmRleE9mKGlkLm5hbWUpID09PSAtMSkge1xuICAgICAgdGhpcy51bmRlZmluZWRFeHBvcnRzW2lkLm5hbWVdID0gaWQ7XG4gICAgfVxuICB9O1xuXG4gIHBwJDUuY3VycmVudFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMV1cbiAgfTtcblxuICBwcCQ1LmN1cnJlbnRWYXJTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSKSB7IHJldHVybiBzY29wZSB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDUuY3VycmVudFRoaXNTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSICYmICEoc2NvcGUuZmxhZ3MgJiBTQ09QRV9BUlJPVykpIHsgcmV0dXJuIHNjb3BlIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgICB0aGlzLnR5cGUgPSBcIlwiO1xuICAgIHRoaXMuc3RhcnQgPSBwb3M7XG4gICAgdGhpcy5lbmQgPSAwO1xuICAgIGlmIChwYXJzZXIub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHBhcnNlciwgbG9jKTsgfVxuICAgIGlmIChwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlKVxuICAgICAgeyB0aGlzLnNvdXJjZUZpbGUgPSBwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlOyB9XG4gICAgaWYgKHBhcnNlci5vcHRpb25zLnJhbmdlcylcbiAgICAgIHsgdGhpcy5yYW5nZSA9IFtwb3MsIDBdOyB9XG4gIH07XG5cblxuICB2YXIgcHAkNiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgcHAkNi5zdGFydE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5zdGFydCwgdGhpcy5zdGFydExvYylcbiAgfTtcblxuICBwcCQ2LnN0YXJ0Tm9kZUF0ID0gZnVuY3Rpb24ocG9zLCBsb2MpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgcG9zLCBsb2MpXG4gIH07XG5cblxuICBmdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgIG5vZGUuZW5kID0gcG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyBub2RlLmxvYy5lbmQgPSBsb2M7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICAgIHsgbm9kZS5yYW5nZVsxXSA9IHBvczsgfVxuICAgIHJldHVybiBub2RlXG4gIH1cblxuICBwcCQ2LmZpbmlzaE5vZGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKVxuICB9O1xuXG5cbiAgcHAkNi5maW5pc2hOb2RlQXQgPSBmdW5jdGlvbihub2RlLCB0eXBlLCBwb3MsIGxvYykge1xuICAgIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYylcbiAgfTtcblxuXG4gIHZhciBUb2tDb250ZXh0ID0gZnVuY3Rpb24gVG9rQ29udGV4dCh0b2tlbiwgaXNFeHByLCBwcmVzZXJ2ZVNwYWNlLCBvdmVycmlkZSwgZ2VuZXJhdG9yKSB7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMuaXNFeHByID0gISFpc0V4cHI7XG4gICAgdGhpcy5wcmVzZXJ2ZVNwYWNlID0gISFwcmVzZXJ2ZVNwYWNlO1xuICAgIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgICB0aGlzLmdlbmVyYXRvciA9ICEhZ2VuZXJhdG9yO1xuICB9O1xuXG4gIHZhciB0eXBlcyQxID0ge1xuICAgIGJfc3RhdDogbmV3IFRva0NvbnRleHQoXCJ7XCIsIGZhbHNlKSxcbiAgICBiX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwie1wiLCB0cnVlKSxcbiAgICBiX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiJHtcIiwgZmFsc2UpLFxuICAgIHBfc3RhdDogbmV3IFRva0NvbnRleHQoXCIoXCIsIGZhbHNlKSxcbiAgICBwX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCB0cnVlKSxcbiAgICBxX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiYFwiLCB0cnVlLCB0cnVlLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gcC50cnlSZWFkVGVtcGxhdGVUb2tlbigpOyB9KSxcbiAgICBmX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgZmFsc2UpLFxuICAgIGZfZXhwcjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlKSxcbiAgICBmX2V4cHJfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUsIGZhbHNlLCBudWxsLCB0cnVlKSxcbiAgICBmX2dlbjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSwgZmFsc2UsIG51bGwsIHRydWUpXG4gIH07XG5cbiAgdmFyIHBwJDcgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHBwJDcuaW5pdGlhbENvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gW3R5cGVzJDEuYl9zdGF0XVxuICB9O1xuXG4gIHBwJDcuYnJhY2VJc0Jsb2NrID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKHBhcmVudCA9PT0gdHlwZXMkMS5mX2V4cHIgfHwgcGFyZW50ID09PSB0eXBlcyQxLmZfc3RhdClcbiAgICAgIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMkMS5iX3N0YXQgfHwgcGFyZW50ID09PSB0eXBlcyQxLmJfZXhwcikpXG4gICAgICB7IHJldHVybiAhcGFyZW50LmlzRXhwciB9XG5cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9yZXR1cm4gfHwgcHJldlR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy5leHByQWxsb3dlZClcbiAgICAgIHsgcmV0dXJuIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX2Vsc2UgfHwgcHJldlR5cGUgPT09IHR5cGVzLnNlbWkgfHwgcHJldlR5cGUgPT09IHR5cGVzLmVvZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMucGFyZW5SIHx8IHByZXZUeXBlID09PSB0eXBlcy5hcnJvdylcbiAgICAgIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKVxuICAgICAgeyByZXR1cm4gcGFyZW50ID09PSB0eXBlcyQxLmJfc3RhdCB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fdmFyIHx8IHByZXZUeXBlID09PSB0eXBlcy5fY29uc3QgfHwgcHJldlR5cGUgPT09IHR5cGVzLm5hbWUpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuICF0aGlzLmV4cHJBbGxvd2VkXG4gIH07XG5cbiAgcHAkNy5pbkdlbmVyYXRvckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMTsgaS0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dFtpXTtcbiAgICAgIGlmIChjb250ZXh0LnRva2VuID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHsgcmV0dXJuIGNvbnRleHQuZ2VuZXJhdG9yIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkNy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB2YXIgdXBkYXRlLCB0eXBlID0gdGhpcy50eXBlO1xuICAgIGlmICh0eXBlLmtleXdvcmQgJiYgcHJldlR5cGUgPT09IHR5cGVzLmRvdClcbiAgICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gICAgZWxzZSBpZiAodXBkYXRlID0gdHlwZS51cGRhdGVDb250ZXh0KVxuICAgICAgeyB1cGRhdGUuY2FsbCh0aGlzLCBwcmV2VHlwZSk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSB0eXBlLmJlZm9yZUV4cHI7IH1cbiAgfTtcblxuXG4gIHR5cGVzLnBhcmVuUi51cGRhdGVDb250ZXh0ID0gdHlwZXMuYnJhY2VSLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jb250ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICBpZiAob3V0ID09PSB0eXBlcyQxLmJfc3RhdCAmJiB0aGlzLmN1ckNvbnRleHQoKS50b2tlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gICAgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSAhb3V0LmlzRXhwcjtcbiAgfTtcblxuICB0eXBlcy5icmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdGhpcy5jb250ZXh0LnB1c2godGhpcy5icmFjZUlzQmxvY2socHJldlR5cGUpID8gdHlwZXMkMS5iX3N0YXQgOiB0eXBlcyQxLmJfZXhwcik7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMuZG9sbGFyQnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmJfdG1wbCk7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMucGFyZW5MLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBzdGF0ZW1lbnRQYXJlbnMgPSBwcmV2VHlwZSA9PT0gdHlwZXMuX2lmIHx8IHByZXZUeXBlID09PSB0eXBlcy5fZm9yIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2l0aCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX3doaWxlO1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHN0YXRlbWVudFBhcmVucyA/IHR5cGVzJDEucF9zdGF0IDogdHlwZXMkMS5wX2V4cHIpO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzLmluY0RlYy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIH07XG5cbiAgdHlwZXMuX2Z1bmN0aW9uLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5fY2xhc3MudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgaWYgKHByZXZUeXBlLmJlZm9yZUV4cHIgJiYgcHJldlR5cGUgIT09IHR5cGVzLnNlbWkgJiYgcHJldlR5cGUgIT09IHR5cGVzLl9lbHNlICYmXG4gICAgICAgICEocHJldlR5cGUgPT09IHR5cGVzLl9yZXR1cm4gJiYgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSkgJiZcbiAgICAgICAgISgocHJldlR5cGUgPT09IHR5cGVzLmNvbG9uIHx8IHByZXZUeXBlID09PSB0eXBlcy5icmFjZUwpICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcyQxLmJfc3RhdCkpXG4gICAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuZl9leHByKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5mX3N0YXQpOyB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHR5cGVzLmJhY2tRdW90ZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcyQxLnFfdG1wbClcbiAgICAgIHsgdGhpcy5jb250ZXh0LnBvcCgpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLnFfdG1wbCk7IH1cbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gIH07XG5cbiAgdHlwZXMuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbikge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7XG4gICAgICBpZiAodGhpcy5jb250ZXh0W2luZGV4XSA9PT0gdHlwZXMkMS5mX2V4cHIpXG4gICAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9leHByX2dlbjsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHRoaXMuY29udGV4dFtpbmRleF0gPSB0eXBlcyQxLmZfZ2VuOyB9XG4gICAgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHR5cGVzLm5hbWUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIGFsbG93ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgcHJldlR5cGUgIT09IHR5cGVzLmRvdCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwib2ZcIiAmJiAhdGhpcy5leHByQWxsb3dlZCB8fFxuICAgICAgICAgIHRoaXMudmFsdWUgPT09IFwieWllbGRcIiAmJiB0aGlzLmluR2VuZXJhdG9yQ29udGV4dCgpKVxuICAgICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gICAgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSBhbGxvd2VkO1xuICB9O1xuXG5cbiAgdmFyIGVjbWE5QmluYXJ5UHJvcGVydGllcyA9IFwiQVNDSUkgQVNDSUlfSGV4X0RpZ2l0IEFIZXggQWxwaGFiZXRpYyBBbHBoYSBBbnkgQXNzaWduZWQgQmlkaV9Db250cm9sIEJpZGlfQyBCaWRpX01pcnJvcmVkIEJpZGlfTSBDYXNlX0lnbm9yYWJsZSBDSSBDYXNlZCBDaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZCBDV0NGIENoYW5nZXNfV2hlbl9DYXNlbWFwcGVkIENXQ00gQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWQgQ1dMIENoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWQgQ1dLQ0YgQ2hhbmdlc19XaGVuX1RpdGxlY2FzZWQgQ1dUIENoYW5nZXNfV2hlbl9VcHBlcmNhc2VkIENXVSBEYXNoIERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQgREkgRGVwcmVjYXRlZCBEZXAgRGlhY3JpdGljIERpYSBFbW9qaSBFbW9qaV9Db21wb25lbnQgRW1vamlfTW9kaWZpZXIgRW1vamlfTW9kaWZpZXJfQmFzZSBFbW9qaV9QcmVzZW50YXRpb24gRXh0ZW5kZXIgRXh0IEdyYXBoZW1lX0Jhc2UgR3JfQmFzZSBHcmFwaGVtZV9FeHRlbmQgR3JfRXh0IEhleF9EaWdpdCBIZXggSURTX0JpbmFyeV9PcGVyYXRvciBJRFNCIElEU19UcmluYXJ5X09wZXJhdG9yIElEU1QgSURfQ29udGludWUgSURDIElEX1N0YXJ0IElEUyBJZGVvZ3JhcGhpYyBJZGVvIEpvaW5fQ29udHJvbCBKb2luX0MgTG9naWNhbF9PcmRlcl9FeGNlcHRpb24gTE9FIExvd2VyY2FzZSBMb3dlciBNYXRoIE5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50IE5DaGFyIFBhdHRlcm5fU3ludGF4IFBhdF9TeW4gUGF0dGVybl9XaGl0ZV9TcGFjZSBQYXRfV1MgUXVvdGF0aW9uX01hcmsgUU1hcmsgUmFkaWNhbCBSZWdpb25hbF9JbmRpY2F0b3IgUkkgU2VudGVuY2VfVGVybWluYWwgU1Rlcm0gU29mdF9Eb3R0ZWQgU0QgVGVybWluYWxfUHVuY3R1YXRpb24gVGVybSBVbmlmaWVkX0lkZW9ncmFwaCBVSWRlbyBVcHBlcmNhc2UgVXBwZXIgVmFyaWF0aW9uX1NlbGVjdG9yIFZTIFdoaXRlX1NwYWNlIHNwYWNlIFhJRF9Db250aW51ZSBYSURDIFhJRF9TdGFydCBYSURTXCI7XG4gIHZhciBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTlCaW5hcnlQcm9wZXJ0aWVzICsgXCIgRXh0ZW5kZWRfUGljdG9ncmFwaGljXCI7XG4gIHZhciBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTEwQmluYXJ5UHJvcGVydGllcztcbiAgdmFyIHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzID0ge1xuICAgIDk6IGVjbWE5QmluYXJ5UHJvcGVydGllcyxcbiAgICAxMDogZWNtYTEwQmluYXJ5UHJvcGVydGllcyxcbiAgICAxMTogZWNtYTExQmluYXJ5UHJvcGVydGllc1xuICB9O1xuXG4gIHZhciB1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzID0gXCJDYXNlZF9MZXR0ZXIgTEMgQ2xvc2VfUHVuY3R1YXRpb24gUGUgQ29ubmVjdG9yX1B1bmN0dWF0aW9uIFBjIENvbnRyb2wgQ2MgY250cmwgQ3VycmVuY3lfU3ltYm9sIFNjIERhc2hfUHVuY3R1YXRpb24gUGQgRGVjaW1hbF9OdW1iZXIgTmQgZGlnaXQgRW5jbG9zaW5nX01hcmsgTWUgRmluYWxfUHVuY3R1YXRpb24gUGYgRm9ybWF0IENmIEluaXRpYWxfUHVuY3R1YXRpb24gUGkgTGV0dGVyIEwgTGV0dGVyX051bWJlciBObCBMaW5lX1NlcGFyYXRvciBabCBMb3dlcmNhc2VfTGV0dGVyIExsIE1hcmsgTSBDb21iaW5pbmdfTWFyayBNYXRoX1N5bWJvbCBTbSBNb2RpZmllcl9MZXR0ZXIgTG0gTW9kaWZpZXJfU3ltYm9sIFNrIE5vbnNwYWNpbmdfTWFyayBNbiBOdW1iZXIgTiBPcGVuX1B1bmN0dWF0aW9uIFBzIE90aGVyIEMgT3RoZXJfTGV0dGVyIExvIE90aGVyX051bWJlciBObyBPdGhlcl9QdW5jdHVhdGlvbiBQbyBPdGhlcl9TeW1ib2wgU28gUGFyYWdyYXBoX1NlcGFyYXRvciBacCBQcml2YXRlX1VzZSBDbyBQdW5jdHVhdGlvbiBQIHB1bmN0IFNlcGFyYXRvciBaIFNwYWNlX1NlcGFyYXRvciBacyBTcGFjaW5nX01hcmsgTWMgU3Vycm9nYXRlIENzIFN5bWJvbCBTIFRpdGxlY2FzZV9MZXR0ZXIgTHQgVW5hc3NpZ25lZCBDbiBVcHBlcmNhc2VfTGV0dGVyIEx1XCI7XG5cbiAgdmFyIGVjbWE5U2NyaXB0VmFsdWVzID0gXCJBZGxhbSBBZGxtIEFob20gQWhvbSBBbmF0b2xpYW5fSGllcm9nbHlwaHMgSGx1dyBBcmFiaWMgQXJhYiBBcm1lbmlhbiBBcm1uIEF2ZXN0YW4gQXZzdCBCYWxpbmVzZSBCYWxpIEJhbXVtIEJhbXUgQmFzc2FfVmFoIEJhc3MgQmF0YWsgQmF0ayBCZW5nYWxpIEJlbmcgQmhhaWtzdWtpIEJoa3MgQm9wb21vZm8gQm9wbyBCcmFobWkgQnJhaCBCcmFpbGxlIEJyYWkgQnVnaW5lc2UgQnVnaSBCdWhpZCBCdWhkIENhbmFkaWFuX0Fib3JpZ2luYWwgQ2FucyBDYXJpYW4gQ2FyaSBDYXVjYXNpYW5fQWxiYW5pYW4gQWdoYiBDaGFrbWEgQ2FrbSBDaGFtIENoYW0gQ2hlcm9rZWUgQ2hlciBDb21tb24gWnl5eSBDb3B0aWMgQ29wdCBRYWFjIEN1bmVpZm9ybSBYc3V4IEN5cHJpb3QgQ3BydCBDeXJpbGxpYyBDeXJsIERlc2VyZXQgRHNydCBEZXZhbmFnYXJpIERldmEgRHVwbG95YW4gRHVwbCBFZ3lwdGlhbl9IaWVyb2dseXBocyBFZ3lwIEVsYmFzYW4gRWxiYSBFdGhpb3BpYyBFdGhpIEdlb3JnaWFuIEdlb3IgR2xhZ29saXRpYyBHbGFnIEdvdGhpYyBHb3RoIEdyYW50aGEgR3JhbiBHcmVlayBHcmVrIEd1amFyYXRpIEd1anIgR3VybXVraGkgR3VydSBIYW4gSGFuaSBIYW5ndWwgSGFuZyBIYW51bm9vIEhhbm8gSGF0cmFuIEhhdHIgSGVicmV3IEhlYnIgSGlyYWdhbmEgSGlyYSBJbXBlcmlhbF9BcmFtYWljIEFybWkgSW5oZXJpdGVkIFppbmggUWFhaSBJbnNjcmlwdGlvbmFsX1BhaGxhdmkgUGhsaSBJbnNjcmlwdGlvbmFsX1BhcnRoaWFuIFBydGkgSmF2YW5lc2UgSmF2YSBLYWl0aGkgS3RoaSBLYW5uYWRhIEtuZGEgS2F0YWthbmEgS2FuYSBLYXlhaF9MaSBLYWxpIEtoYXJvc2h0aGkgS2hhciBLaG1lciBLaG1yIEtob2praSBLaG9qIEtodWRhd2FkaSBTaW5kIExhbyBMYW9vIExhdGluIExhdG4gTGVwY2hhIExlcGMgTGltYnUgTGltYiBMaW5lYXJfQSBMaW5hIExpbmVhcl9CIExpbmIgTGlzdSBMaXN1IEx5Y2lhbiBMeWNpIEx5ZGlhbiBMeWRpIE1haGFqYW5pIE1haGogTWFsYXlhbGFtIE1seW0gTWFuZGFpYyBNYW5kIE1hbmljaGFlYW4gTWFuaSBNYXJjaGVuIE1hcmMgTWFzYXJhbV9Hb25kaSBHb25tIE1lZXRlaV9NYXllayBNdGVpIE1lbmRlX0tpa2FrdWkgTWVuZCBNZXJvaXRpY19DdXJzaXZlIE1lcmMgTWVyb2l0aWNfSGllcm9nbHlwaHMgTWVybyBNaWFvIFBscmQgTW9kaSBNb2RpIE1vbmdvbGlhbiBNb25nIE1ybyBNcm9vIE11bHRhbmkgTXVsdCBNeWFubWFyIE15bXIgTmFiYXRhZWFuIE5iYXQgTmV3X1RhaV9MdWUgVGFsdSBOZXdhIE5ld2EgTmtvIE5rb28gTnVzaHUgTnNodSBPZ2hhbSBPZ2FtIE9sX0NoaWtpIE9sY2sgT2xkX0h1bmdhcmlhbiBIdW5nIE9sZF9JdGFsaWMgSXRhbCBPbGRfTm9ydGhfQXJhYmlhbiBOYXJiIE9sZF9QZXJtaWMgUGVybSBPbGRfUGVyc2lhbiBYcGVvIE9sZF9Tb3V0aF9BcmFiaWFuIFNhcmIgT2xkX1R1cmtpYyBPcmtoIE9yaXlhIE9yeWEgT3NhZ2UgT3NnZSBPc21hbnlhIE9zbWEgUGFoYXdoX0htb25nIEhtbmcgUGFsbXlyZW5lIFBhbG0gUGF1X0Npbl9IYXUgUGF1YyBQaGFnc19QYSBQaGFnIFBob2VuaWNpYW4gUGhueCBQc2FsdGVyX1BhaGxhdmkgUGhscCBSZWphbmcgUmpuZyBSdW5pYyBSdW5yIFNhbWFyaXRhbiBTYW1yIFNhdXJhc2h0cmEgU2F1ciBTaGFyYWRhIFNocmQgU2hhdmlhbiBTaGF3IFNpZGRoYW0gU2lkZCBTaWduV3JpdGluZyBTZ253IFNpbmhhbGEgU2luaCBTb3JhX1NvbXBlbmcgU29yYSBTb3lvbWJvIFNveW8gU3VuZGFuZXNlIFN1bmQgU3lsb3RpX05hZ3JpIFN5bG8gU3lyaWFjIFN5cmMgVGFnYWxvZyBUZ2xnIFRhZ2JhbndhIFRhZ2IgVGFpX0xlIFRhbGUgVGFpX1RoYW0gTGFuYSBUYWlfVmlldCBUYXZ0IFRha3JpIFRha3IgVGFtaWwgVGFtbCBUYW5ndXQgVGFuZyBUZWx1Z3UgVGVsdSBUaGFhbmEgVGhhYSBUaGFpIFRoYWkgVGliZXRhbiBUaWJ0IFRpZmluYWdoIFRmbmcgVGlyaHV0YSBUaXJoIFVnYXJpdGljIFVnYXIgVmFpIFZhaWkgV2FyYW5nX0NpdGkgV2FyYSBZaSBZaWlpIFphbmFiYXphcl9TcXVhcmUgWmFuYlwiO1xuICB2YXIgZWNtYTEwU2NyaXB0VmFsdWVzID0gZWNtYTlTY3JpcHRWYWx1ZXMgKyBcIiBEb2dyYSBEb2dyIEd1bmphbGFfR29uZGkgR29uZyBIYW5pZmlfUm9oaW5neWEgUm9oZyBNYWthc2FyIE1ha2EgTWVkZWZhaWRyaW4gTWVkZiBPbGRfU29nZGlhbiBTb2dvIFNvZ2RpYW4gU29nZFwiO1xuICB2YXIgZWNtYTExU2NyaXB0VmFsdWVzID0gZWNtYTEwU2NyaXB0VmFsdWVzICsgXCIgRWx5bWFpYyBFbHltIE5hbmRpbmFnYXJpIE5hbmQgTnlpYWtlbmdfUHVhY2h1ZV9IbW9uZyBIbW5wIFdhbmNobyBXY2hvXCI7XG4gIHZhciB1bmljb2RlU2NyaXB0VmFsdWVzID0ge1xuICAgIDk6IGVjbWE5U2NyaXB0VmFsdWVzLFxuICAgIDEwOiBlY21hMTBTY3JpcHRWYWx1ZXMsXG4gICAgMTE6IGVjbWExMVNjcmlwdFZhbHVlc1xuICB9O1xuXG4gIHZhciBkYXRhID0ge307XG4gIGZ1bmN0aW9uIGJ1aWxkVW5pY29kZURhdGEoZWNtYVZlcnNpb24pIHtcbiAgICB2YXIgZCA9IGRhdGFbZWNtYVZlcnNpb25dID0ge1xuICAgICAgYmluYXJ5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlQmluYXJ5UHJvcGVydGllc1tlY21hVmVyc2lvbl0gKyBcIiBcIiArIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgICAgbm9uQmluYXJ5OiB7XG4gICAgICAgIEdlbmVyYWxfQ2F0ZWdvcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgICAgICBTY3JpcHQ6IHdvcmRzUmVnZXhwKHVuaWNvZGVTY3JpcHRWYWx1ZXNbZWNtYVZlcnNpb25dKVxuICAgICAgfVxuICAgIH07XG4gICAgZC5ub25CaW5hcnkuU2NyaXB0X0V4dGVuc2lvbnMgPSBkLm5vbkJpbmFyeS5TY3JpcHQ7XG5cbiAgICBkLm5vbkJpbmFyeS5nYyA9IGQubm9uQmluYXJ5LkdlbmVyYWxfQ2F0ZWdvcnk7XG4gICAgZC5ub25CaW5hcnkuc2MgPSBkLm5vbkJpbmFyeS5TY3JpcHQ7XG4gICAgZC5ub25CaW5hcnkuc2N4ID0gZC5ub25CaW5hcnkuU2NyaXB0X0V4dGVuc2lvbnM7XG4gIH1cbiAgYnVpbGRVbmljb2RlRGF0YSg5KTtcbiAgYnVpbGRVbmljb2RlRGF0YSgxMCk7XG4gIGJ1aWxkVW5pY29kZURhdGEoMTEpO1xuXG4gIHZhciBwcCQ4ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICB2YXIgUmVnRXhwVmFsaWRhdGlvblN0YXRlID0gZnVuY3Rpb24gUmVnRXhwVmFsaWRhdGlvblN0YXRlKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMudmFsaWRGbGFncyA9IFwiZ2ltXCIgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IFwidXlcIiA6IFwiXCIpICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgPyBcInNcIiA6IFwiXCIpO1xuICAgIHRoaXMudW5pY29kZVByb3BlcnRpZXMgPSBkYXRhW3BhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExID8gMTEgOiBwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbl07XG4gICAgdGhpcy5zb3VyY2UgPSBcIlwiO1xuICAgIHRoaXMuZmxhZ3MgPSBcIlwiO1xuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuc3dpdGNoVSA9IGZhbHNlO1xuICAgIHRoaXMuc3dpdGNoTiA9IGZhbHNlO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgdGhpcy5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHRoaXMubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5udW1DYXB0dXJpbmdQYXJlbnMgPSAwO1xuICAgIHRoaXMubWF4QmFja1JlZmVyZW5jZSA9IDA7XG4gICAgdGhpcy5ncm91cE5hbWVzID0gW107XG4gICAgdGhpcy5iYWNrUmVmZXJlbmNlTmFtZXMgPSBbXTtcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKHN0YXJ0LCBwYXR0ZXJuLCBmbGFncykge1xuICAgIHZhciB1bmljb2RlID0gZmxhZ3MuaW5kZXhPZihcInVcIikgIT09IC0xO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydCB8IDA7XG4gICAgdGhpcy5zb3VyY2UgPSBwYXR0ZXJuICsgXCJcIjtcbiAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgdGhpcy5zd2l0Y2hVID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDY7XG4gICAgdGhpcy5zd2l0Y2hOID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDk7XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5yYWlzZSA9IGZ1bmN0aW9uIHJhaXNlIChtZXNzYWdlKSB7XG4gICAgdGhpcy5wYXJzZXIucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCAoXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogL1wiICsgKHRoaXMuc291cmNlKSArIFwiLzogXCIgKyBtZXNzYWdlKSk7XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0IChpLCBmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICBpZiAoaSA+PSBsKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKCEoZm9yY2VVIHx8IHRoaXMuc3dpdGNoVSkgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCkge1xuICAgICAgcmV0dXJuIGNcbiAgICB9XG4gICAgdmFyIG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgIHJldHVybiBuZXh0ID49IDB4REMwMCAmJiBuZXh0IDw9IDB4REZGRiA/IChjIDw8IDEwKSArIG5leHQgLSAweDM1RkRDMDAgOiBjXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5uZXh0SW5kZXggPSBmdW5jdGlvbiBuZXh0SW5kZXggKGksIGZvcmNlVSkge1xuICAgICAgaWYgKCBmb3JjZVUgPT09IHZvaWQgMCApIGZvcmNlVSA9IGZhbHNlO1xuXG4gICAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIGlmIChpID49IGwpIHtcbiAgICAgIHJldHVybiBsXG4gICAgfVxuICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpLCBuZXh0O1xuICAgIGlmICghKGZvcmNlVSB8fCB0aGlzLnN3aXRjaFUpIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwgfHxcbiAgICAgICAgKG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4REMwMCB8fCBuZXh0ID4gMHhERkZGKSB7XG4gICAgICByZXR1cm4gaSArIDFcbiAgICB9XG4gICAgcmV0dXJuIGkgKyAyXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCAoZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcy5hdCh0aGlzLnBvcywgZm9yY2VVKVxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubG9va2FoZWFkID0gZnVuY3Rpb24gbG9va2FoZWFkIChmb3JjZVUpIHtcbiAgICAgIGlmICggZm9yY2VVID09PSB2b2lkIDAgKSBmb3JjZVUgPSBmYWxzZTtcblxuICAgIHJldHVybiB0aGlzLmF0KHRoaXMubmV4dEluZGV4KHRoaXMucG9zLCBmb3JjZVUpLCBmb3JjZVUpXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gYWR2YW5jZSAoZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICB0aGlzLnBvcyA9IHRoaXMubmV4dEluZGV4KHRoaXMucG9zLCBmb3JjZVUpO1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gZWF0IChjaCwgZm9yY2VVKSB7XG4gICAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50KGZvcmNlVSkgPT09IGNoKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoZm9yY2VVKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nKGNoKSB7XG4gICAgaWYgKGNoIDw9IDB4RkZGRikgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaCkgfVxuICAgIGNoIC09IDB4MTAwMDA7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNoID4+IDEwKSArIDB4RDgwMCwgKGNoICYgMHgwM0ZGKSArIDB4REMwMClcbiAgfVxuXG4gIHBwJDgudmFsaWRhdGVSZWdFeHBGbGFncyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHZhbGlkRmxhZ3MgPSBzdGF0ZS52YWxpZEZsYWdzO1xuICAgIHZhciBmbGFncyA9IHN0YXRlLmZsYWdzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZsYWcgPSBmbGFncy5jaGFyQXQoaSk7XG4gICAgICBpZiAodmFsaWRGbGFncy5pbmRleE9mKGZsYWcpID09PSAtMSkge1xuICAgICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgICB9XG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZihmbGFnLCBpICsgMSkgPiAtMSkge1xuICAgICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHAkOC52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuXG4gICAgaWYgKCFzdGF0ZS5zd2l0Y2hOICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHN0YXRlLmdyb3VwTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGUuc3dpdGNoTiA9IHRydWU7XG4gICAgICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkOC5yZWdleHBfcGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUucG9zID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgICBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA9IDA7XG4gICAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLmxlbmd0aCA9IDA7XG5cbiAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucG9zICE9PSBzdGF0ZS5zb3VyY2UubGVuZ3RoKSB7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIlVubWF0Y2hlZCAnKSdcIik7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4NUQgKSB8fCBzdGF0ZS5lYXQoMHg3RCApKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGUubWF4QmFja1JlZmVyZW5jZSA+IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICAgIGlmIChzdGF0ZS5ncm91cE5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCBjYXB0dXJlIHJlZmVyZW5jZWRcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2Rpc2p1bmN0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gICAgd2hpbGUgKHN0YXRlLmVhdCgweDdDICkpIHtcbiAgICAgIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg3QiApKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkOC5yZWdleHBfYWx0ZXJuYXRpdmUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGF0ZS5zb3VyY2UubGVuZ3RoICYmIHRoaXMucmVnZXhwX2VhdFRlcm0oc3RhdGUpKVxuICAgICAgeyB9XG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0VGVybSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEFzc2VydGlvbihzdGF0ZSkpIHtcbiAgICAgIGlmIChzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgJiYgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSkpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcXVhbnRpZmllclwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSA/IHRoaXMucmVnZXhwX2VhdEF0b20oc3RhdGUpIDogdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tKHN0YXRlKSkge1xuICAgICAgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdEFzc2VydGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKHN0YXRlLmVhdCgweDVFICkgfHwgc3RhdGUuZWF0KDB4MjQgKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgKSkge1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDQyICkgfHwgc3RhdGUuZWF0KDB4NjIgKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmVhdCgweDI4ICkgJiYgc3RhdGUuZWF0KDB4M0YgKSkge1xuICAgICAgdmFyIGxvb2tiZWhpbmQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICBsb29rYmVoaW5kID0gc3RhdGUuZWF0KDB4M0MgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgzRCApIHx8IHN0YXRlLmVhdCgweDIxICkpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgICBpZiAoIXN0YXRlLmVhdCgweDI5ICkpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSAhbG9va2JlaGluZDtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgICBpZiAoIG5vRXJyb3IgPT09IHZvaWQgMCApIG5vRXJyb3IgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4KHN0YXRlLCBub0Vycm9yKSkge1xuICAgICAgc3RhdGUuZWF0KDB4M0YgKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXggPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICAgIHJldHVybiAoXG4gICAgICBzdGF0ZS5lYXQoMHgyQSApIHx8XG4gICAgICBzdGF0ZS5lYXQoMHgyQiApIHx8XG4gICAgICBzdGF0ZS5lYXQoMHgzRiApIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCBub0Vycm9yKVxuICAgIClcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg3QiApKSB7XG4gICAgICB2YXIgbWluID0gMCwgbWF4ID0gLTE7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgICAgbWluID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4MkMgKSAmJiB0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgICAgIG1heCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4N0QgKSkge1xuICAgICAgICAgIGlmIChtYXggIT09IC0xICYmIG1heCA8IG1pbiAmJiAhbm9FcnJvcikge1xuICAgICAgICAgICAgc3RhdGUucmFpc2UoXCJudW1iZXJzIG91dCBvZiBvcmRlciBpbiB7fSBxdWFudGlmaWVyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAhbm9FcnJvcikge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkluY29tcGxldGUgcXVhbnRpZmllclwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMoc3RhdGUpIHx8XG4gICAgICBzdGF0ZS5lYXQoMHgyRSApIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChzdGF0ZSlcbiAgICApXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0QXRvbUVzY2FwZShzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyOCApKSB7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4M0YgKSAmJiBzdGF0ZS5lYXQoMHgzQSApKSB7XG4gICAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDI5ICkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI4ICkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICB0aGlzLnJlZ2V4cF9ncm91cFNwZWNpZmllcihzdGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzRiApIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5ICkpIHtcbiAgICAgICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zICs9IDE7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgc3RhdGUuZWF0KDB4MkUgKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllcihzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlcihzdGF0ZSlcbiAgICApXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNTeW50YXhDaGFyYWN0ZXIoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2ggPT09IDB4MjQgIHx8XG4gICAgICBjaCA+PSAweDI4ICAmJiBjaCA8PSAweDJCICB8fFxuICAgICAgY2ggPT09IDB4MkUgIHx8XG4gICAgICBjaCA9PT0gMHgzRiAgfHxcbiAgICAgIGNoID49IDB4NUIgICYmIGNoIDw9IDB4NUUgIHx8XG4gICAgICBjaCA+PSAweDdCICAmJiBjaCA8PSAweDdEIFxuICAgIClcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gMDtcbiAgICB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSAhPT0gLTEgJiYgIWlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChcbiAgICAgIGNoICE9PSAtMSAmJlxuICAgICAgY2ggIT09IDB4MjQgICYmXG4gICAgICAhKGNoID49IDB4MjggICYmIGNoIDw9IDB4MkIgKSAmJlxuICAgICAgY2ggIT09IDB4MkUgICYmXG4gICAgICBjaCAhPT0gMHgzRiAgJiZcbiAgICAgIGNoICE9PSAweDVCICAmJlxuICAgICAgY2ggIT09IDB4NUUgICYmXG4gICAgICBjaCAhPT0gMHg3QyBcbiAgICApIHtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2dyb3VwU3BlY2lmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4M0YgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiRHVwbGljYXRlIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5ncm91cE5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdEdyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICBpZiAoc3RhdGUuZWF0KDB4M0MgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRSApKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2FwdHVyZSBncm91cCBuYW1lXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0KHN0YXRlKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgICB3aGlsZSAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGZvcmNlVSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMTtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KGZvcmNlVSk7XG4gICAgc3RhdGUuYWR2YW5jZShmb3JjZVUpO1xuXG4gICAgaWYgKGNoID09PSAweDVDICAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUsIGZvcmNlVSkpIHtcbiAgICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgcmV0dXJuIGlzSWRlbnRpZmllclN0YXJ0KGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAgfHwgY2ggPT09IDB4NUYgXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBmb3JjZVUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTE7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudChmb3JjZVUpO1xuICAgIHN0YXRlLmFkdmFuY2UoZm9yY2VVKTtcblxuICAgIGlmIChjaCA9PT0gMHg1QyAgJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlLCBmb3JjZVUpKSB7XG4gICAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgICByZXR1cm4gaXNJZGVudGlmaWVyQ2hhcihjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgIHx8IGNoID09PSAweDVGICB8fCBjaCA9PT0gMHgyMDBDICB8fCBjaCA9PT0gMHgyMDBEIFxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0QXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWdleHBfZWF0QmFja1JlZmVyZW5jZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgKHN0YXRlLnN3aXRjaE4gJiYgdGhpcy5yZWdleHBfZWF0S0dyb3VwTmFtZShzdGF0ZSkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg2MyApIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZShzdGF0ZSkpIHtcbiAgICAgIHZhciBuID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgaWYgKG4gPiBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlKSB7XG4gICAgICAgICAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChuIDw9IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRLR3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NkIgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCByZWZlcmVuY2VcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlcihzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFplcm8oc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSwgZmFsc2UpIHx8XG4gICAgICAoIXN0YXRlLnN3aXRjaFUgJiYgdGhpcy5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZShzdGF0ZSlcbiAgICApXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdENDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDYzICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRaZXJvID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDMwICAmJiAhaXNEZWNpbWFsRGlnaXQoc3RhdGUubG9va2FoZWFkKCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q29udHJvbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCA9PT0gMHg3NCApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDk7IFxuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDZFICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQTsgXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NzYgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBCOyBcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg2NiApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEM7IFxuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDcyICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwRDsgXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzQ29udHJvbExldHRlcihjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGNoID49IDB4NDEgICYmIGNoIDw9IDB4NUEgKSB8fFxuICAgICAgKGNoID49IDB4NjEgICYmIGNoIDw9IDB4N0EgKVxuICAgIClcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlLCBmb3JjZVUpIHtcbiAgICBpZiAoIGZvcmNlVSA9PT0gdm9pZCAwICkgZm9yY2VVID0gZmFsc2U7XG5cbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIHN3aXRjaFUgPSBmb3JjZVUgfHwgc3RhdGUuc3dpdGNoVTtcblxuICAgIGlmIChzdGF0ZS5lYXQoMHg3NSApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICAgIHZhciBsZWFkID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3dpdGNoVSAmJiBsZWFkID49IDB4RDgwMCAmJiBsZWFkIDw9IDB4REJGRikge1xuICAgICAgICAgIHZhciBsZWFkU3Vycm9nYXRlRW5kID0gc3RhdGUucG9zO1xuICAgICAgICAgIGlmIChzdGF0ZS5lYXQoMHg1QyApICYmIHN0YXRlLmVhdCgweDc1ICkgJiYgdGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICAgICAgICB2YXIgdHJhaWwgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgICAgICBpZiAodHJhaWwgPj0gMHhEQzAwICYmIHRyYWlsIDw9IDB4REZGRikge1xuICAgICAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAobGVhZCAtIDB4RDgwMCkgKiAweDQwMCArICh0cmFpbCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5wb3MgPSBsZWFkU3Vycm9nYXRlRW5kO1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGxlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgc3dpdGNoVSAmJlxuICAgICAgICBzdGF0ZS5lYXQoMHg3QiApICYmXG4gICAgICAgIHRoaXMucmVnZXhwX2VhdEhleERpZ2l0cyhzdGF0ZSkgJiZcbiAgICAgICAgc3RhdGUuZWF0KDB4N0QgKSAmJlxuICAgICAgICBpc1ZhbGlkVW5pY29kZShzdGF0ZS5sYXN0SW50VmFsdWUpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzd2l0Y2hVKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1ZhbGlkVW5pY29kZShjaCkge1xuICAgIHJldHVybiBjaCA+PSAwICYmIGNoIDw9IDB4MTBGRkZGXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MkYgKSkge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJGOyBcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggIT09IDB4NjMgICYmICghc3RhdGUuc3dpdGNoTiB8fCBjaCAhPT0gMHg2QiApKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoID49IDB4MzEgICYmIGNoIDw9IDB4MzkgKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCApO1xuICAgICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICB9IHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpID49IDB4MzAgICYmIGNoIDw9IDB4MzkgKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcblxuICAgIGlmIChpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gLTE7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHN0YXRlLnN3aXRjaFUgJiZcbiAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmXG4gICAgICAoY2ggPT09IDB4NTAgIHx8IGNoID09PSAweDcwIClcbiAgICApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IC0xO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgaWYgKFxuICAgICAgICBzdGF0ZS5lYXQoMHg3QiApICYmXG4gICAgICAgIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbihzdGF0ZSkgJiZcbiAgICAgICAgc3RhdGUuZWF0KDB4N0QgKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHg2NCAgfHxcbiAgICAgIGNoID09PSAweDQ0ICB8fFxuICAgICAgY2ggPT09IDB4NzMgIHx8XG4gICAgICBjaCA9PT0gMHg1MyAgfHxcbiAgICAgIGNoID09PSAweDc3ICB8fFxuICAgICAgY2ggPT09IDB4NTcgXG4gICAgKVxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0QgKSkge1xuICAgICAgdmFyIG5hbWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUoc3RhdGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlKSkge1xuICAgICAgdmFyIG5hbWVPclZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSwgbmFtZU9yVmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFoYXMoc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5LCBuYW1lKSlcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeVtuYW1lXS50ZXN0KHZhbHVlKSlcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IHZhbHVlXCIpOyB9XG4gIH07XG4gIHBwJDgucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZU9yVmFsdWUpIHtcbiAgICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLmJpbmFyeS50ZXN0KG5hbWVPclZhbHVlKSlcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgd2hpbGUgKGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbiAgfTtcbiAgZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIGlzQ29udHJvbExldHRlcihjaCkgfHwgY2ggPT09IDB4NUYgXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxuICB9O1xuICBmdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoKSB7XG4gICAgcmV0dXJuIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkgfHwgaXNEZWNpbWFsRGlnaXQoY2gpXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSlcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDVCICkpIHtcbiAgICAgIHN0YXRlLmVhdCgweDVFICk7XG4gICAgICB0aGlzLnJlZ2V4cF9jbGFzc1JhbmdlcyhzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4NUQgKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9jbGFzc1JhbmdlcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICAgIHZhciBsZWZ0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDJEICkgJiYgdGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgICAgICB2YXIgcmlnaHQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIChsZWZ0ID09PSAtMSB8fCByaWdodCA9PT0gLTEpKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCAhPT0gLTEgJiYgcmlnaHQgIT09IC0xICYmIGxlZnQgPiByaWdodCkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRDbGFzc0F0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NFc2NhcGUoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICB2YXIgY2gkMSA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICAgICAgaWYgKGNoJDEgPT09IDB4NjMgIHx8IGlzT2N0YWxEaWdpdChjaCQxKSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjbGFzcyBlc2NhcGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggIT09IDB4NUQgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q2xhc3NFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAgIGlmIChzdGF0ZS5lYXQoMHg2MiApKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA4OyBcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4MkQgKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRDsgXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICghc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHg2MyApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKVxuICAgIClcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNEZWNpbWFsRGlnaXQoY2gpIHx8IGNoID09PSAweDVGICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggJSAweDIwO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4NzggKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCAyKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCApO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxuICB9O1xuICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgIHJldHVybiBjaCA+PSAweDMwICAmJiBjaCA8PSAweDM5IFxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0SGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHdoaWxlIChpc0hleERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG4gIH07XG4gIGZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGNoID49IDB4MzAgICYmIGNoIDw9IDB4MzkgKSB8fFxuICAgICAgKGNoID49IDB4NDEgICYmIGNoIDw9IDB4NDYgKSB8fFxuICAgICAgKGNoID49IDB4NjEgICYmIGNoIDw9IDB4NjYgKVxuICAgIClcbiAgfVxuICBmdW5jdGlvbiBoZXhUb0ludChjaCkge1xuICAgIGlmIChjaCA+PSAweDQxICAmJiBjaCA8PSAweDQ2ICkge1xuICAgICAgcmV0dXJuIDEwICsgKGNoIC0gMHg0MSApXG4gICAgfVxuICAgIGlmIChjaCA+PSAweDYxICAmJiBjaCA8PSAweDY2ICkge1xuICAgICAgcmV0dXJuIDEwICsgKGNoIC0gMHg2MSApXG4gICAgfVxuICAgIHJldHVybiBjaCAtIDB4MzAgXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgIHZhciBuMSA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgICB2YXIgbjIgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIGlmIChuMSA8PSAzICYmIHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA2NCArIG4yICogOCArIHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDggKyBuMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRPY3RhbERpZ2l0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoIC0gMHgzMDsgXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gMHgzMCAgJiYgY2ggPD0gMHgzNyBcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUsIGxlbmd0aCkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cblxuICB2YXIgVG9rZW4gPSBmdW5jdGlvbiBUb2tlbihwKSB7XG4gICAgdGhpcy50eXBlID0gcC50eXBlO1xuICAgIHRoaXMudmFsdWUgPSBwLnZhbHVlO1xuICAgIHRoaXMuc3RhcnQgPSBwLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gcC5lbmQ7XG4gICAgaWYgKHAub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHAsIHAuc3RhcnRMb2MsIHAuZW5kTG9jKTsgfVxuICAgIGlmIChwLm9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyB0aGlzLnJhbmdlID0gW3Auc3RhcnQsIHAuZW5kXTsgfVxuICB9O1xuXG5cbiAgdmFyIHBwJDkgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5cbiAgcHAkOS5uZXh0ID0gZnVuY3Rpb24oaWdub3JlRXNjYXBlU2VxdWVuY2VJbktleXdvcmQpIHtcbiAgICBpZiAoIWlnbm9yZUVzY2FwZVNlcXVlbmNlSW5LZXl3b3JkICYmIHRoaXMudHlwZS5rZXl3b3JkICYmIHRoaXMuY29udGFpbnNFc2MpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIFwiICsgdGhpcy50eXBlLmtleXdvcmQpOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vblRva2VuKVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25Ub2tlbihuZXcgVG9rZW4odGhpcykpOyB9XG5cbiAgICB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLmVuZDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgdGhpcy5sYXN0VG9rRW5kTG9jID0gdGhpcy5lbmRMb2M7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gIH07XG5cbiAgcHAkOS5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiBuZXcgVG9rZW4odGhpcylcbiAgfTtcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICB7IHBwJDlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzJDEuZ2V0VG9rZW4oKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdG9rZW4udHlwZSA9PT0gdHlwZXMuZW9mLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgfVxuXG5cbiAgcHAkOS5jdXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dFt0aGlzLmNvbnRleHQubGVuZ3RoIC0gMV1cbiAgfTtcblxuXG4gIHBwJDkubmV4dFRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1ckNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAoIWN1ckNvbnRleHQgfHwgIWN1ckNvbnRleHQucHJlc2VydmVTcGFjZSkgeyB0aGlzLnNraXBTcGFjZSgpOyB9XG5cbiAgICB0aGlzLnN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5zdGFydExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5lb2YpIH1cblxuICAgIGlmIChjdXJDb250ZXh0Lm92ZXJyaWRlKSB7IHJldHVybiBjdXJDb250ZXh0Lm92ZXJyaWRlKHRoaXMpIH1cbiAgICBlbHNlIHsgdGhpcy5yZWFkVG9rZW4odGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKTsgfVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuID0gZnVuY3Rpb24oY29kZSkge1xuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgfHwgY29kZSA9PT0gOTIgKVxuICAgICAgeyByZXR1cm4gdGhpcy5yZWFkV29yZCgpIH1cblxuICAgIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY29kZSlcbiAgfTtcblxuICBwcCQ5LmZ1bGxDaGFyQ29kZUF0UG9zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmIChjb2RlIDw9IDB4ZDdmZiB8fCBjb2RlID49IDB4ZTAwMCkgeyByZXR1cm4gY29kZSB9XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICByZXR1cm4gKGNvZGUgPDwgMTApICsgbmV4dCAtIDB4MzVmZGMwMFxuICB9O1xuXG4gIHBwJDkuc2tpcEJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpO1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zLCBlbmQgPSB0aGlzLmlucHV0LmluZGV4T2YoXCIqL1wiLCB0aGlzLnBvcyArPSAyKTtcbiAgICBpZiAoZW5kID09PSAtMSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zIC0gMiwgXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKTsgfVxuICAgIHRoaXMucG9zID0gZW5kICsgMjtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWtHLmV4ZWModGhpcy5pbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgdGhpcy5wb3MpIHtcbiAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KHRydWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG4gIH07XG5cbiAgcHAkOS5za2lwTGluZUNvbW1lbnQgPSBmdW5jdGlvbihzdGFydFNraXApIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKz0gc3RhcnRTa2lwKTtcbiAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNOZXdMaW5lKGNoKSkge1xuICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KGZhbHNlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCB0aGlzLnBvcyksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbiAgfTtcblxuXG4gIHBwJDkuc2tpcFNwYWNlID0gZnVuY3Rpb24oKSB7XG4gICAgbG9vcDogd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICBjYXNlIDMyOiBjYXNlIDE2MDogXG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDEzOlxuICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEwKSB7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMDogY2FzZSA4MjMyOiBjYXNlIDgyMzM6XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0NzogXG4gICAgICAgIHN3aXRjaCAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkpIHtcbiAgICAgICAgY2FzZSA0MjogXG4gICAgICAgICAgdGhpcy5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrIGxvb3BcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNoID4gOCAmJiBjaCA8IDE0IHx8IGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICBwcCQ5LmZpbmlzaFRva2VuID0gZnVuY3Rpb24odHlwZSwgdmFsKSB7XG4gICAgdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTsgfVxuICAgIHZhciBwcmV2VHlwZSA9IHRoaXMudHlwZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbnRleHQocHJldlR5cGUpO1xuICB9O1xuXG5cbiAgcHAkOS5yZWFkVG9rZW5fZG90ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSB7IHJldHVybiB0aGlzLnJlYWROdW1iZXIodHJ1ZSkgfVxuICAgIHZhciBuZXh0MiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHsgXG4gICAgICB0aGlzLnBvcyArPSAzO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZWxsaXBzaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5kb3QpXG4gICAgfVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX3NsYXNoID0gZnVuY3Rpb24oKSB7IFxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKHRoaXMuZXhwckFsbG93ZWQpIHsgKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMucmVhZFJlZ2V4cCgpIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuc2xhc2gsIDEpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwID0gZnVuY3Rpb24oY29kZSkgeyBcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIHZhciBzaXplID0gMTtcbiAgICB2YXIgdG9rZW50eXBlID0gY29kZSA9PT0gNDIgPyB0eXBlcy5zdGFyIDogdHlwZXMubW9kdWxvO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmIGNvZGUgPT09IDQyICYmIG5leHQgPT09IDQyKSB7XG4gICAgICArK3NpemU7XG4gICAgICB0b2tlbnR5cGUgPSB0eXBlcy5zdGFyc3RhcjtcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSkgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHRva2VudHlwZSwgc2l6ZSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uKGNvZGUpIHsgXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMikge1xuICAgICAgICB2YXIgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICAgICAgaWYgKG5leHQyID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDMpIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmxvZ2ljYWxPUiA6IHR5cGVzLmxvZ2ljYWxBTkQsIDIpXG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcy5iaXR3aXNlT1IgOiB0eXBlcy5iaXR3aXNlQU5ELCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX2NhcmV0ID0gZnVuY3Rpb24oKSB7IFxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdHdpc2VYT1IsIDEpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fcGx1c19taW4gPSBmdW5jdGlvbihjb2RlKSB7IFxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIGlmIChuZXh0ID09PSA0NSAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgJiZcbiAgICAgICAgICAodGhpcy5sYXN0VG9rRW5kID09PSAwIHx8IGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnBvcykpKSkge1xuICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgzKTtcbiAgICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmluY0RlYywgMilcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnBsdXNNaW4sIDEpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fbHRfZ3QgPSBmdW5jdGlvbihjb2RlKSB7IFxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgdmFyIHNpemUgPSAxO1xuICAgIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgICBzaXplID0gY29kZSA9PT0gNjIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyID8gMyA6IDI7XG4gICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgc2l6ZSkgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdFNoaWZ0LCBzaXplKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gMzMgJiYgY29kZSA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDQ1ICYmXG4gICAgICAgIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDMpID09PSA0NSkge1xuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHNpemUgPSAyOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucmVsYXRpb25hbCwgc2l6ZSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9lcV9leGNsID0gZnVuY3Rpb24oY29kZSkgeyBcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5lcXVhbGl0eSwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYxID8gMyA6IDIpIH1cbiAgICBpZiAoY29kZSA9PT0gNjEgJiYgbmV4dCA9PT0gNjIgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgXG4gICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYXJyb3cpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYxID8gdHlwZXMuZXEgOiB0eXBlcy5wcmVmaXgsIDEpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fcXVlc3Rpb24gPSBmdW5jdGlvbigpIHsgXG4gICAgdmFyIGVjbWFWZXJzaW9uID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uO1xuICAgIGlmIChlY21hVmVyc2lvbiA+PSAxMSkge1xuICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICAgIGlmIChuZXh0ID09PSA0Nikge1xuICAgICAgICB2YXIgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgICAgICAgaWYgKG5leHQyIDwgNDggfHwgbmV4dDIgPiA1NykgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5xdWVzdGlvbkRvdCwgMikgfVxuICAgICAgfVxuICAgICAgaWYgKG5leHQgPT09IDYzKSB7XG4gICAgICAgIGlmIChlY21hVmVyc2lvbiA+PSAxMikge1xuICAgICAgICAgIHZhciBuZXh0MiQxID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgICAgICAgaWYgKG5leHQyJDEgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMykgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmNvYWxlc2NlLCAyKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5xdWVzdGlvbiwgMSlcbiAgfTtcblxuICBwcCQ5LmdldFRva2VuRnJvbUNvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSA0NjogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZG90KClcblxuICAgIGNhc2UgNDA6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnBhcmVuTClcbiAgICBjYXNlIDQxOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5wYXJlblIpXG4gICAgY2FzZSA1OTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc2VtaSlcbiAgICBjYXNlIDQ0OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5jb21tYSlcbiAgICBjYXNlIDkxOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0TClcbiAgICBjYXNlIDkzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0UilcbiAgICBjYXNlIDEyMzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VMKVxuICAgIGNhc2UgMTI1OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZVIpXG4gICAgY2FzZSA1ODogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29sb24pXG5cbiAgICBjYXNlIDk2OiBcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IGJyZWFrIH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG5cbiAgICBjYXNlIDQ4OiBcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigxNikgfSBcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgICBpZiAobmV4dCA9PT0gMTExIHx8IG5leHQgPT09IDc5KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcig4KSB9IFxuICAgICAgICBpZiAobmV4dCA9PT0gOTggfHwgbmV4dCA9PT0gNjYpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDIpIH0gXG4gICAgICB9XG5cbiAgICBjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOiBjYXNlIDU0OiBjYXNlIDU1OiBjYXNlIDU2OiBjYXNlIDU3OiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWROdW1iZXIoZmFsc2UpXG5cbiAgICBjYXNlIDM0OiBjYXNlIDM5OiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoY29kZSlcblxuXG4gICAgY2FzZSA0NzogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fc2xhc2goKVxuXG4gICAgY2FzZSAzNzogY2FzZSA0MjogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwKGNvZGUpXG5cbiAgICBjYXNlIDEyNDogY2FzZSAzODogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSlcblxuICAgIGNhc2UgOTQ6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2NhcmV0KClcblxuICAgIGNhc2UgNDM6IGNhc2UgNDU6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BsdXNfbWluKGNvZGUpXG5cbiAgICBjYXNlIDYwOiBjYXNlIDYyOiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9sdF9ndChjb2RlKVxuXG4gICAgY2FzZSA2MTogY2FzZSAzMzogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZXFfZXhjbChjb2RlKVxuXG4gICAgY2FzZSA2MzogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcXVlc3Rpb24oKVxuXG4gICAgY2FzZSAxMjY6IFxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucHJlZml4LCAxKVxuICAgIH1cblxuICAgIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmckMShjb2RlKSArIFwiJ1wiKTtcbiAgfTtcblxuICBwcCQ5LmZpbmlzaE9wID0gZnVuY3Rpb24odHlwZSwgc2l6ZSkge1xuICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIHNpemUpO1xuICAgIHRoaXMucG9zICs9IHNpemU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKVxuICB9O1xuXG4gIHBwJDkucmVhZFJlZ2V4cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgIGlmIChsaW5lQnJlYWsudGVzdChjaCkpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgICAgaWYgKGNoID09PSBcIltcIikgeyBpbkNsYXNzID0gdHJ1ZTsgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gXCJdXCIgJiYgaW5DbGFzcykgeyBpbkNsYXNzID0gZmFsc2U7IH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiL1wiICYmICFpbkNsYXNzKSB7IGJyZWFrIH1cbiAgICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICAgIH0gZWxzZSB7IGVzY2FwZWQgPSBmYWxzZTsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICB9XG4gICAgdmFyIHBhdHRlcm4gPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICB2YXIgZmxhZ3NTdGFydCA9IHRoaXMucG9zO1xuICAgIHZhciBmbGFncyA9IHRoaXMucmVhZFdvcmQxKCk7XG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy51bmV4cGVjdGVkKGZsYWdzU3RhcnQpOyB9XG5cbiAgICB2YXIgc3RhdGUgPSB0aGlzLnJlZ2V4cFN0YXRlIHx8ICh0aGlzLnJlZ2V4cFN0YXRlID0gbmV3IFJlZ0V4cFZhbGlkYXRpb25TdGF0ZSh0aGlzKSk7XG4gICAgc3RhdGUucmVzZXQoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKTtcbiAgICB0aGlzLnZhbGlkYXRlUmVnRXhwRmxhZ3Moc3RhdGUpO1xuICAgIHRoaXMudmFsaWRhdGVSZWdFeHBQYXR0ZXJuKHN0YXRlKTtcblxuICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnJlZ2V4cCwge3BhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncywgdmFsdWU6IHZhbHVlfSlcbiAgfTtcblxuXG4gIHBwJDkucmVhZEludCA9IGZ1bmN0aW9uKHJhZGl4LCBsZW4sIG1heWJlTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAgIHZhciBhbGxvd1NlcGFyYXRvcnMgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTIgJiYgbGVuID09PSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsID0gbWF5YmVMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDQ4O1xuXG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIHRvdGFsID0gMCwgbGFzdENvZGUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSwgKyt0aGlzLnBvcykge1xuICAgICAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLCB2YWwgPSAodm9pZCAwKTtcblxuICAgICAgaWYgKGFsbG93U2VwYXJhdG9ycyAmJiBjb2RlID09PSA5NSkge1xuICAgICAgICBpZiAoaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywgXCJOdW1lcmljIHNlcGFyYXRvciBpcyBub3QgYWxsb3dlZCBpbiBsZWdhY3kgb2N0YWwgbnVtZXJpYyBsaXRlcmFsc1wiKTsgfVxuICAgICAgICBpZiAobGFzdENvZGUgPT09IDk1KSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywgXCJOdW1lcmljIHNlcGFyYXRvciBtdXN0IGJlIGV4YWN0bHkgb25lIHVuZGVyc2NvcmVcIik7IH1cbiAgICAgICAgaWYgKGkgPT09IDApIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zLCBcIk51bWVyaWMgc2VwYXJhdG9yIGlzIG5vdCBhbGxvd2VkIGF0IHRoZSBmaXJzdCBvZiBkaWdpdHNcIik7IH1cbiAgICAgICAgbGFzdENvZGUgPSBjb2RlO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoY29kZSA+PSA5NykgeyB2YWwgPSBjb2RlIC0gOTcgKyAxMDsgfSBcbiAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNjUpIHsgdmFsID0gY29kZSAtIDY1ICsgMTA7IH0gXG4gICAgICBlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHsgdmFsID0gY29kZSAtIDQ4OyB9IFxuICAgICAgZWxzZSB7IHZhbCA9IEluZmluaXR5OyB9XG4gICAgICBpZiAodmFsID49IHJhZGl4KSB7IGJyZWFrIH1cbiAgICAgIGxhc3RDb2RlID0gY29kZTtcbiAgICAgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbDtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dTZXBhcmF0b3JzICYmIGxhc3RDb2RlID09PSA5NSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MgLSAxLCBcIk51bWVyaWMgc2VwYXJhdG9yIGlzIG5vdCBhbGxvd2VkIGF0IHRoZSBsYXN0IG9mIGRpZ2l0c1wiKTsgfVxuICAgIGlmICh0aGlzLnBvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgdGhpcy5wb3MgLSBzdGFydCAhPT0gbGVuKSB7IHJldHVybiBudWxsIH1cblxuICAgIHJldHVybiB0b3RhbFxuICB9O1xuXG4gIGZ1bmN0aW9uIHN0cmluZ1RvTnVtYmVyKHN0ciwgaXNMZWdhY3lPY3RhbE51bWVyaWNMaXRlcmFsKSB7XG4gICAgaWYgKGlzTGVnYWN5T2N0YWxOdW1lcmljTGl0ZXJhbCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgOClcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCBcIlwiKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQmlnSW50KHN0cikge1xuICAgIGlmICh0eXBlb2YgQmlnSW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIEJpZ0ludChzdHIucmVwbGFjZSgvXy9nLCBcIlwiKSlcbiAgfVxuXG4gIHBwJDkucmVhZFJhZGl4TnVtYmVyID0gZnVuY3Rpb24ocmFkaXgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICB0aGlzLnBvcyArPSAyOyBcbiAgICB2YXIgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcbiAgICBpZiAodmFsID09IG51bGwpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0ICsgMiwgXCJFeHBlY3RlZCBudW1iZXIgaW4gcmFkaXggXCIgKyByYWRpeCk7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDExMCkge1xuICAgICAgdmFsID0gc3RyaW5nVG9CaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbClcbiAgfTtcblxuXG4gIHBwJDkucmVhZE51bWJlciA9IGZ1bmN0aW9uKHN0YXJ0c1dpdGhEb3QpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5yZWFkSW50KDEwLCB1bmRlZmluZWQsIHRydWUpID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB2YXIgb2N0YWwgPSB0aGlzLnBvcyAtIHN0YXJ0ID49IDIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gNDg7XG4gICAgaWYgKG9jdGFsICYmIHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKCFvY3RhbCAmJiAhc3RhcnRzV2l0aERvdCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgbmV4dCA9PT0gMTEwKSB7XG4gICAgICB2YXIgdmFsJDEgPSBzdHJpbmdUb0JpZ0ludCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsJDEpXG4gICAgfVxuICAgIGlmIChvY3RhbCAmJiAvWzg5XS8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpKSB7IG9jdGFsID0gZmFsc2U7IH1cbiAgICBpZiAobmV4dCA9PT0gNDYgJiYgIW9jdGFsKSB7IFxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICB9XG4gICAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkgeyBcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpIHsgKyt0aGlzLnBvczsgfSBcbiAgICAgIGlmICh0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB9XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuXG4gICAgdmFyIHZhbCA9IHN0cmluZ1RvTnVtYmVyKHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSwgb2N0YWwpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsKVxuICB9O1xuXG5cbiAgcHAkOS5yZWFkQ29kZVBvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgY29kZTtcblxuICAgIGlmIChjaCA9PT0gMTIzKSB7IFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnBvcztcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKHRoaXMuaW5wdXQuaW5kZXhPZihcIn1cIiwgdGhpcy5wb3MpIC0gdGhpcy5wb3MpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHNcIik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIoNCk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH07XG5cbiAgZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmckMShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIH1cbiAgICBjb2RlIC09IDB4MTAwMDA7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhEODAwLCAoY29kZSAmIDEwMjMpICsgMHhEQzAwKVxuICB9XG5cbiAgcHAkOS5yZWFkU3RyaW5nID0gZnVuY3Rpb24ocXVvdGUpIHtcbiAgICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9ICsrdGhpcy5wb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKGNoID09PSBxdW90ZSkgeyBicmVhayB9XG4gICAgICBpZiAoY2ggPT09IDkyKSB7IFxuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcihmYWxzZSk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc05ld0xpbmUoY2gsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMCkpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MrKyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc3RyaW5nLCBvdXQpXG4gIH07XG5cblxuICB2YXIgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IgPSB7fTtcblxuICBwcCQ5LnRyeVJlYWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVhZFRtcGxUb2tlbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciA9PT0gSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IpIHtcbiAgICAgICAgdGhpcy5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSBmYWxzZTtcbiAgfTtcblxuICBwcCQ5LmludmFsaWRTdHJpbmdUb2tlbiA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIHRocm93IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmFpc2UocG9zaXRpb24sIG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ5LnJlYWRUbXBsVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpOyB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKGNoID09PSA5NiB8fCBjaCA9PT0gMzYgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEyMykgeyBcbiAgICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLnN0YXJ0ICYmICh0aGlzLnR5cGUgPT09IHR5cGVzLnRlbXBsYXRlIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuaW52YWxpZFRlbXBsYXRlKSkge1xuICAgICAgICAgIGlmIChjaCA9PT0gMzYpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5kb2xsYXJCcmFjZUwpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMudGVtcGxhdGUsIG91dClcbiAgICAgIH1cbiAgICAgIGlmIChjaCA9PT0gOTIpIHsgXG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKHRydWUpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9IGVsc2UgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH1cbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBvdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgfVxuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwcCQ5LnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAoOyB0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoOyB0aGlzLnBvcysrKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuaW5wdXRbdGhpcy5wb3NdKSB7XG4gICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiJFwiOlxuICAgICAgICBpZiAodGhpcy5pbnB1dFt0aGlzLnBvcyArIDFdICE9PSBcIntcIikge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImBcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuaW52YWxpZFRlbXBsYXRlLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKSlcblxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpO1xuICB9O1xuXG5cbiAgcHAkOS5yZWFkRXNjYXBlZENoYXIgPSBmdW5jdGlvbihpblRlbXBsYXRlKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgICsrdGhpcy5wb3M7XG4gICAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMTEwOiByZXR1cm4gXCJcXG5cIiBcbiAgICBjYXNlIDExNDogcmV0dXJuIFwiXFxyXCIgXG4gICAgY2FzZSAxMjA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEhleENoYXIoMikpIFxuICAgIGNhc2UgMTE3OiByZXR1cm4gY29kZVBvaW50VG9TdHJpbmckMSh0aGlzLnJlYWRDb2RlUG9pbnQoKSkgXG4gICAgY2FzZSAxMTY6IHJldHVybiBcIlxcdFwiIFxuICAgIGNhc2UgOTg6IHJldHVybiBcIlxcYlwiIFxuICAgIGNhc2UgMTE4OiByZXR1cm4gXCJcXHUwMDBiXCIgXG4gICAgY2FzZSAxMDI6IHJldHVybiBcIlxcZlwiIFxuICAgIGNhc2UgMTM6IGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9IFxuICAgIGNhc2UgMTA6IFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvczsgKyt0aGlzLmN1ckxpbmU7IH1cbiAgICAgIHJldHVybiBcIlwiXG4gICAgY2FzZSA1NjpcbiAgICBjYXNlIDU3OlxuICAgICAgaWYgKGluVGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcyAtIDE7XG5cbiAgICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgICAgY29kZVBvcyxcbiAgICAgICAgICBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlIHN0cmluZ1wiXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNoID49IDQ4ICYmIGNoIDw9IDU1KSB7XG4gICAgICAgIHZhciBvY3RhbFN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKVswXTtcbiAgICAgICAgdmFyIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICBpZiAob2N0YWwgPiAyNTUpIHtcbiAgICAgICAgICBvY3RhbFN0ciA9IG9jdGFsU3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBvY3RhbFN0ci5sZW5ndGggLSAxO1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICgob2N0YWxTdHIgIT09IFwiMFwiIHx8IGNoID09PSA1NiB8fCBjaCA9PT0gNTcpICYmICh0aGlzLnN0cmljdCB8fCBpblRlbXBsYXRlKSkge1xuICAgICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgICAgdGhpcy5wb3MgLSAxIC0gb2N0YWxTdHIubGVuZ3RoLFxuICAgICAgICAgICAgaW5UZW1wbGF0ZVxuICAgICAgICAgICAgICA/IFwiT2N0YWwgbGl0ZXJhbCBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgICAgICAgICA6IFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbClcbiAgICAgIH1cbiAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIHJldHVybiBcIlwiXG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaClcbiAgICB9XG4gIH07XG5cblxuICBwcCQ5LnJlYWRIZXhDaGFyID0gZnVuY3Rpb24obGVuKSB7XG4gICAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcztcbiAgICB2YXIgbiA9IHRoaXMucmVhZEludCgxNiwgbGVuKTtcbiAgICBpZiAobiA9PT0gbnVsbCkgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpOyB9XG4gICAgcmV0dXJuIG5cbiAgfTtcblxuXG4gIHBwJDkucmVhZFdvcmQxID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuICAgIHZhciB3b3JkID0gXCJcIiwgZmlyc3QgPSB0cnVlLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdmFyIGFzdHJhbCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICAgIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCwgYXN0cmFsKSkge1xuICAgICAgICB0aGlzLnBvcyArPSBjaCA8PSAweGZmZmYgPyAxIDogMjtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7IFxuICAgICAgICB0aGlzLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgdmFyIGVzY1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcykgIT09IDExNykgXG4gICAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbih0aGlzLnBvcywgXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIpOyB9XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIHZhciBlc2MgPSB0aGlzLnJlYWRDb2RlUG9pbnQoKTtcbiAgICAgICAgaWYgKCEoZmlyc3QgPyBpc0lkZW50aWZpZXJTdGFydCA6IGlzSWRlbnRpZmllckNoYXIpKGVzYywgYXN0cmFsKSlcbiAgICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGVzY1N0YXJ0LCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7IH1cbiAgICAgICAgd29yZCArPSBjb2RlUG9pbnRUb1N0cmluZyQxKGVzYyk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpXG4gIH07XG5cblxuICBwcCQ5LnJlYWRXb3JkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdvcmQgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICAgIHZhciB0eXBlID0gdHlwZXMubmFtZTtcbiAgICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KHdvcmQpKSB7XG4gICAgICB0eXBlID0ga2V5d29yZHMkMVt3b3JkXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgd29yZClcbiAgfTtcblxuXG4gIHZhciB2ZXJzaW9uID0gXCI3LjQuMFwiO1xuXG4gIFBhcnNlci5hY29ybiA9IHtcbiAgICBQYXJzZXI6IFBhcnNlcixcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9ucyxcbiAgICBQb3NpdGlvbjogUG9zaXRpb24sXG4gICAgU291cmNlTG9jYXRpb246IFNvdXJjZUxvY2F0aW9uLFxuICAgIGdldExpbmVJbmZvOiBnZXRMaW5lSW5mbyxcbiAgICBOb2RlOiBOb2RlLFxuICAgIFRva2VuVHlwZTogVG9rZW5UeXBlLFxuICAgIHRva1R5cGVzOiB0eXBlcyxcbiAgICBrZXl3b3JkVHlwZXM6IGtleXdvcmRzJDEsXG4gICAgVG9rQ29udGV4dDogVG9rQ29udGV4dCxcbiAgICB0b2tDb250ZXh0czogdHlwZXMkMSxcbiAgICBpc0lkZW50aWZpZXJDaGFyOiBpc0lkZW50aWZpZXJDaGFyLFxuICAgIGlzSWRlbnRpZmllclN0YXJ0OiBpc0lkZW50aWZpZXJTdGFydCxcbiAgICBUb2tlbjogVG9rZW4sXG4gICAgaXNOZXdMaW5lOiBpc05ld0xpbmUsXG4gICAgbGluZUJyZWFrOiBsaW5lQnJlYWssXG4gICAgbGluZUJyZWFrRzogbGluZUJyZWFrRyxcbiAgICBub25BU0NJSXdoaXRlc3BhY2U6IG5vbkFTQ0lJd2hpdGVzcGFjZVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUGFyc2VyLnBhcnNlKGlucHV0LCBvcHRpb25zKVxuICB9XG5cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKVxuICB9XG5cblxuICBmdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUGFyc2VyLnRva2VuaXplcihpbnB1dCwgb3B0aW9ucylcbiAgfVxuXG4gIGV4cG9ydHMuTm9kZSA9IE5vZGU7XG4gIGV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuICBleHBvcnRzLlBvc2l0aW9uID0gUG9zaXRpb247XG4gIGV4cG9ydHMuU291cmNlTG9jYXRpb24gPSBTb3VyY2VMb2NhdGlvbjtcbiAgZXhwb3J0cy5Ub2tDb250ZXh0ID0gVG9rQ29udGV4dDtcbiAgZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xuICBleHBvcnRzLlRva2VuVHlwZSA9IFRva2VuVHlwZTtcbiAgZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICBleHBvcnRzLmdldExpbmVJbmZvID0gZ2V0TGluZUluZm87XG4gIGV4cG9ydHMuaXNJZGVudGlmaWVyQ2hhciA9IGlzSWRlbnRpZmllckNoYXI7XG4gIGV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBpc0lkZW50aWZpZXJTdGFydDtcbiAgZXhwb3J0cy5pc05ld0xpbmUgPSBpc05ld0xpbmU7XG4gIGV4cG9ydHMua2V5d29yZFR5cGVzID0ga2V5d29yZHMkMTtcbiAgZXhwb3J0cy5saW5lQnJlYWsgPSBsaW5lQnJlYWs7XG4gIGV4cG9ydHMubGluZUJyZWFrRyA9IGxpbmVCcmVha0c7XG4gIGV4cG9ydHMubm9uQVNDSUl3aGl0ZXNwYWNlID0gbm9uQVNDSUl3aGl0ZXNwYWNlO1xuICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG4gIGV4cG9ydHMucGFyc2VFeHByZXNzaW9uQXQgPSBwYXJzZUV4cHJlc3Npb25BdDtcbiAgZXhwb3J0cy50b2tDb250ZXh0cyA9IHR5cGVzJDE7XG4gIGV4cG9ydHMudG9rVHlwZXMgPSB0eXBlcztcbiAgZXhwb3J0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gIGV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcblxufSx7fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbn0se31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuZnVuY3Rpb24gZ2xXaXJldGFwKGdsLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGNvbnRleHROYW1lID0gJ2dsJyxcbiAgICB0aHJvd0dldEVycm9yLFxuICAgIHVzZVRyYWNrYWJsZVByaW1pdGl2ZXMsXG4gICAgcmVhZFBpeGVsc0ZpbGUsXG4gICAgcmVjb3JkaW5nID0gW10sXG4gICAgdmFyaWFibGVzID0ge30sXG4gICAgb25SZWFkUGl4ZWxzLFxuICAgIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAsXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShnbCwgeyBnZXQ6IGxpc3RlbiB9KTtcbiAgY29uc3QgY29udGV4dFZhcmlhYmxlcyA9IFtdO1xuICBjb25zdCBlbnRpdHlOYW1lcyA9IHt9O1xuICBsZXQgaW1hZ2VDb3VudCA9IDA7XG4gIGxldCBpbmRlbnQgPSAnJztcbiAgbGV0IHJlYWRQaXhlbHNWYXJpYWJsZU5hbWU7XG4gIHJldHVybiBwcm94eTtcbiAgZnVuY3Rpb24gbGlzdGVuKG9iaiwgcHJvcGVydHkpIHtcbiAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICBjYXNlICdhZGRDb21tZW50JzogcmV0dXJuIGFkZENvbW1lbnQ7XG4gICAgICBjYXNlICdjaGVja1Rocm93RXJyb3InOiByZXR1cm4gY2hlY2tUaHJvd0Vycm9yO1xuICAgICAgY2FzZSAnZ2V0UmVhZFBpeGVsc1ZhcmlhYmxlTmFtZSc6IHJldHVybiByZWFkUGl4ZWxzVmFyaWFibGVOYW1lO1xuICAgICAgY2FzZSAnaW5zZXJ0VmFyaWFibGUnOiByZXR1cm4gaW5zZXJ0VmFyaWFibGU7XG4gICAgICBjYXNlICdyZXNldCc6IHJldHVybiByZXNldDtcbiAgICAgIGNhc2UgJ3NldEluZGVudCc6IHJldHVybiBzZXRJbmRlbnQ7XG4gICAgICBjYXNlICd0b1N0cmluZyc6IHJldHVybiB0b1N0cmluZztcbiAgICAgIGNhc2UgJ2dldENvbnRleHRWYXJpYWJsZU5hbWUnOiByZXR1cm4gZ2V0Q29udGV4dFZhcmlhYmxlTmFtZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbFtwcm9wZXJ0eV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHsgXG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICBjYXNlICdnZXRFcnJvcic6XG4gICAgICAgICAgICBpZiAodGhyb3dHZXRFcnJvcikge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9aWYgKCR7Y29udGV4dE5hbWV9LmdldEVycm9yKCkgIT09ICR7Y29udGV4dE5hbWV9Lk5PTkUpIHRocm93IG5ldyBFcnJvcignZXJyb3InKTtgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0ke2NvbnRleHROYW1lfS5nZXRFcnJvcigpO2ApOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnbC5nZXRFcnJvcigpO1xuICAgICAgICAgIGNhc2UgJ2dldEV4dGVuc2lvbic6IHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGAke2NvbnRleHROYW1lfVZhcmlhYmxlcyR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9YDtcbiAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke3ZhcmlhYmxlTmFtZX0gPSAke2NvbnRleHROYW1lfS5nZXRFeHRlbnNpb24oJyR7YXJndW1lbnRzWzBdfScpO2ApO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uICYmIHR5cGVvZiBleHRlbnNpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRhcHBlZEV4dGVuc2lvbiA9IGdsRXh0ZW5zaW9uV2lyZXRhcChleHRlbnNpb24sIHtcbiAgICAgICAgICAgICAgICBnZXRFbnRpdHksXG4gICAgICAgICAgICAgICAgdXNlVHJhY2thYmxlUHJpbWl0aXZlcyxcbiAgICAgICAgICAgICAgICByZWNvcmRpbmcsXG4gICAgICAgICAgICAgICAgY29udGV4dE5hbWU6IHZhcmlhYmxlTmFtZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICBpbmRlbnQsXG4gICAgICAgICAgICAgICAgb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaCh0YXBwZWRFeHRlbnNpb24pO1xuICAgICAgICAgICAgICByZXR1cm4gdGFwcGVkRXh0ZW5zaW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAncmVhZFBpeGVscyc6XG4gICAgICAgICAgICBjb25zdCBpID0gY29udGV4dFZhcmlhYmxlcy5pbmRleE9mKGFyZ3VtZW50c1s2XSk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0VmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGdldFZhcmlhYmxlTmFtZShhcmd1bWVudHNbNl0pO1xuICAgICAgICAgICAgICBpZiAodmFyaWFibGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VmFyaWFibGVOYW1lID0gdmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0ke3ZhcmlhYmxlTmFtZX1gKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRWYXJpYWJsZU5hbWUgPSBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9YDtcbiAgICAgICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2goYXJndW1lbnRzWzZdKTtcbiAgICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHt0YXJnZXRWYXJpYWJsZU5hbWV9ID0gbmV3ICR7YXJndW1lbnRzWzZdLmNvbnN0cnVjdG9yLm5hbWV9KCR7YXJndW1lbnRzWzZdLmxlbmd0aH0pO2ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRWYXJpYWJsZU5hbWUgPSBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7aX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZFBpeGVsc1ZhcmlhYmxlTmFtZSA9IHRhcmdldFZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50QXNTdHJpbmdzID0gW1xuICAgICAgICAgICAgICBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICAgIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzJdLFxuICAgICAgICAgICAgICBhcmd1bWVudHNbM10sXG4gICAgICAgICAgICAgIGdldEVudGl0eShhcmd1bWVudHNbNF0pLFxuICAgICAgICAgICAgICBnZXRFbnRpdHkoYXJndW1lbnRzWzVdKSxcbiAgICAgICAgICAgICAgdGFyZ2V0VmFyaWFibGVOYW1lXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSR7Y29udGV4dE5hbWV9LnJlYWRQaXhlbHMoJHthcmd1bWVudEFzU3RyaW5ncy5qb2luKCcsICcpfSk7YCk7XG4gICAgICAgICAgICBpZiAocmVhZFBpeGVsc0ZpbGUpIHtcbiAgICAgICAgICAgICAgd3JpdGVQUE0oYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uUmVhZFBpeGVscykge1xuICAgICAgICAgICAgICBvblJlYWRQaXhlbHModGFyZ2V0VmFyaWFibGVOYW1lLCBhcmd1bWVudEFzU3RyaW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2wucmVhZFBpeGVscy5hcHBseShnbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICBjYXNlICdkcmF3QnVmZmVycyc6XG4gICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9JHtjb250ZXh0TmFtZX0uZHJhd0J1ZmZlcnMoWyR7YXJndW1lbnRzVG9TdHJpbmcoYXJndW1lbnRzWzBdLCB7IGNvbnRleHROYW1lLCBjb250ZXh0VmFyaWFibGVzLCBnZXRFbnRpdHksIGFkZFZhcmlhYmxlLCB2YXJpYWJsZXMsIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAgfSApfV0pO2ApO1xuICAgICAgICAgICAgcmV0dXJuIGdsLmRyYXdCdWZmZXJzKGFyZ3VtZW50c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IGdsW3Byb3BlcnR5XS5hcHBseShnbCwgYXJndW1lbnRzKTtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgcmVzdWx0KSB7XG4gICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0ke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGlmICh1c2VUcmFja2FibGVQcmltaXRpdmVzICYmIGNvbnRleHRWYXJpYWJsZXMuaW5kZXhPZih0cmFja2FibGVQcmltaXRpdmUocmVzdWx0KSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH0gPSAke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaChyZXN1bHQgPSB0cmFja2FibGVQcmltaXRpdmUocmVzdWx0KSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9ID0gJHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBlbnRpdHlOYW1lc1tnbFtwcm9wZXJ0eV1dID0gcHJvcGVydHk7XG4gICAgcmV0dXJuIGdsW3Byb3BlcnR5XTtcbiAgfVxuICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gcmVjb3JkaW5nLmpvaW4oJ1xcbicpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHdoaWxlIChyZWNvcmRpbmcubGVuZ3RoID4gMCkge1xuICAgICAgcmVjb3JkaW5nLnBvcCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbnNlcnRWYXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgIHZhcmlhYmxlc1tuYW1lXSA9IHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGdldEVudGl0eSh2YWx1ZSkge1xuICAgIGNvbnN0IG5hbWUgPSBlbnRpdHlOYW1lc1t2YWx1ZV07XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBjb250ZXh0TmFtZSArICcuJyArIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBzZXRJbmRlbnQoc3BhY2VzKSB7XG4gICAgaW5kZW50ID0gJyAnLnJlcGVhdChzcGFjZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFZhcmlhYmxlKHZhbHVlLCBzb3VyY2UpIHtcbiAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9YDtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHt2YXJpYWJsZU5hbWV9ID0gJHtzb3VyY2V9O2ApO1xuICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHZhcmlhYmxlTmFtZTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVBQTSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgc291cmNlVmFyaWFibGUgPSBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9YDtcbiAgICBjb25zdCBpbWFnZVZhcmlhYmxlID0gYGltYWdlRGF0dW0ke2ltYWdlQ291bnR9YDtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9bGV0ICR7aW1hZ2VWYXJpYWJsZX0gPSBbXCJQM1xcXFxuIyAke3JlYWRQaXhlbHNGaWxlfS5wcG1cXFxcblwiLCAke3dpZHRofSwgJyAnLCAke2hlaWdodH0sIFwiXFxcXG4yNTVcXFxcblwiXS5qb2luKFwiXCIpO2ApO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1mb3IgKGxldCBpID0gMDsgaSA8ICR7aW1hZ2VWYXJpYWJsZX0ubGVuZ3RoOyBpICs9IDQpIHtgKTtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9ICAke2ltYWdlVmFyaWFibGV9ICs9ICR7c291cmNlVmFyaWFibGV9W2ldICsgJyAnICsgJHtzb3VyY2VWYXJpYWJsZX1baSArIDFdICsgJyAnICsgJHtzb3VyY2VWYXJpYWJsZX1baSArIDJdICsgJyAnO2ApO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH19YCk7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWlmICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIikge2ApO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0gIHJlcXVpcmUoJ2ZzJykud3JpdGVGaWxlU3luYygnLi8ke3JlYWRQaXhlbHNGaWxlfS5wcG0nLCAke2ltYWdlVmFyaWFibGV9KTtgKTtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9fWApO1xuICAgIGltYWdlQ291bnQrKztcbiAgfVxuICBmdW5jdGlvbiBhZGRDb21tZW50KHZhbHVlKSB7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fS8vICR7dmFsdWV9YCk7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tUaHJvd0Vycm9yKCkge1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0oKCkgPT4ge1xuJHtpbmRlbnR9Y29uc3QgZXJyb3IgPSAke2NvbnRleHROYW1lfS5nZXRFcnJvcigpO1xuJHtpbmRlbnR9aWYgKGVycm9yICE9PSAke2NvbnRleHROYW1lfS5OT05FKSB7XG4ke2luZGVudH0gIGNvbnN0IG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZ2wpO1xuJHtpbmRlbnR9ICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4ke2luZGVudH0gICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuJHtpbmRlbnR9ICAgIGlmICgke2NvbnRleHROYW1lfVtuYW1lXSA9PT0gZXJyb3IpIHtcbiR7aW5kZW50fSAgICAgIHRocm93IG5ldyBFcnJvcignJHtjb250ZXh0TmFtZX0gdGhyZXcgJyArIG5hbWUpO1xuJHtpbmRlbnR9ICAgIH1cbiR7aW5kZW50fSAgfVxuJHtpbmRlbnR9fVxuJHtpbmRlbnR9fSkoKTtgKTtcbiAgfVxuICBmdW5jdGlvbiBtZXRob2RDYWxsVG9TdHJpbmcobWV0aG9kLCBhcmdzKSB7XG4gICAgcmV0dXJuIGAke2NvbnRleHROYW1lfS4ke21ldGhvZH0oJHthcmd1bWVudHNUb1N0cmluZyhhcmdzLCB7IGNvbnRleHROYW1lLCBjb250ZXh0VmFyaWFibGVzLCBnZXRFbnRpdHksIGFkZFZhcmlhYmxlLCB2YXJpYWJsZXMsIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAgfSl9KWA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWYXJpYWJsZU5hbWUodmFsdWUpIHtcbiAgICBpZiAodmFyaWFibGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFyaWFibGVzKSB7XG4gICAgICAgIGlmICh2YXJpYWJsZXNbbmFtZV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb250ZXh0VmFyaWFibGVOYW1lKHZhbHVlKSB7XG4gICAgY29uc3QgaSA9IGNvbnRleHRWYXJpYWJsZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gYCR7Y29udGV4dE5hbWV9VmFyaWFibGUke2l9YDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2xFeHRlbnNpb25XaXJldGFwKGV4dGVuc2lvbiwgb3B0aW9ucykge1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShleHRlbnNpb24sIHsgZ2V0OiBsaXN0ZW4gfSk7XG4gIGNvbnN0IGV4dGVuc2lvbkVudGl0eU5hbWVzID0ge307XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0TmFtZSxcbiAgICBjb250ZXh0VmFyaWFibGVzLFxuICAgIGdldEVudGl0eSxcbiAgICB1c2VUcmFja2FibGVQcmltaXRpdmVzLFxuICAgIHJlY29yZGluZyxcbiAgICB2YXJpYWJsZXMsXG4gICAgaW5kZW50LFxuICAgIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAsXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gcHJveHk7XG4gIGZ1bmN0aW9uIGxpc3RlbihvYmosIHByb3BlcnR5KSB7XG4gICAgaWYgKHR5cGVvZiBvYmpbcHJvcGVydHldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICBjYXNlICdkcmF3QnVmZmVyc1dFQkdMJzpcbiAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0ke2NvbnRleHROYW1lfS5kcmF3QnVmZmVyc1dFQkdMKFske2FyZ3VtZW50c1RvU3RyaW5nKGFyZ3VtZW50c1swXSwgeyBjb250ZXh0TmFtZSwgY29udGV4dFZhcmlhYmxlcywgZ2V0RW50aXR5OiBnZXRFeHRlbnNpb25FbnRpdHksIGFkZFZhcmlhYmxlLCB2YXJpYWJsZXMsIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAgfSl9XSk7YCk7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uLmRyYXdCdWZmZXJzV0VCR0woYXJndW1lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gZXh0ZW5zaW9uW3Byb3BlcnR5XS5hcHBseShleHRlbnNpb24sIGFyZ3VtZW50cyk7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHJlc3VsdCkge1xuICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9JHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBpZiAodXNlVHJhY2thYmxlUHJpbWl0aXZlcyAmJiBjb250ZXh0VmFyaWFibGVzLmluZGV4T2YodHJhY2thYmxlUHJpbWl0aXZlKHJlc3VsdCkpID09PSAtMSkge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9ID0gJHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2gocmVzdWx0ID0gdHJhY2thYmxlUHJpbWl0aXZlKHJlc3VsdCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofSA9ICR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofSA9ICR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cbiAgICBleHRlbnNpb25FbnRpdHlOYW1lc1tleHRlbnNpb25bcHJvcGVydHldXSA9IHByb3BlcnR5O1xuICAgIHJldHVybiBleHRlbnNpb25bcHJvcGVydHldO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uRW50aXR5KHZhbHVlKSB7XG4gICAgaWYgKGV4dGVuc2lvbkVudGl0eU5hbWVzLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGAke2NvbnRleHROYW1lfS4ke2V4dGVuc2lvbkVudGl0eU5hbWVzW3ZhbHVlXX1gO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RW50aXR5KHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ldGhvZENhbGxUb1N0cmluZyhtZXRob2QsIGFyZ3MpIHtcbiAgICByZXR1cm4gYCR7Y29udGV4dE5hbWV9LiR7bWV0aG9kfSgke2FyZ3VtZW50c1RvU3RyaW5nKGFyZ3MsIHsgY29udGV4dE5hbWUsIGNvbnRleHRWYXJpYWJsZXMsIGdldEVudGl0eTogZ2V0RXh0ZW5zaW9uRW50aXR5LCBhZGRWYXJpYWJsZSwgdmFyaWFibGVzLCBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwIH0pfSlgO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkVmFyaWFibGUodmFsdWUsIHNvdXJjZSkge1xuICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH1gO1xuICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaCh2YWx1ZSk7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7dmFyaWFibGVOYW1lfSA9ICR7c291cmNlfTtgKTtcbiAgICByZXR1cm4gdmFyaWFibGVOYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFyZ3VtZW50c1RvU3RyaW5nKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyB2YXJpYWJsZXMsIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiAoQXJyYXkuZnJvbShhcmdzKS5tYXAoKGFyZykgPT4ge1xuICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGdldFZhcmlhYmxlTmFtZShhcmcpO1xuICAgIGlmICh2YXJpYWJsZU5hbWUpIHtcbiAgICAgIHJldHVybiB2YXJpYWJsZU5hbWU7XG4gICAgfVxuICAgIHJldHVybiBhcmd1bWVudFRvU3RyaW5nKGFyZywgb3B0aW9ucyk7XG4gIH0pLmpvaW4oJywgJykpO1xuXG4gIGZ1bmN0aW9uIGdldFZhcmlhYmxlTmFtZSh2YWx1ZSkge1xuICAgIGlmICh2YXJpYWJsZXMpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKCF2YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAodmFyaWFibGVzW25hbWVdID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwKSB7XG4gICAgICByZXR1cm4gb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFyZ3VtZW50VG9TdHJpbmcoYXJnLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgY29udGV4dE5hbWUsIGNvbnRleHRWYXJpYWJsZXMsIGdldEVudGl0eSwgYWRkVmFyaWFibGUsIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAgfSA9IG9wdGlvbnM7XG4gIGlmICh0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuICBpZiAoYXJnID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuICBjb25zdCBpID0gY29udGV4dFZhcmlhYmxlcy5pbmRleE9mKGFyZyk7XG4gIGlmIChpID4gLTEpIHtcbiAgICByZXR1cm4gYCR7Y29udGV4dE5hbWV9VmFyaWFibGUke2l9YDtcbiAgfVxuICBzd2l0Y2ggKGFyZy5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgY2FzZSAnU3RyaW5nJzpcbiAgICAgIGNvbnN0IGhhc0xpbmVzID0gL1xcbi8udGVzdChhcmcpO1xuICAgICAgY29uc3QgaGFzU2luZ2xlUXVvdGVzID0gLycvLnRlc3QoYXJnKTtcbiAgICAgIGNvbnN0IGhhc0RvdWJsZVF1b3RlcyA9IC9cIi8udGVzdChhcmcpO1xuICAgICAgaWYgKGhhc0xpbmVzKSB7XG4gICAgICAgIHJldHVybiAnYCcgKyBhcmcgKyAnYCc7XG4gICAgICB9IGVsc2UgaWYgKGhhc1NpbmdsZVF1b3RlcyAmJiAhaGFzRG91YmxlUXVvdGVzKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgYXJnICsgJ1wiJztcbiAgICAgIH0gZWxzZSBpZiAoIWhhc1NpbmdsZVF1b3RlcyAmJiBoYXNEb3VibGVRdW90ZXMpIHtcbiAgICAgICAgcmV0dXJuIFwiJ1wiICsgYXJnICsgXCInXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ1xcJycgKyBhcmcgKyAnXFwnJztcbiAgICAgIH1cbiAgICBjYXNlICdOdW1iZXInOiByZXR1cm4gZ2V0RW50aXR5KGFyZyk7XG4gICAgY2FzZSAnQm9vbGVhbic6IHJldHVybiBnZXRFbnRpdHkoYXJnKTtcbiAgICBjYXNlICdBcnJheSc6XG4gICAgICByZXR1cm4gYWRkVmFyaWFibGUoYXJnLCBgbmV3ICR7YXJnLmNvbnN0cnVjdG9yLm5hbWV9KFske0FycmF5LmZyb20oYXJnKS5qb2luKCcsJyl9XSlgKTtcbiAgICBjYXNlICdGbG9hdDMyQXJyYXknOlxuICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQxNkFycmF5JzpcbiAgICBjYXNlICdJbnQzMkFycmF5JzpcbiAgICAgIHJldHVybiBhZGRWYXJpYWJsZShhcmcsIGBuZXcgJHthcmcuY29uc3RydWN0b3IubmFtZX0oJHtKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKGFyZykpfSlgKTtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXApIHtcbiAgICAgICAgY29uc3QgaW5zdGFudGlhdGlvblN0cmluZyA9IG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAoYXJnKTtcbiAgICAgICAgaWYgKGluc3RhbnRpYXRpb25TdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFudGlhdGlvblN0cmluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgYXJndW1lbnQgdHlwZSAke2FyZy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrYWJsZVByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gbmV3IHZhbHVlLmNvbnN0cnVjdG9yKHZhbHVlKTtcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBnbFdpcmV0YXAsIGdsRXh0ZW5zaW9uV2lyZXRhcCB9O1xufVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xXaXJldGFwLmdsRXh0ZW5zaW9uV2lyZXRhcCA9IGdsRXh0ZW5zaW9uV2lyZXRhcDtcbiAgd2luZG93LmdsV2lyZXRhcCA9IGdsV2lyZXRhcDtcbn1cblxufSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5mdW5jdGlvbiBzZXR1cEFyZ3VtZW50cyhhcmdzKSB7XG4gIGNvbnN0IG5ld0FyZ3VtZW50cyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgaWYgKGFyZy50b0FycmF5KSB7XG4gICAgICBuZXdBcmd1bWVudHNbaV0gPSBhcmcudG9BcnJheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdBcmd1bWVudHNbaV0gPSBhcmc7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdBcmd1bWVudHM7XG59XG5cbmZ1bmN0aW9uIG1vY2sxRCgpIHtcbiAgY29uc3QgYXJncyA9IHNldHVwQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gIGNvbnN0IHJvdyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5vdXRwdXQueCk7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5vdXRwdXQueDsgeCsrKSB7XG4gICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgdGhpcy50aHJlYWQueSA9IDA7XG4gICAgdGhpcy50aHJlYWQueiA9IDA7XG4gICAgcm93W3hdID0gdGhpcy5fZm4uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHJvdztcbn1cblxuZnVuY3Rpb24gbW9jazJEKCkge1xuICBjb25zdCBhcmdzID0gc2V0dXBBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgY29uc3QgbWF0cml4ID0gbmV3IEFycmF5KHRoaXMub3V0cHV0LnkpO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMub3V0cHV0Lnk7IHkrKykge1xuICAgIGNvbnN0IHJvdyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5vdXRwdXQueCk7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLm91dHB1dC54OyB4KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICB0aGlzLnRocmVhZC56ID0gMDtcbiAgICAgIHJvd1t4XSA9IHRoaXMuX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBtYXRyaXhbeV0gPSByb3c7XG4gIH1cbiAgcmV0dXJuIG1hdHJpeDtcbn1cblxuZnVuY3Rpb24gbW9jazJER3JhcGhpY2FsKCkge1xuICBjb25zdCBhcmdzID0gc2V0dXBBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLm91dHB1dC55OyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMub3V0cHV0Lng7IHgrKykge1xuICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgdGhpcy5fZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vY2szRCgpIHtcbiAgY29uc3QgYXJncyA9IHNldHVwQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gIGNvbnN0IGN1YmUgPSBuZXcgQXJyYXkodGhpcy5vdXRwdXQueik7XG4gIGZvciAobGV0IHogPSAwOyB6IDwgdGhpcy5vdXRwdXQuejsgeisrKSB7XG4gICAgY29uc3QgbWF0cml4ID0gbmV3IEFycmF5KHRoaXMub3V0cHV0LnkpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5vdXRwdXQueTsgeSsrKSB7XG4gICAgICBjb25zdCByb3cgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMub3V0cHV0LngpO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLm91dHB1dC54OyB4KyspIHtcbiAgICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xuICAgICAgICB0aGlzLnRocmVhZC56ID0gejtcbiAgICAgICAgcm93W3hdID0gdGhpcy5fZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICBtYXRyaXhbeV0gPSByb3c7XG4gICAgfVxuICAgIGN1YmVbel0gPSBtYXRyaXg7XG4gIH1cbiAgcmV0dXJuIGN1YmU7XG59XG5cbmZ1bmN0aW9uIGFwaURlY29yYXRlKGtlcm5lbCkge1xuICBrZXJuZWwuc2V0T3V0cHV0ID0gKG91dHB1dCkgPT4ge1xuICAgIGtlcm5lbC5vdXRwdXQgPSBzZXR1cE91dHB1dChvdXRwdXQpO1xuICAgIGlmIChrZXJuZWwuZ3JhcGhpY2FsKSB7XG4gICAgICBzZXR1cEdyYXBoaWNhbChrZXJuZWwpO1xuICAgIH1cbiAgfTtcbiAga2VybmVsLnRvSlNPTiA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB1c2FibGUgd2l0aCBncHVNb2NrJyk7XG4gIH07XG4gIGtlcm5lbC5zZXRDb25zdGFudHMgPSAoZmxhZykgPT4ge1xuICAgIGtlcm5lbC5jb25zdGFudHMgPSBmbGFnO1xuICAgIHJldHVybiBrZXJuZWw7XG4gIH07XG4gIGtlcm5lbC5zZXRHcmFwaGljYWwgPSAoZmxhZykgPT4ge1xuICAgIGtlcm5lbC5ncmFwaGljYWwgPSBmbGFnO1xuICAgIHJldHVybiBrZXJuZWw7XG4gIH07XG4gIGtlcm5lbC5zZXRDYW52YXMgPSAoZmxhZykgPT4ge1xuICAgIGtlcm5lbC5jYW52YXMgPSBmbGFnO1xuICAgIHJldHVybiBrZXJuZWw7XG4gIH07XG4gIGtlcm5lbC5zZXRDb250ZXh0ID0gKGZsYWcpID0+IHtcbiAgICBrZXJuZWwuY29udGV4dCA9IGZsYWc7XG4gICAgcmV0dXJuIGtlcm5lbDtcbiAgfTtcbiAga2VybmVsLmRlc3Ryb3kgPSAoKSA9PiB7fTtcbiAga2VybmVsLnZhbGlkYXRlU2V0dGluZ3MgPSAoKSA9PiB7fTtcbiAgaWYgKGtlcm5lbC5ncmFwaGljYWwgJiYga2VybmVsLm91dHB1dCkge1xuICAgIHNldHVwR3JhcGhpY2FsKGtlcm5lbCk7XG4gIH1cbiAga2VybmVsLmV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZShrZXJuZWwuYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGtlcm5lbC5nZXRQaXhlbHMgPSAoZmxpcCkgPT4ge1xuICAgIGNvbnN0IHt4LCB5fSA9IGtlcm5lbC5vdXRwdXQ7XG4gICAgcmV0dXJuIGZsaXAgPyBmbGlwUGl4ZWxzKGtlcm5lbC5faW1hZ2VEYXRhLmRhdGEsIHgsIHkpIDoga2VybmVsLl9pbWFnZURhdGEuZGF0YS5zbGljZSgwKTtcbiAgfTtcbiAga2VybmVsLmNvbG9yID0gZnVuY3Rpb24ociwgZywgYiwgYSkge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGEgPSAxO1xuICAgIH1cblxuICAgIHIgPSBNYXRoLmZsb29yKHIgKiAyNTUpO1xuICAgIGcgPSBNYXRoLmZsb29yKGcgKiAyNTUpO1xuICAgIGIgPSBNYXRoLmZsb29yKGIgKiAyNTUpO1xuICAgIGEgPSBNYXRoLmZsb29yKGEgKiAyNTUpO1xuXG4gICAgY29uc3Qgd2lkdGggPSBrZXJuZWwub3V0cHV0Lng7XG4gICAgY29uc3QgaGVpZ2h0ID0ga2VybmVsLm91dHB1dC55O1xuXG4gICAgY29uc3QgeCA9IGtlcm5lbC50aHJlYWQueDtcbiAgICBjb25zdCB5ID0gaGVpZ2h0IC0ga2VybmVsLnRocmVhZC55IC0gMTtcblxuICAgIGNvbnN0IGluZGV4ID0geCArIHkgKiB3aWR0aDtcblxuICAgIGtlcm5lbC5fY29sb3JEYXRhW2luZGV4ICogNCArIDBdID0gcjtcbiAgICBrZXJuZWwuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAxXSA9IGc7XG4gICAga2VybmVsLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgMl0gPSBiO1xuICAgIGtlcm5lbC5fY29sb3JEYXRhW2luZGV4ICogNCArIDNdID0gYTtcbiAgfTtcblxuICBjb25zdCBtb2NrTWV0aG9kID0gKCkgPT4ga2VybmVsO1xuICBjb25zdCBtZXRob2RzID0gW1xuICAgICdzZXRXYXJuVmFyVXNhZ2UnLFxuICAgICdzZXRBcmd1bWVudFR5cGVzJyxcbiAgICAnc2V0VGFjdGljJyxcbiAgICAnc2V0T3B0aW1pemVGbG9hdE1lbW9yeScsXG4gICAgJ3NldERlYnVnJyxcbiAgICAnc2V0TG9vcE1heEl0ZXJhdGlvbnMnLFxuICAgICdzZXRDb25zdGFudFR5cGVzJyxcbiAgICAnc2V0RnVuY3Rpb25zJyxcbiAgICAnc2V0TmF0aXZlRnVuY3Rpb25zJyxcbiAgICAnc2V0SW5qZWN0ZWROYXRpdmUnLFxuICAgICdzZXRQaXBlbGluZScsXG4gICAgJ3NldFByZWNpc2lvbicsXG4gICAgJ3NldE91dHB1dFRvVGV4dHVyZScsXG4gICAgJ3NldEltbXV0YWJsZScsXG4gICAgJ3NldFN0cmljdEludGVnZXJzJyxcbiAgICAnc2V0RHluYW1pY091dHB1dCcsXG4gICAgJ3NldEhhcmRjb2RlQ29uc3RhbnRzJyxcbiAgICAnc2V0RHluYW1pY0FyZ3VtZW50cycsXG4gICAgJ3NldFVzZUxlZ2FjeUVuY29kZXInLFxuICAgICdzZXRXYXJuVmFyVXNhZ2UnLFxuICAgICdhZGRTdWJLZXJuZWwnLFxuICBdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXJuZWxbbWV0aG9kc1tpXV0gPSBtb2NrTWV0aG9kO1xuICB9XG4gIHJldHVybiBrZXJuZWw7XG59XG5cbmZ1bmN0aW9uIHNldHVwR3JhcGhpY2FsKGtlcm5lbCkge1xuICBjb25zdCB7eCwgeX0gPSBrZXJuZWwub3V0cHV0O1xuICBpZiAoa2VybmVsLmNvbnRleHQgJiYga2VybmVsLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh4ICogeSAqIDQpO1xuICAgIGtlcm5lbC5faW1hZ2VEYXRhID0ga2VybmVsLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHgsIHkpO1xuICAgIGtlcm5lbC5fY29sb3JEYXRhID0gZGF0YTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHggKiB5ICogNCk7XG4gICAga2VybmVsLl9pbWFnZURhdGEgPSB7IGRhdGEgfTtcbiAgICBrZXJuZWwuX2NvbG9yRGF0YSA9IGRhdGE7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBPdXRwdXQob3V0cHV0KSB7XG4gIGxldCByZXN1bHQgPSBudWxsO1xuICBpZiAob3V0cHV0Lmxlbmd0aCkge1xuICAgIGlmIChvdXRwdXQubGVuZ3RoID09PSAzKSB7XG4gICAgICBjb25zdCBbeCx5LHpdID0gb3V0cHV0O1xuICAgICAgcmVzdWx0ID0geyB4LCB5LCB6IH07XG4gICAgfSBlbHNlIGlmIChvdXRwdXQubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBbeCx5XSA9IG91dHB1dDtcbiAgICAgIHJlc3VsdCA9IHsgeCwgeSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbeF0gPSBvdXRwdXQ7XG4gICAgICByZXN1bHQgPSB7IHggfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gb3V0cHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdwdU1vY2soZm4sIHNldHRpbmdzID0ge30pIHtcbiAgY29uc3Qgb3V0cHV0ID0gc2V0dGluZ3Mub3V0cHV0ID8gc2V0dXBPdXRwdXQoc2V0dGluZ3Mub3V0cHV0KSA6IG51bGw7XG4gIGZ1bmN0aW9uIGtlcm5lbCgpIHtcbiAgICBpZiAoa2VybmVsLm91dHB1dC56KSB7XG4gICAgICByZXR1cm4gbW9jazNELmFwcGx5KGtlcm5lbCwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKGtlcm5lbC5vdXRwdXQueSkge1xuICAgICAgaWYgKGtlcm5lbC5ncmFwaGljYWwpIHtcbiAgICAgICAgcmV0dXJuIG1vY2syREdyYXBoaWNhbC5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9jazJELmFwcGx5KGtlcm5lbCwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1vY2sxRC5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG4gIGtlcm5lbC5fZm4gPSBmbjtcbiAga2VybmVsLmNvbnN0YW50cyA9IHNldHRpbmdzLmNvbnN0YW50cyB8fCBudWxsO1xuICBrZXJuZWwuY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHQgfHwgbnVsbDtcbiAga2VybmVsLmNhbnZhcyA9IHNldHRpbmdzLmNhbnZhcyB8fCBudWxsO1xuICBrZXJuZWwuZ3JhcGhpY2FsID0gc2V0dGluZ3MuZ3JhcGhpY2FsIHx8IGZhbHNlO1xuICBrZXJuZWwuX2ltYWdlRGF0YSA9IG51bGw7XG4gIGtlcm5lbC5fY29sb3JEYXRhID0gbnVsbDtcbiAga2VybmVsLm91dHB1dCA9IG91dHB1dDtcbiAga2VybmVsLnRocmVhZCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgejogMFxuICB9O1xuICByZXR1cm4gYXBpRGVjb3JhdGUoa2VybmVsKTtcbn1cblxuZnVuY3Rpb24gZmxpcFBpeGVscyhwaXhlbHMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgY29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDIgfCAwOyBcbiAgY29uc3QgYnl0ZXNQZXJSb3cgPSB3aWR0aCAqIDQ7XG4gIGNvbnN0IHRlbXAgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiA0KTtcbiAgY29uc3QgcmVzdWx0ID0gcGl4ZWxzLnNsaWNlKDApO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IGhhbGZIZWlnaHQ7ICsreSkge1xuICAgIGNvbnN0IHRvcE9mZnNldCA9IHkgKiBieXRlc1BlclJvdztcbiAgICBjb25zdCBib3R0b21PZmZzZXQgPSAoaGVpZ2h0IC0geSAtIDEpICogYnl0ZXNQZXJSb3c7XG5cbiAgICB0ZW1wLnNldChyZXN1bHQuc3ViYXJyYXkodG9wT2Zmc2V0LCB0b3BPZmZzZXQgKyBieXRlc1BlclJvdykpO1xuXG4gICAgcmVzdWx0LmNvcHlXaXRoaW4odG9wT2Zmc2V0LCBib3R0b21PZmZzZXQsIGJvdHRvbU9mZnNldCArIGJ5dGVzUGVyUm93KTtcblxuICAgIHJlc3VsdC5zZXQodGVtcCwgYm90dG9tT2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ3B1TW9ja1xufTtcblxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGFsaWFzKG5hbWUsIHNvdXJjZSkge1xuICBjb25zdCBmblN0cmluZyA9IHNvdXJjZS50b1N0cmluZygpO1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKGByZXR1cm4gZnVuY3Rpb24gJHsgbmFtZSB9ICgkeyB1dGlscy5nZXRBcmd1bWVudE5hbWVzRnJvbVN0cmluZyhmblN0cmluZykuam9pbignLCAnKSB9KSB7XG4gICR7IHV0aWxzLmdldEZ1bmN0aW9uQm9keUZyb21TdHJpbmcoZm5TdHJpbmcpIH1cbn1gKSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWxpYXNcbn07XG59LHtcIi4vdXRpbHNcIjoxMTR9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuLi9mdW5jdGlvbi1ub2RlJyk7XG5cbmNsYXNzIENQVUZ1bmN0aW9uTm9kZSBleHRlbmRzIEZ1bmN0aW9uTm9kZSB7XG4gIGFzdEZ1bmN0aW9uKGFzdCwgcmV0QXJyKSB7XG5cbiAgICBpZiAoIXRoaXMuaXNSb290S2VybmVsKSB7XG4gICAgICByZXRBcnIucHVzaCgnZnVuY3Rpb24nKTtcbiAgICAgIHJldEFyci5wdXNoKCcgJyk7XG4gICAgICByZXRBcnIucHVzaCh0aGlzLm5hbWUpO1xuICAgICAgcmV0QXJyLnB1c2goJygnKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgYXJndW1lbnROYW1lID0gdGhpcy5hcmd1bWVudE5hbWVzW2ldO1xuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHJldEFyci5wdXNoKCcsICcpO1xuICAgICAgICB9XG4gICAgICAgIHJldEFyci5wdXNoKCd1c2VyXycpO1xuICAgICAgICByZXRBcnIucHVzaChhcmd1bWVudE5hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXRBcnIucHVzaCgnKSB7XFxuJyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QuYm9keS5ib2R5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmJvZHkuYm9keVtpXSwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCdcXG4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNSb290S2VybmVsKSB7XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0UmV0dXJuU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMucmV0dXJuVHlwZSB8fCB0aGlzLmdldFR5cGUoYXN0LmFyZ3VtZW50KTtcblxuICAgIGlmICghdGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICB0aGlzLnJldHVyblR5cGUgPSB0eXBlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUm9vdEtlcm5lbCkge1xuICAgICAgcmV0QXJyLnB1c2godGhpcy5sZWFkaW5nUmV0dXJuU3RhdGVtZW50KTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnO1xcbicpO1xuICAgICAgcmV0QXJyLnB1c2godGhpcy5mb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQpO1xuICAgICAgcmV0QXJyLnB1c2goJ2NvbnRpbnVlO1xcbicpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1N1Yktlcm5lbCkge1xuICAgICAgcmV0QXJyLnB1c2goYHN1Yktlcm5lbFJlc3VsdF8keyB0aGlzLm5hbWUgfSA9IGApO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgICByZXRBcnIucHVzaChgcmV0dXJuIHN1Yktlcm5lbFJlc3VsdF8keyB0aGlzLm5hbWUgfTtgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goJ3JldHVybiAnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnOycpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0TGl0ZXJhbChhc3QsIHJldEFycikge1xuXG4gICAgaWYgKGlzTmFOKGFzdC52YWx1ZSkpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG4gICAgICAgICdOb24tbnVtZXJpYyBsaXRlcmFsIG5vdCBzdXBwb3J0ZWQgOiAnICsgYXN0LnZhbHVlLFxuICAgICAgICBhc3RcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0QXJyLnB1c2goYXN0LnZhbHVlKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RCaW5hcnlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goYXN0Lm9wZXJhdG9yKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdElkZW50aWZpZXJFeHByZXNzaW9uKGlkdE5vZGUsIHJldEFycikge1xuICAgIGlmIChpZHROb2RlLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcbiAgICAgICAgJ0lkZW50aWZpZXJFeHByZXNzaW9uIC0gbm90IGFuIElkZW50aWZpZXInLFxuICAgICAgICBpZHROb2RlXG4gICAgICApO1xuICAgIH1cblxuICAgIHN3aXRjaCAoaWR0Tm9kZS5uYW1lKSB7XG4gICAgICBjYXNlICdJbmZpbml0eSc6XG4gICAgICAgIHJldEFyci5wdXNoKCdJbmZpbml0eScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0aGlzLmNvbnN0YW50cyAmJiB0aGlzLmNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShpZHROb2RlLm5hbWUpKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ2NvbnN0YW50c18nICsgaWR0Tm9kZS5uYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgndXNlcl8nICsgaWR0Tm9kZS5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RGb3JTdGF0ZW1lbnQoZm9yTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKGZvck5vZGUudHlwZSAhPT0gJ0ZvclN0YXRlbWVudCcpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgZm9yIHN0YXRlbWVudCcsIGZvck5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRBcnIgPSBbXTtcbiAgICBjb25zdCB0ZXN0QXJyID0gW107XG4gICAgY29uc3QgdXBkYXRlQXJyID0gW107XG4gICAgY29uc3QgYm9keUFyciA9IFtdO1xuICAgIGxldCBpc1NhZmUgPSBudWxsO1xuXG4gICAgaWYgKGZvck5vZGUuaW5pdCkge1xuICAgICAgdGhpcy5wdXNoU3RhdGUoJ2luLWZvci1sb29wLWluaXQnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLmluaXQsIGluaXRBcnIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbml0QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbml0QXJyW2ldLmluY2x1ZGVzICYmIGluaXRBcnJbaV0uaW5jbHVkZXMoJywnKSkge1xuICAgICAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBvcFN0YXRlKCdpbi1mb3ItbG9vcC1pbml0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmb3JOb2RlLnRlc3QpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLnRlc3QsIHRlc3RBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZm9yTm9kZS51cGRhdGUpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLnVwZGF0ZSwgdXBkYXRlQXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZvck5vZGUuYm9keSkge1xuICAgICAgdGhpcy5wdXNoU3RhdGUoJ2xvb3AtYm9keScpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUuYm9keSwgYm9keUFycik7XG4gICAgICB0aGlzLnBvcFN0YXRlKCdsb29wLWJvZHknKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTYWZlID09PSBudWxsKSB7XG4gICAgICBpc1NhZmUgPSB0aGlzLmlzU2FmZShmb3JOb2RlLmluaXQpICYmIHRoaXMuaXNTYWZlKGZvck5vZGUudGVzdCk7XG4gICAgfVxuXG4gICAgaWYgKGlzU2FmZSkge1xuICAgICAgcmV0QXJyLnB1c2goYGZvciAoJHtpbml0QXJyLmpvaW4oJycpfTske3Rlc3RBcnIuam9pbignJyl9OyR7dXBkYXRlQXJyLmpvaW4oJycpfSl7XFxuYCk7XG4gICAgICByZXRBcnIucHVzaChib2R5QXJyLmpvaW4oJycpKTtcbiAgICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlWYXJpYWJsZU5hbWUgPSB0aGlzLmdldEludGVybmFsVmFyaWFibGVOYW1lKCdzYWZlSScpO1xuICAgICAgaWYgKGluaXRBcnIubGVuZ3RoID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaChpbml0QXJyLmpvaW4oJycpLCAnO1xcbicpO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goYGZvciAobGV0ICR7aVZhcmlhYmxlTmFtZX09MDske2lWYXJpYWJsZU5hbWV9PExPT1BfTUFYOyR7aVZhcmlhYmxlTmFtZX0rKyl7XFxuYCk7XG4gICAgICBpZiAodGVzdEFyci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldEFyci5wdXNoKGBpZiAoISR7dGVzdEFyci5qb2luKCcnKX0pIGJyZWFrO1xcbmApO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goYm9keUFyci5qb2luKCcnKSk7XG4gICAgICByZXRBcnIucHVzaChgXFxuJHt1cGRhdGVBcnIuam9pbignJyl9O2ApO1xuICAgICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFdoaWxlU3RhdGVtZW50KHdoaWxlTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKHdoaWxlTm9kZS50eXBlICE9PSAnV2hpbGVTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KFxuICAgICAgICAnSW52YWxpZCB3aGlsZSBzdGF0ZW1lbnQnLFxuICAgICAgICB3aGlsZU5vZGVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0QXJyLnB1c2goJ2ZvciAobGV0IGkgPSAwOyBpIDwgTE9PUF9NQVg7IGkrKykgeycpO1xuICAgIHJldEFyci5wdXNoKCdpZiAoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKHdoaWxlTm9kZS50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpIHtcXG4nKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMod2hpbGVOb2RlLmJvZHksIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJ30gZWxzZSB7XFxuJyk7XG4gICAgcmV0QXJyLnB1c2goJ2JyZWFrO1xcbicpO1xuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3REb1doaWxlU3RhdGVtZW50KGRvV2hpbGVOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoZG9XaGlsZU5vZGUudHlwZSAhPT0gJ0RvV2hpbGVTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KFxuICAgICAgICAnSW52YWxpZCB3aGlsZSBzdGF0ZW1lbnQnLFxuICAgICAgICBkb1doaWxlTm9kZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXRBcnIucHVzaCgnZm9yIChsZXQgaSA9IDA7IGkgPCBMT09QX01BWDsgaSsrKSB7Jyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGRvV2hpbGVOb2RlLmJvZHksIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJ2lmICghJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGRvV2hpbGVOb2RlLnRlc3QsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJykge1xcbicpO1xuICAgIHJldEFyci5wdXNoKCdicmVhaztcXG4nKTtcbiAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuXG4gIH1cblxuICBhc3RBc3NpZ25tZW50RXhwcmVzc2lvbihhc3NOb2RlLCByZXRBcnIpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHRoaXMuZ2V0RGVjbGFyYXRpb24oYXNzTm9kZS5sZWZ0KTtcbiAgICBpZiAoZGVjbGFyYXRpb24gJiYgIWRlY2xhcmF0aW9uLmFzc2lnbmFibGUpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFZhcmlhYmxlICR7YXNzTm9kZS5sZWZ0Lm5hbWV9IGlzIG5vdCBhc3NpZ25hYmxlIGhlcmVgLCBhc3NOb2RlKTtcbiAgICB9XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaChhc3NOb2RlLm9wZXJhdG9yKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0QmxvY2tTdGF0ZW1lbnQoYk5vZGUsIHJldEFycikge1xuICAgIGlmICh0aGlzLmlzU3RhdGUoJ2xvb3AtYm9keScpKSB7XG4gICAgICB0aGlzLnB1c2hTdGF0ZSgnYmxvY2stYm9keScpOyBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYk5vZGUuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYk5vZGUuYm9keVtpXSwgcmV0QXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9wU3RhdGUoJ2Jsb2NrLWJvZHknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goJ3tcXG4nKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYk5vZGUuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYk5vZGUuYm9keVtpXSwgcmV0QXJyKTtcbiAgICAgIH1cbiAgICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RWYXJpYWJsZURlY2xhcmF0aW9uKHZhckRlY05vZGUsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKGAke3ZhckRlY05vZGUua2luZH0gYCk7XG4gICAgY29uc3QgeyBkZWNsYXJhdGlvbnMgfSA9IHZhckRlY05vZGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaCgnLCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbnNbaV07XG4gICAgICBjb25zdCBpbmZvID0gdGhpcy5nZXREZWNsYXJhdGlvbihkZWNsYXJhdGlvbi5pZCk7XG4gICAgICBpZiAoIWluZm8udmFsdWVUeXBlKSB7XG4gICAgICAgIGluZm8udmFsdWVUeXBlID0gdGhpcy5nZXRUeXBlKGRlY2xhcmF0aW9uLmluaXQpO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3RHZW5lcmljKGRlY2xhcmF0aW9uLCByZXRBcnIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNTdGF0ZSgnaW4tZm9yLWxvb3AtaW5pdCcpKSB7XG4gICAgICByZXRBcnIucHVzaCgnOycpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0SWZTdGF0ZW1lbnQoaWZOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnaWYgKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUudGVzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIGlmIChpZk5vZGUuY29uc2VxdWVudC50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCcge1xcbicpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJ1xcbn1cXG4nKTtcbiAgICB9XG5cbiAgICBpZiAoaWZOb2RlLmFsdGVybmF0ZSkge1xuICAgICAgcmV0QXJyLnB1c2goJ2Vsc2UgJyk7XG4gICAgICBpZiAoaWZOb2RlLmFsdGVybmF0ZS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnIHx8IGlmTm9kZS5hbHRlcm5hdGUudHlwZSA9PT0gJ0lmU3RhdGVtZW50Jykge1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmFsdGVybmF0ZSwgcmV0QXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldEFyci5wdXNoKCcge1xcbicpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmFsdGVybmF0ZSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ1xcbn1cXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcblxuICB9XG5cbiAgYXN0U3dpdGNoU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgY29uc3QgeyBkaXNjcmltaW5hbnQsIGNhc2VzIH0gPSBhc3Q7XG4gICAgcmV0QXJyLnB1c2goJ3N3aXRjaCAoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGRpc2NyaW1pbmFudCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKSB7XFxuJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNhc2VzW2ldLnRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgcmV0QXJyLnB1c2goJ2RlZmF1bHQ6XFxuJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhjYXNlc1tpXS5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgICAgICBpZiAoY2FzZXNbaV0uY29uc2VxdWVudCAmJiBjYXNlc1tpXS5jb25zZXF1ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnYnJlYWs7XFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXRBcnIucHVzaCgnY2FzZSAnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhjYXNlc1tpXS50ZXN0LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJzpcXG4nKTtcbiAgICAgIGlmIChjYXNlc1tpXS5jb25zZXF1ZW50ICYmIGNhc2VzW2ldLmNvbnNlcXVlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoY2FzZXNbaV0uY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ2JyZWFrO1xcbicpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXRBcnIucHVzaCgnXFxufScpO1xuICB9XG5cbiAgYXN0VGhpc0V4cHJlc3Npb24odE5vZGUsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKCdfdGhpcycpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RNZW1iZXJFeHByZXNzaW9uKG1Ob2RlLCByZXRBcnIpIHtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYXR1cmUsXG4gICAgICB0eXBlLFxuICAgICAgcHJvcGVydHksXG4gICAgICB4UHJvcGVydHksXG4gICAgICB5UHJvcGVydHksXG4gICAgICB6UHJvcGVydHksXG4gICAgICBuYW1lLFxuICAgICAgb3JpZ2luXG4gICAgfSA9IHRoaXMuZ2V0TWVtYmVyRXhwcmVzc2lvbkRldGFpbHMobU5vZGUpO1xuICAgIHN3aXRjaCAoc2lnbmF0dXJlKSB7XG4gICAgICBjYXNlICd0aGlzLnRocmVhZC52YWx1ZSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBfdGhpcy50aHJlYWQuJHsgbmFtZSB9YCk7XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICBjYXNlICd0aGlzLm91dHB1dC52YWx1ZSc6XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ291dHB1dFgnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ291dHB1dFknKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ291dHB1dFonKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBtTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuICAgICAgY2FzZSAndmFsdWVbXSc6XG4gICAgICBjYXNlICd2YWx1ZVtdW10nOlxuICAgICAgY2FzZSAndmFsdWVbXVtdW10nOlxuICAgICAgY2FzZSAndmFsdWUudmFsdWUnOlxuICAgICAgICBpZiAob3JpZ2luID09PSAnTWF0aCcpIHtcbiAgICAgICAgICByZXRBcnIucHVzaChNYXRoW25hbWVdKTtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IG5hbWUgfVswXWApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IG5hbWUgfVsxXWApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IG5hbWUgfVsyXWApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IG5hbWUgfVszXWApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlJzpcbiAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW10nOlxuICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdJzpcbiAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmbigpW10nOlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMobU5vZGUucHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICBjYXNlICdmbigpW11bXSc6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3Qub2JqZWN0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LnByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMobU5vZGUucHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBtTm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKCFtTm9kZS5jb21wdXRlZCkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgICAgIHJldEFyci5wdXNoKGAke29yaWdpbn1fJHtuYW1lfWApO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWFya3VwTmFtZSA9IGAke29yaWdpbn1fJHtuYW1lfWA7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgyKSc6XG4gICAgICBjYXNlICdNYXRyaXgoMyknOlxuICAgICAgY2FzZSAnTWF0cml4KDQpJzpcbiAgICAgIGNhc2UgJ0hUTUxJbWFnZUFycmF5JzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoMiknOlxuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGV0IHNpemU7XG4gICAgICAgIGxldCBpc0lucHV0O1xuICAgICAgICBpZiAob3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgICAgIGNvbnN0IGNvbnN0YW50ID0gdGhpcy5jb25zdGFudHNbbmFtZV07XG4gICAgICAgICAgaXNJbnB1dCA9IHRoaXMuY29uc3RhbnRUeXBlc1tuYW1lXSA9PT0gJ0lucHV0JztcbiAgICAgICAgICBzaXplID0gaXNJbnB1dCA/IGNvbnN0YW50LnNpemUgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzSW5wdXQgPSB0aGlzLmlzSW5wdXQobmFtZSk7XG4gICAgICAgICAgc2l6ZSA9IGlzSW5wdXQgPyB0aGlzLmFyZ3VtZW50U2l6ZXNbdGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YobmFtZSldIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXRBcnIucHVzaChgJHsgbWFya3VwTmFtZSB9YCk7XG4gICAgICAgIGlmICh6UHJvcGVydHkgJiYgeVByb3BlcnR5KSB7XG4gICAgICAgICAgaWYgKGlzSW5wdXQpIHtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdbKCcpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGAqJHsgdGhpcy5keW5hbWljQXJndW1lbnRzID8gJyhvdXRwdXRZICogb3V0cHV0WCknIDogc2l6ZVsxXSAqIHNpemVbMF0gfSkrKGApO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHlQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGAqJHsgdGhpcy5keW5hbWljQXJndW1lbnRzID8gJ291dHB1dFgnIDogc2l6ZVswXSB9KStgKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh4UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHlQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHhQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHlQcm9wZXJ0eSkge1xuICAgICAgICAgIGlmIChpc0lucHV0KSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnWygnKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh5UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaChgKiR7IHRoaXMuZHluYW1pY0FyZ3VtZW50cyA/ICdvdXRwdXRYJyA6IHNpemVbMF0gfSkrYCk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeFByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh5UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh4UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgeFByb3BlcnR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHhQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RDYWxsRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ0NhbGxFeHByZXNzaW9uJykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5rbm93biBDYWxsRXhwcmVzc2lvbicsIGFzdCk7XG4gICAgfVxuICAgIGxldCBmdW5jdGlvbk5hbWUgPSB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0LmNhbGxlZSk7XG5cbiAgICBpZiAodGhpcy5jYWxsZWRGdW5jdGlvbnMuaW5kZXhPZihmdW5jdGlvbk5hbWUpIDwgMCkge1xuICAgICAgdGhpcy5jYWxsZWRGdW5jdGlvbnMucHVzaChmdW5jdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzTWF0aEZ1bmN0aW9uID0gdGhpcy5pc0FzdE1hdGhGdW5jdGlvbihhc3QpO1xuXG4gICAgaWYgKHRoaXMub25GdW5jdGlvbkNhbGwpIHtcbiAgICAgIHRoaXMub25GdW5jdGlvbkNhbGwodGhpcy5uYW1lLCBmdW5jdGlvbk5hbWUsIGFzdC5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldEFyci5wdXNoKGZ1bmN0aW9uTmFtZSk7XG5cbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIGNvbnN0IHRhcmdldFR5cGVzID0gdGhpcy5sb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMoZnVuY3Rpb25OYW1lKSB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5hcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGFyZ3VtZW50ID0gYXN0LmFyZ3VtZW50c1tpXTtcblxuICAgICAgbGV0IGFyZ3VtZW50VHlwZSA9IHRoaXMuZ2V0VHlwZShhcmd1bWVudCk7XG4gICAgICBpZiAoIXRhcmdldFR5cGVzW2ldKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckltcGx5QXJndW1lbnRUeXBlKGZ1bmN0aW9uTmFtZSwgaSwgYXJndW1lbnRUeXBlLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHJldEFyci5wdXNoKCcsICcpO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKScpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEFycmF5RXhwcmVzc2lvbihhcnJOb2RlLCByZXRBcnIpIHtcbiAgICBjb25zdCByZXR1cm5UeXBlID0gdGhpcy5nZXRUeXBlKGFyck5vZGUpO1xuICAgIGNvbnN0IGFyckxlbiA9IGFyck5vZGUuZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJMZW47ICsraSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IFtdO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFyck5vZGUuZWxlbWVudHNbaV0sIGVsZW1lbnQpO1xuICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50LmpvaW4oJycpKTtcbiAgICB9XG4gICAgc3dpdGNoIChyZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdNYXRyaXgoMiknOlxuICAgICAgY2FzZSAnTWF0cml4KDMpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCg0KSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBbJHtlbGVtZW50cy5qb2luKCcsICcpfV1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXRBcnIucHVzaChgbmV3IEZsb2F0MzJBcnJheShbJHtlbGVtZW50cy5qb2luKCcsICcpfV0pYCk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3REZWJ1Z2dlclN0YXRlbWVudChhcnJOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnZGVidWdnZXI7Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1BVRnVuY3Rpb25Ob2RlXG59O1xufSx7XCIuLi9mdW5jdGlvbi1ub2RlXCI6MTB9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGNvbnN0YW50c1RvU3RyaW5nKGNvbnN0YW50cywgdHlwZXMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gdHlwZXMpIHtcbiAgICBpZiAoIXR5cGVzLmhhc093blByb3BlcnR5KG5hbWUpKSBjb250aW51ZTtcbiAgICBjb25zdCB0eXBlID0gdHlwZXNbbmFtZV07XG4gICAgY29uc3QgY29uc3RhbnQgPSBjb25zdGFudHNbbmFtZV07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgICAgcmVzdWx0cy5wdXNoKGAke25hbWV9OiR7Y29uc3RhbnR9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgY2FzZSAnTWF0cml4KDIpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgzKSc6XG4gICAgICBjYXNlICdNYXRyaXgoNCknOlxuICAgICAgICByZXN1bHRzLnB1c2goYCR7bmFtZX06bmV3ICR7Y29uc3RhbnQuY29uc3RydWN0b3IubmFtZX0oJHtKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKGNvbnN0YW50KSl9KWApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGB7ICR7IHJlc3VsdHMuam9pbigpIH0gfWA7XG59XG5cbmZ1bmN0aW9uIGNwdUtlcm5lbFN0cmluZyhjcHVLZXJuZWwsIG5hbWUpIHtcbiAgY29uc3QgaGVhZGVyID0gW107XG4gIGNvbnN0IHRoaXNQcm9wZXJ0aWVzID0gW107XG4gIGNvbnN0IGJlZm9yZVJldHVybiA9IFtdO1xuXG4gIGNvbnN0IHVzZUZ1bmN0aW9uS2V5d29yZCA9ICEvXmZ1bmN0aW9uLy50ZXN0KGNwdUtlcm5lbC5jb2xvci50b1N0cmluZygpKTtcblxuICBoZWFkZXIucHVzaChcbiAgICAnICBjb25zdCB7IGNvbnRleHQsIGNhbnZhcywgY29uc3RhbnRzOiBpbmNvbWluZ0NvbnN0YW50cyB9ID0gc2V0dGluZ3M7JyxcbiAgICBgICBjb25zdCBvdXRwdXQgPSBuZXcgSW50MzJBcnJheSgke0pTT04uc3RyaW5naWZ5KEFycmF5LmZyb20oY3B1S2VybmVsLm91dHB1dCkpfSk7YCxcbiAgICBgICBjb25zdCBfY29uc3RhbnRUeXBlcyA9ICR7SlNPTi5zdHJpbmdpZnkoY3B1S2VybmVsLmNvbnN0YW50VHlwZXMpfTtgLFxuICAgIGAgIGNvbnN0IF9jb25zdGFudHMgPSAke2NvbnN0YW50c1RvU3RyaW5nKGNwdUtlcm5lbC5jb25zdGFudHMsIGNwdUtlcm5lbC5jb25zdGFudFR5cGVzKX07YFxuICApO1xuXG4gIHRoaXNQcm9wZXJ0aWVzLnB1c2goXG4gICAgJyAgICBjb25zdGFudHM6IF9jb25zdGFudHMsJyxcbiAgICAnICAgIGNvbnRleHQsJyxcbiAgICAnICAgIG91dHB1dCwnLFxuICAgICcgICAgdGhyZWFkOiB7eDogMCwgeTogMCwgejogMH0sJ1xuICApO1xuXG4gIGlmIChjcHVLZXJuZWwuZ3JhcGhpY2FsKSB7XG4gICAgaGVhZGVyLnB1c2goYCAgY29uc3QgX2ltYWdlRGF0YSA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKCR7Y3B1S2VybmVsLm91dHB1dFswXX0sICR7Y3B1S2VybmVsLm91dHB1dFsxXX0pO2ApO1xuICAgIGhlYWRlci5wdXNoKGAgIGNvbnN0IF9jb2xvckRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoJHtjcHVLZXJuZWwub3V0cHV0WzBdfSAqICR7Y3B1S2VybmVsLm91dHB1dFsxXX0gKiA0KTtgKTtcblxuICAgIGNvbnN0IGNvbG9yRm4gPSB1dGlscy5mbGF0dGVuRnVuY3Rpb25Ub1N0cmluZygodXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJykgKyBjcHVLZXJuZWwuY29sb3IudG9TdHJpbmcoKSwge1xuICAgICAgdGhpc0xvb2t1cDogKHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgJ19jb2xvckRhdGEnOlxuICAgICAgICAgICAgcmV0dXJuICdfY29sb3JEYXRhJztcbiAgICAgICAgICBjYXNlICdfaW1hZ2VEYXRhJzpcbiAgICAgICAgICAgIHJldHVybiAnX2ltYWdlRGF0YSc7XG4gICAgICAgICAgY2FzZSAnb3V0cHV0JzpcbiAgICAgICAgICAgIHJldHVybiAnb3V0cHV0JztcbiAgICAgICAgICBjYXNlICd0aHJlYWQnOlxuICAgICAgICAgICAgcmV0dXJuICd0aGlzLnRocmVhZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNwdUtlcm5lbFtwcm9wZXJ0eU5hbWVdKTtcbiAgICAgIH0sXG4gICAgICBmaW5kRGVwZW5kZW5jeTogKG9iamVjdCwgbmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGdldFBpeGVsc0ZuID0gdXRpbHMuZmxhdHRlbkZ1bmN0aW9uVG9TdHJpbmcoKHVzZUZ1bmN0aW9uS2V5d29yZCA/ICdmdW5jdGlvbiAnIDogJycpICsgY3B1S2VybmVsLmdldFBpeGVscy50b1N0cmluZygpLCB7XG4gICAgICB0aGlzTG9va3VwOiAocHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgY2FzZSAnX2NvbG9yRGF0YSc6XG4gICAgICAgICAgICByZXR1cm4gJ19jb2xvckRhdGEnO1xuICAgICAgICAgIGNhc2UgJ19pbWFnZURhdGEnOlxuICAgICAgICAgICAgcmV0dXJuICdfaW1hZ2VEYXRhJztcbiAgICAgICAgICBjYXNlICdvdXRwdXQnOlxuICAgICAgICAgICAgcmV0dXJuICdvdXRwdXQnO1xuICAgICAgICAgIGNhc2UgJ3RocmVhZCc6XG4gICAgICAgICAgICByZXR1cm4gJ3RoaXMudGhyZWFkJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY3B1S2VybmVsW3Byb3BlcnR5TmFtZV0pO1xuICAgICAgfSxcbiAgICAgIGZpbmREZXBlbmRlbmN5OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpc1Byb3BlcnRpZXMucHVzaChcbiAgICAgICcgICAgX2ltYWdlRGF0YSwnLFxuICAgICAgJyAgICBfY29sb3JEYXRhLCcsXG4gICAgICBgICAgIGNvbG9yOiAke2NvbG9yRm59LGBcbiAgICApO1xuXG4gICAgYmVmb3JlUmV0dXJuLnB1c2goXG4gICAgICBgICBrZXJuZWwuZ2V0UGl4ZWxzID0gJHtnZXRQaXhlbHNGbn07YFxuICAgICk7XG4gIH1cblxuICBjb25zdCBjb25zdGFudFR5cGVzID0gW107XG4gIGNvbnN0IGNvbnN0YW50S2V5cyA9IE9iamVjdC5rZXlzKGNwdUtlcm5lbC5jb25zdGFudFR5cGVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25zdGFudEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdGFudFR5cGVzLnB1c2goY3B1S2VybmVsLmNvbnN0YW50VHlwZXNbY29uc3RhbnRLZXlzXSk7XG4gIH1cbiAgaWYgKGNwdUtlcm5lbC5hcmd1bWVudFR5cGVzLmluZGV4T2YoJ0hUTUxJbWFnZUFycmF5JykgIT09IC0xIHx8IGNvbnN0YW50VHlwZXMuaW5kZXhPZignSFRNTEltYWdlQXJyYXknKSAhPT0gLTEpIHtcbiAgICBjb25zdCBmbGF0dGVuZWRJbWFnZVRvM0RBcnJheSA9IHV0aWxzLmZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nKCh1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnKSArIGNwdUtlcm5lbC5faW1hZ2VUbzNEQXJyYXkudG9TdHJpbmcoKSwge1xuICAgICAgZG9Ob3REZWZpbmU6IFsnY2FudmFzJ10sXG4gICAgICBmaW5kRGVwZW5kZW5jeTogKG9iamVjdCwgbmFtZSkgPT4ge1xuICAgICAgICBpZiAob2JqZWN0ID09PSAndGhpcycpIHtcbiAgICAgICAgICByZXR1cm4gKHVzZUZ1bmN0aW9uS2V5d29yZCA/ICdmdW5jdGlvbiAnIDogJycpICsgY3B1S2VybmVsW25hbWVdLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgdGhpc0xvb2t1cDogKHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgICByZXR1cm4gJ2NvbnRleHQnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgYmVmb3JlUmV0dXJuLnB1c2goZmxhdHRlbmVkSW1hZ2VUbzNEQXJyYXkpO1xuICAgIHRoaXNQcm9wZXJ0aWVzLnB1c2goYCAgICBfbWVkaWFUbzJEQXJyYXksYCk7XG4gICAgdGhpc1Byb3BlcnRpZXMucHVzaChgICAgIF9pbWFnZVRvM0RBcnJheSxgKTtcbiAgfSBlbHNlIGlmIChjcHVLZXJuZWwuYXJndW1lbnRUeXBlcy5pbmRleE9mKCdIVE1MSW1hZ2UnKSAhPT0gLTEgfHwgY29uc3RhbnRUeXBlcy5pbmRleE9mKCdIVE1MSW1hZ2UnKSAhPT0gLTEpIHtcbiAgICBjb25zdCBmbGF0dGVuZWRJbWFnZVRvMkRBcnJheSA9IHV0aWxzLmZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nKCh1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnKSArIGNwdUtlcm5lbC5fbWVkaWFUbzJEQXJyYXkudG9TdHJpbmcoKSwge1xuICAgICAgZmluZERlcGVuZGVuY3k6IChvYmplY3QsIG5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgdGhpc0xvb2t1cDogKHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgICAgICAgICByZXR1cm4gJ3NldHRpbmdzLmNhbnZhcyc7XG4gICAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgICByZXR1cm4gJ3NldHRpbmdzLmNvbnRleHQnO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5oYW5kbGVkIHRoaXNMb29rdXAnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBiZWZvcmVSZXR1cm4ucHVzaChmbGF0dGVuZWRJbWFnZVRvMkRBcnJheSk7XG4gICAgdGhpc1Byb3BlcnRpZXMucHVzaChgICAgIF9tZWRpYVRvMkRBcnJheSxgKTtcbiAgfVxuXG4gIHJldHVybiBgZnVuY3Rpb24oc2V0dGluZ3MpIHtcbiR7IGhlYWRlci5qb2luKCdcXG4nKSB9XG4gIGZvciAoY29uc3QgcCBpbiBfY29uc3RhbnRUeXBlcykge1xuICAgIGlmICghX2NvbnN0YW50VHlwZXMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IHR5cGUgPSBfY29uc3RhbnRUeXBlc1twXTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgY2FzZSAnTWF0cml4KDIpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgzKSc6XG4gICAgICBjYXNlICdNYXRyaXgoNCknOlxuICAgICAgICBpZiAoaW5jb21pbmdDb25zdGFudHMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2NvbnN0YW50ICcgKyBwICsgJyBvZiB0eXBlICcgKyB0eXBlICsgJyBjYW5ub3QgYmUgcmVzaWduZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFpbmNvbWluZ0NvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb25zdGFudCAnICsgcCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIF9jb25zdGFudHNbcF0gPSBpbmNvbWluZ0NvbnN0YW50c1twXTtcbiAgfVxuICBjb25zdCBrZXJuZWwgPSAoZnVuY3Rpb24oKSB7XG4ke2NwdUtlcm5lbC5fa2VybmVsU3RyaW5nfVxuICB9KVxuICAgIC5hcHBseSh7ICR7dGhpc1Byb3BlcnRpZXMuam9pbignXFxuJyl9IH0pO1xuICAkeyBiZWZvcmVSZXR1cm4uam9pbignXFxuJykgfVxuICByZXR1cm4ga2VybmVsO1xufWA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcHVLZXJuZWxTdHJpbmdcbn07XG59LHtcIi4uLy4uL3V0aWxzXCI6MTE0fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IEtlcm5lbCB9ID0gcmVxdWlyZSgnLi4va2VybmVsJyk7XG5jb25zdCB7IEZ1bmN0aW9uQnVpbGRlciB9ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tYnVpbGRlcicpO1xuY29uc3QgeyBDUFVGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgY3B1S2VybmVsU3RyaW5nIH0gPSByZXF1aXJlKCcuL2tlcm5lbC1zdHJpbmcnKTtcblxuY2xhc3MgQ1BVS2VybmVsIGV4dGVuZHMgS2VybmVsIHtcbiAgc3RhdGljIGdldEZlYXR1cmVzKCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzO1xuICB9XG4gIHN0YXRpYyBnZXQgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAga2VybmVsTWFwOiB0cnVlLFxuICAgICAgaXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGlzQ29udGV4dE1hdGNoKGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGdldCBtb2RlKCkge1xuICAgIHJldHVybiAnY3B1JztcbiAgfVxuXG4gIHN0YXRpYyBuYXRpdmVGdW5jdGlvbkFyZ3VtZW50cygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBuYXRpdmVGdW5jdGlvblJldHVyblR5cGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBMb29raW5nIHVwIG5hdGl2ZSBmdW5jdGlvbiByZXR1cm4gdHlwZSBub3Qgc3VwcG9ydGVkIG9uICR7dGhpcy5uYW1lfWApO1xuICB9XG5cbiAgc3RhdGljIGNvbWJpbmVLZXJuZWxzKGNvbWJpbmVkS2VybmVsKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVkS2VybmVsO1xuICB9XG5cbiAgc3RhdGljIGdldFNpZ25hdHVyZShrZXJuZWwsIGFyZ3VtZW50VHlwZXMpIHtcbiAgICByZXR1cm4gJ2NwdScgKyAoYXJndW1lbnRUeXBlcy5sZW5ndGggPiAwID8gJzonICsgYXJndW1lbnRUeXBlcy5qb2luKCcsJykgOiAnJyk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc291cmNlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5tZXJnZVNldHRpbmdzKHNvdXJjZS5zZXR0aW5ncyB8fCBzZXR0aW5ncyk7XG5cbiAgICB0aGlzLl9pbWFnZURhdGEgPSBudWxsO1xuICAgIHRoaXMuX2NvbG9yRGF0YSA9IG51bGw7XG4gICAgdGhpcy5fa2VybmVsU3RyaW5nID0gbnVsbDtcbiAgICB0aGlzLl9wcmVwZW5kZWRTdHJpbmcgPSBbXTtcbiAgICB0aGlzLnRocmVhZCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgejogMFxuICAgIH07XG4gICAgdGhpcy50cmFuc2xhdGVkU291cmNlcyA9IG51bGw7XG4gIH1cblxuICBpbml0Q2FudmFzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMCwgMCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdENvbnRleHQoKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcykgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIH1cblxuICBpbml0UGx1Z2lucyhzZXR0aW5ncykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhbGlkYXRlU2V0dGluZ3MoYXJncykge1xuICAgIGlmICghdGhpcy5vdXRwdXQgfHwgdGhpcy5vdXRwdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBvbmx5IHN1cHBvcnRlZCBmb3Iga2VybmVscyB3aXRoIG9ubHkgb25lIGlucHV0Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFyZ1R5cGUgPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUoYXJnc1swXSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICBpZiAoYXJnVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICB0aGlzLm91dHB1dCA9IHV0aWxzLmdldERpbWVuc2lvbnMoYXJnVHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdOdW1iZXJUZXh0dXJlJyB8fCBhcmdUeXBlID09PSAnQXJyYXlUZXh0dXJlKDQpJykge1xuICAgICAgICB0aGlzLm91dHB1dCA9IGFyZ3NbMF0ub3V0cHV0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBub3Qgc3VwcG9ydGVkIGZvciBpbnB1dCB0eXBlOiAnICsgYXJnVHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICBpZiAodGhpcy5vdXRwdXQubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0cHV0IG11c3QgaGF2ZSAyIGRpbWVuc2lvbnMgb24gZ3JhcGhpY2FsIG1vZGUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrT3V0cHV0KCk7XG4gIH1cblxuICB0cmFuc2xhdGVTb3VyY2UoKSB7XG4gICAgdGhpcy5sZWFkaW5nUmV0dXJuU3RhdGVtZW50ID0gdGhpcy5vdXRwdXQubGVuZ3RoID4gMSA/ICdyZXN1bHRYW3hdID0gJyA6ICdyZXN1bHRbeF0gPSAnO1xuICAgIGlmICh0aGlzLnN1Yktlcm5lbHMpIHtcbiAgICAgIGNvbnN0IGZvbGxvd2luZ1JldHVyblN0YXRlbWVudCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgICAgZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50LnB1c2godGhpcy5vdXRwdXQubGVuZ3RoID4gMSA/IGByZXN1bHRYXyR7IG5hbWUgfVt4XSA9IHN1Yktlcm5lbFJlc3VsdF8keyBuYW1lIH07XFxuYCA6IGByZXN1bHRfJHsgbmFtZSB9W3hdID0gc3ViS2VybmVsUmVzdWx0XyR7IG5hbWUgfTtcXG5gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50ID0gZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50LmpvaW4oJycpO1xuICAgIH1cbiAgICBjb25zdCBmdW5jdGlvbkJ1aWxkZXIgPSBGdW5jdGlvbkJ1aWxkZXIuZnJvbUtlcm5lbCh0aGlzLCBDUFVGdW5jdGlvbk5vZGUpO1xuICAgIHRoaXMudHJhbnNsYXRlZFNvdXJjZXMgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0UHJvdG90eXBlcygna2VybmVsJyk7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNhbCAmJiAhdGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICB0aGlzLnJldHVyblR5cGUgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0S2VybmVsUmVzdWx0VHlwZSgpO1xuICAgIH1cbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIGlmICh0aGlzLmJ1aWx0KSByZXR1cm47XG4gICAgdGhpcy5zZXR1cENvbnN0YW50cygpO1xuICAgIHRoaXMuc2V0dXBBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICB0aGlzLnZhbGlkYXRlU2V0dGluZ3MoYXJndW1lbnRzKTtcbiAgICB0aGlzLnRyYW5zbGF0ZVNvdXJjZSgpO1xuXG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNhbnZhcyxcbiAgICAgICAgb3V0cHV0XG4gICAgICB9ID0gdGhpcztcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gY2FudmFzIGF2YWlsYWJsZSBmb3IgdXNpbmcgZ3JhcGhpY2FsIG91dHB1dCcpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lkdGggPSBvdXRwdXRbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSBvdXRwdXRbMV0gfHwgMTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuX2ltYWdlRGF0YSA9IHRoaXMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLl9jb2xvckRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXJuZWxTdHJpbmcgPSB0aGlzLmdldEtlcm5lbFN0cmluZygpO1xuICAgIHRoaXMua2VybmVsU3RyaW5nID0ga2VybmVsU3RyaW5nO1xuXG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdGdW5jdGlvbiBvdXRwdXQ6Jyk7XG4gICAgICBjb25zb2xlLmxvZyhrZXJuZWxTdHJpbmcpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLnJ1biA9IG5ldyBGdW5jdGlvbihbXSwga2VybmVsU3RyaW5nKS5iaW5kKHRoaXMpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgY29tcGlsaW5nIHRoZSBqYXZhc2NyaXB0OiAnLCBlKTtcbiAgICB9XG4gICAgdGhpcy5idWlsZFNpZ25hdHVyZShhcmd1bWVudHMpO1xuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgY29sb3IociwgZywgYiwgYSkge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGEgPSAxO1xuICAgIH1cblxuICAgIHIgPSBNYXRoLmZsb29yKHIgKiAyNTUpO1xuICAgIGcgPSBNYXRoLmZsb29yKGcgKiAyNTUpO1xuICAgIGIgPSBNYXRoLmZsb29yKGIgKiAyNTUpO1xuICAgIGEgPSBNYXRoLmZsb29yKGEgKiAyNTUpO1xuXG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLm91dHB1dFsxXTtcblxuICAgIGNvbnN0IHggPSB0aGlzLnRocmVhZC54O1xuICAgIGNvbnN0IHkgPSBoZWlnaHQgLSB0aGlzLnRocmVhZC55IC0gMTtcblxuICAgIGNvbnN0IGluZGV4ID0geCArIHkgKiB3aWR0aDtcblxuICAgIHRoaXMuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAwXSA9IHI7XG4gICAgdGhpcy5fY29sb3JEYXRhW2luZGV4ICogNCArIDFdID0gZztcbiAgICB0aGlzLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgMl0gPSBiO1xuICAgIHRoaXMuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAzXSA9IGE7XG4gIH1cblxuICBnZXRLZXJuZWxTdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2tlcm5lbFN0cmluZyAhPT0gbnVsbCkgcmV0dXJuIHRoaXMuX2tlcm5lbFN0cmluZztcblxuICAgIGxldCBrZXJuZWxUaHJlYWRTdHJpbmcgPSBudWxsO1xuICAgIGxldCB7XG4gICAgICB0cmFuc2xhdGVkU291cmNlc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICh0cmFuc2xhdGVkU291cmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0cmFuc2xhdGVkU291cmNlcyA9IHRyYW5zbGF0ZWRTb3VyY2VzLmZpbHRlcihmbiA9PiB7XG4gICAgICAgIGlmICgvXmZ1bmN0aW9uLy50ZXN0KGZuKSkgcmV0dXJuIGZuO1xuICAgICAgICBrZXJuZWxUaHJlYWRTdHJpbmcgPSBmbjtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtlcm5lbFRocmVhZFN0cmluZyA9IHRyYW5zbGF0ZWRTb3VyY2VzLnNoaWZ0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9rZXJuZWxTdHJpbmcgPSBgICBjb25zdCBMT09QX01BWCA9ICR7IHRoaXMuX2dldExvb3BNYXhTdHJpbmcoKSB9O1xuICAkeyB0aGlzLmluamVjdGVkTmF0aXZlIHx8ICcnIH1cbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAkeyB0aGlzLl9yZXN1bHRLZXJuZWxIZWFkZXIoKSB9XG4gICR7IHRoaXMuX3Byb2Nlc3NDb25zdGFudHMoKSB9XG4gIHJldHVybiAoJHsgdGhpcy5hcmd1bWVudE5hbWVzLm1hcChhcmd1bWVudE5hbWUgPT4gJ3VzZXJfJyArIGFyZ3VtZW50TmFtZSkuam9pbignLCAnKSB9KSA9PiB7XG4gICAgJHsgdGhpcy5fcHJlcGVuZGVkU3RyaW5nLmpvaW4oJycpIH1cbiAgICAkeyB0aGlzLl9lYXJseVRocm93cygpIH1cbiAgICAkeyB0aGlzLl9wcm9jZXNzQXJndW1lbnRzKCkgfVxuICAgICR7IHRoaXMuZ3JhcGhpY2FsID8gdGhpcy5fZ3JhcGhpY2FsS2VybmVsQm9keShrZXJuZWxUaHJlYWRTdHJpbmcpIDogdGhpcy5fcmVzdWx0S2VybmVsQm9keShrZXJuZWxUaHJlYWRTdHJpbmcpIH1cbiAgICAkeyB0cmFuc2xhdGVkU291cmNlcy5sZW5ndGggPiAwID8gdHJhbnNsYXRlZFNvdXJjZXMuam9pbignXFxuJykgOiAnJyB9XG4gIH07YDtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBjcHVLZXJuZWxTdHJpbmcodGhpcyk7XG4gIH1cblxuICBfZ2V0TG9vcE1heFN0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb29wTWF4SXRlcmF0aW9ucyA/XG4gICAgICBgICR7IHBhcnNlSW50KHRoaXMubG9vcE1heEl0ZXJhdGlvbnMpIH07YCA6XG4gICAgICAnIDEwMDA7J1xuICAgICk7XG4gIH1cblxuICBfcHJvY2Vzc0NvbnN0YW50cygpIHtcbiAgICBpZiAoIXRoaXMuY29uc3RhbnRzKSByZXR1cm4gJyc7XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBwIGluIHRoaXMuY29uc3RhbnRzKSB7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy5jb25zdGFudFR5cGVzW3BdO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ0hUTUxDYW52YXMnOlxuICAgICAgICBjYXNlICdPZmZzY3JlZW5DYW52YXMnOlxuICAgICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgICBjYXNlICdJbWFnZUJpdG1hcCc6XG4gICAgICAgIGNhc2UgJ0ltYWdlRGF0YSc6XG4gICAgICAgIGNhc2UgJ0hUTUxWaWRlbyc6XG4gICAgICAgICAgcmVzdWx0LnB1c2goYCAgICBjb25zdCBjb25zdGFudHNfJHtwfSA9IHRoaXMuX21lZGlhVG8yREFycmF5KHRoaXMuY29uc3RhbnRzLiR7cH0pO1xcbmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG4gICAgICAgICAgcmVzdWx0LnB1c2goYCAgICBjb25zdCBjb25zdGFudHNfJHtwfSA9IHRoaXMuX2ltYWdlVG8zREFycmF5KHRoaXMuY29uc3RhbnRzLiR7cH0pO1xcbmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdJbnB1dCc6XG4gICAgICAgICAgcmVzdWx0LnB1c2goYCAgICBjb25zdCBjb25zdGFudHNfJHtwfSA9IHRoaXMuY29uc3RhbnRzLiR7cH0udmFsdWU7XFxuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVzdWx0LnB1c2goYCAgICBjb25zdCBjb25zdGFudHNfJHtwfSA9IHRoaXMuY29uc3RhbnRzLiR7cH07XFxuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gIH1cblxuICBfZWFybHlUaHJvd3MoKSB7XG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSByZXR1cm4gJyc7XG4gICAgaWYgKHRoaXMuaW1tdXRhYmxlKSByZXR1cm4gJyc7XG4gICAgaWYgKCF0aGlzLnBpcGVsaW5lKSByZXR1cm4gJyc7XG4gICAgY29uc3QgYXJyYXlBcmd1bWVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJndW1lbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuYXJndW1lbnRUeXBlc1tpXSA9PT0gJ0FycmF5Jykge1xuICAgICAgICBhcnJheUFyZ3VtZW50cy5wdXNoKHRoaXMuYXJndW1lbnROYW1lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcnJheUFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICBjb25zdCBjaGVja3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5QXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmd1bWVudE5hbWUgPSBhcnJheUFyZ3VtZW50c1tpXTtcbiAgICAgIGNvbnN0IGNoZWNrU3ViS2VybmVscyA9IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGB1c2VyXyR7YXJndW1lbnROYW1lfSA9PT0gcmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9YCkuam9pbignIHx8ICcpO1xuICAgICAgY2hlY2tzLnB1c2goYHVzZXJfJHthcmd1bWVudE5hbWV9ID09PSByZXN1bHQke2NoZWNrU3ViS2VybmVscyA/IGAgfHwgJHtjaGVja1N1Yktlcm5lbHN9YCA6ICcnfWApO1xuICAgIH1cbiAgICByZXR1cm4gYGlmICgke2NoZWNrcy5qb2luKCcgfHwgJyl9KSB0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBhbmQgZGVzdGluYXRpb24gYXJyYXlzIGFyZSB0aGUgc2FtZS4gIFVzZSBpbW11dGFibGUgPSB0cnVlJyk7YDtcbiAgfVxuXG4gIF9wcm9jZXNzQXJndW1lbnRzKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hcmd1bWVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBgdXNlcl8ke3RoaXMuYXJndW1lbnROYW1lc1tpXX1gO1xuICAgICAgc3dpdGNoICh0aGlzLmFyZ3VtZW50VHlwZXNbaV0pIHtcbiAgICAgICAgY2FzZSAnSFRNTENhbnZhcyc6XG4gICAgICAgIGNhc2UgJ09mZnNjcmVlbkNhbnZhcyc6XG4gICAgICAgIGNhc2UgJ0hUTUxJbWFnZSc6XG4gICAgICAgIGNhc2UgJ0ltYWdlQml0bWFwJzpcbiAgICAgICAgY2FzZSAnSW1hZ2VEYXRhJzpcbiAgICAgICAgY2FzZSAnSFRNTFZpZGVvJzpcbiAgICAgICAgICByZXN1bHQucHVzaChgICAgICR7dmFyaWFibGVOYW1lfSA9IHRoaXMuX21lZGlhVG8yREFycmF5KCR7dmFyaWFibGVOYW1lfSk7XFxuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0hUTUxJbWFnZUFycmF5JzpcbiAgICAgICAgICByZXN1bHQucHVzaChgICAgICR7dmFyaWFibGVOYW1lfSA9IHRoaXMuX2ltYWdlVG8zREFycmF5KCR7dmFyaWFibGVOYW1lfSk7XFxuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0lucHV0JzpcbiAgICAgICAgICByZXN1bHQucHVzaChgICAgICR7dmFyaWFibGVOYW1lfSA9ICR7dmFyaWFibGVOYW1lfS52YWx1ZTtcXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDIpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcbiAgICAgICAgY2FzZSAnTnVtYmVyVGV4dHVyZSc6XG4gICAgICAgIGNhc2UgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGBcbiAgICBpZiAoJHt2YXJpYWJsZU5hbWV9LnRvQXJyYXkpIHtcbiAgICAgIGlmICghX3RoaXMudGV4dHVyZUNhY2hlKSB7XG4gICAgICAgIF90aGlzLnRleHR1cmVDYWNoZSA9IFtdO1xuICAgICAgICBfdGhpcy5hcnJheUNhY2hlID0gW107XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0dXJlSW5kZXggPSBfdGhpcy50ZXh0dXJlQ2FjaGUuaW5kZXhPZigke3ZhcmlhYmxlTmFtZX0pO1xuICAgICAgaWYgKHRleHR1cmVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgJHt2YXJpYWJsZU5hbWV9ID0gX3RoaXMuYXJyYXlDYWNoZVt0ZXh0dXJlSW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMudGV4dHVyZUNhY2hlLnB1c2goJHt2YXJpYWJsZU5hbWV9KTtcbiAgICAgICAgJHt2YXJpYWJsZU5hbWV9ID0gJHt2YXJpYWJsZU5hbWV9LnRvQXJyYXkoKTtcbiAgICAgICAgX3RoaXMuYXJyYXlDYWNoZS5wdXNoKCR7dmFyaWFibGVOYW1lfSk7XG4gICAgICB9XG4gICAgfWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICB9XG5cbiAgX21lZGlhVG8yREFycmF5KG1lZGlhKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3Qgd2lkdGggPSBtZWRpYS53aWR0aCA+IDAgPyBtZWRpYS53aWR0aCA6IG1lZGlhLnZpZGVvV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gbWVkaWEuaGVpZ2h0ID4gMCA/IG1lZGlhLmhlaWdodCA6IG1lZGlhLnZpZGVvSGVpZ2h0O1xuICAgIGlmIChjYW52YXMud2lkdGggPCB3aWR0aCkge1xuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgfVxuICAgIGlmIChjYW52YXMuaGVpZ2h0IDwgaGVpZ2h0KSB7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgbGV0IHBpeGVsc0RhdGE7XG4gICAgaWYgKG1lZGlhLmNvbnN0cnVjdG9yID09PSBJbWFnZURhdGEpIHtcbiAgICAgIHBpeGVsc0RhdGEgPSBtZWRpYS5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguZHJhd0ltYWdlKG1lZGlhLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHBpeGVsc0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGltYWdlQXJyYXkgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAobGV0IHkgPSBoZWlnaHQgLSAxOyB5ID49IDA7IHktLSkge1xuICAgICAgY29uc3Qgcm93ID0gaW1hZ2VBcnJheVt5XSA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgY29uc3QgcGl4ZWwgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBwaXhlbFswXSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7IFxuICAgICAgICBwaXhlbFsxXSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7IFxuICAgICAgICBwaXhlbFsyXSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7IFxuICAgICAgICBwaXhlbFszXSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7IFxuICAgICAgICByb3dbeF0gPSBwaXhlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGltYWdlQXJyYXk7XG4gIH1cblxuICBnZXRQaXhlbHMoZmxpcCkge1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMub3V0cHV0O1xuICAgIHJldHVybiBmbGlwID8gdXRpbHMuZmxpcFBpeGVscyh0aGlzLl9pbWFnZURhdGEuZGF0YSwgd2lkdGgsIGhlaWdodCkgOiB0aGlzLl9pbWFnZURhdGEuZGF0YS5zbGljZSgwKTtcbiAgfVxuXG4gIF9pbWFnZVRvM0RBcnJheShpbWFnZXMpIHtcbiAgICBjb25zdCBpbWFnZXNBcnJheSA9IG5ldyBBcnJheShpbWFnZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaW1hZ2VzQXJyYXlbaV0gPSB0aGlzLl9tZWRpYVRvMkRBcnJheShpbWFnZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VzQXJyYXk7XG4gIH1cblxuICBfcmVzdWx0S2VybmVsSGVhZGVyKCkge1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkgcmV0dXJuICcnO1xuICAgIGlmICh0aGlzLmltbXV0YWJsZSkgcmV0dXJuICcnO1xuICAgIGlmICghdGhpcy5waXBlbGluZSkgcmV0dXJuICcnO1xuICAgIHN3aXRjaCAodGhpcy5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLl9tdXRhYmxlS2VybmVsMURSZXN1bHRzKCk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLl9tdXRhYmxlS2VybmVsMkRSZXN1bHRzKCk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLl9tdXRhYmxlS2VybmVsM0RSZXN1bHRzKCk7XG4gICAgfVxuICB9XG5cbiAgX3Jlc3VsdEtlcm5lbEJvZHkoa2VybmVsU3RyaW5nKSB7XG4gICAgc3dpdGNoICh0aGlzLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuICghdGhpcy5pbW11dGFibGUgJiYgdGhpcy5waXBlbGluZSA/IHRoaXMuX3Jlc3VsdE11dGFibGVLZXJuZWwxRExvb3Aoa2VybmVsU3RyaW5nKSA6IHRoaXMuX3Jlc3VsdEltbXV0YWJsZUtlcm5lbDFETG9vcChrZXJuZWxTdHJpbmcpKSArIHRoaXMuX2tlcm5lbE91dHB1dCgpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gKCF0aGlzLmltbXV0YWJsZSAmJiB0aGlzLnBpcGVsaW5lID8gdGhpcy5fcmVzdWx0TXV0YWJsZUtlcm5lbDJETG9vcChrZXJuZWxTdHJpbmcpIDogdGhpcy5fcmVzdWx0SW1tdXRhYmxlS2VybmVsMkRMb29wKGtlcm5lbFN0cmluZykpICsgdGhpcy5fa2VybmVsT3V0cHV0KCk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiAoIXRoaXMuaW1tdXRhYmxlICYmIHRoaXMucGlwZWxpbmUgPyB0aGlzLl9yZXN1bHRNdXRhYmxlS2VybmVsM0RMb29wKGtlcm5lbFN0cmluZykgOiB0aGlzLl9yZXN1bHRJbW11dGFibGVLZXJuZWwzRExvb3Aoa2VybmVsU3RyaW5nKSkgKyB0aGlzLl9rZXJuZWxPdXRwdXQoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgc2l6ZSBrZXJuZWwnKTtcbiAgICB9XG4gIH1cblxuICBfZ3JhcGhpY2FsS2VybmVsQm9keShrZXJuZWxUaHJlYWRTdHJpbmcpIHtcbiAgICBzd2l0Y2ggKHRoaXMub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY2FsS2VybmVsMkRMb29wKGtlcm5lbFRocmVhZFN0cmluZykgKyB0aGlzLl9ncmFwaGljYWxPdXRwdXQoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgc2l6ZSBrZXJuZWwnKTtcbiAgICB9XG4gIH1cblxuICBfZ3JhcGhpY2FsT3V0cHV0KCkge1xuICAgIHJldHVybiBgXG4gICAgdGhpcy5faW1hZ2VEYXRhLmRhdGEuc2V0KHRoaXMuX2NvbG9yRGF0YSk7XG4gICAgdGhpcy5jb250ZXh0LnB1dEltYWdlRGF0YSh0aGlzLl9pbWFnZURhdGEsIDAsIDApO1xuICAgIHJldHVybjtgXG4gIH1cblxuICBfZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCkge1xuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIHJldHVybiAnRmxvYXQzMkFycmF5JztcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgcmV0dXJuICdBcnJheSc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgICAgICByZXR1cm4gJ0Zsb2F0MzJBcnJheSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcmV0dXJuVHlwZSAkeyB0aGlzLnJldHVyblR5cGUgfWApO1xuICAgIH1cbiAgfVxuXG4gIF9yZXN1bHRJbW11dGFibGVLZXJuZWwxRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0cHV0WDsgeCsrKSB7XG4gICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgIHRoaXMudGhyZWFkLnkgPSAwO1xuICAgICAgdGhpcy50aHJlYWQueiA9IDA7XG4gICAgICAkeyBrZXJuZWxTdHJpbmcgfVxuICAgIH1gO1xuICB9XG5cbiAgX211dGFibGVLZXJuZWwxRFJlc3VsdHMoKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfWA7XG4gIH1cblxuICBfcmVzdWx0TXV0YWJsZUtlcm5lbDFETG9vcChrZXJuZWxTdHJpbmcpIHtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICB0aGlzLnRocmVhZC55ID0gMDtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9yZXN1bHRJbW11dGFibGVLZXJuZWwyRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCBvdXRwdXRZID0gX3RoaXMub3V0cHV0WzFdO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShvdXRwdXRZKTtcbiAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH0gPSBuZXcgQXJyYXkob3V0cHV0WSk7XFxuYCkuam9pbignICAgICcpIH1cbiAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgbGV0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9O1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRwdXRZOyB5KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xuICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFhfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcnKSB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9tdXRhYmxlS2VybmVsMkRSZXN1bHRzKCkge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yU3RyaW5nID0gdGhpcy5fZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCk7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0WSA9IF90aGlzLm91dHB1dFsxXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkob3V0cHV0WSk7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3IEFycmF5KG91dHB1dFkpO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0cHV0WTsgeSsrKSB7XG4gICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xuICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFhfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcnKSB9XG4gICAgfWA7XG4gIH1cblxuICBfcmVzdWx0TXV0YWJsZUtlcm5lbDJETG9vcChrZXJuZWxTdHJpbmcpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvclN0cmluZyA9IHRoaXMuX2dldEtlcm5lbFJlc3VsdFR5cGVDb25zdHJ1Y3RvclN0cmluZygpO1xuICAgIHJldHVybiBgICBjb25zdCBvdXRwdXRYID0gX3RoaXMub3V0cHV0WzBdO1xuICAgIGNvbnN0IG91dHB1dFkgPSBfdGhpcy5vdXRwdXRbMV07XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRwdXRZOyB5KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0W3ldO1xuICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFhfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcnKSB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9ncmFwaGljYWxLZXJuZWwyRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0WSA9IF90aGlzLm91dHB1dFsxXTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dHB1dFk7IHkrKykge1xuICAgICAgdGhpcy50aHJlYWQueiA9IDA7XG4gICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0cHV0WDsgeCsrKSB7XG4gICAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgICAkeyBrZXJuZWxTdHJpbmcgfVxuICAgICAgfVxuICAgIH1gO1xuICB9XG5cbiAgX3Jlc3VsdEltbXV0YWJsZUtlcm5lbDNETG9vcChrZXJuZWxTdHJpbmcpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvclN0cmluZyA9IHRoaXMuX2dldEtlcm5lbFJlc3VsdFR5cGVDb25zdHJ1Y3RvclN0cmluZygpO1xuICAgIHJldHVybiBgICBjb25zdCBvdXRwdXRYID0gX3RoaXMub3V0cHV0WzBdO1xuICAgIGNvbnN0IG91dHB1dFkgPSBfdGhpcy5vdXRwdXRbMV07XG4gICAgY29uc3Qgb3V0cHV0WiA9IF90aGlzLm91dHB1dFsyXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkob3V0cHV0Wik7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3IEFycmF5KG91dHB1dFopO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgIGZvciAobGV0IHogPSAwOyB6IDwgb3V0cHV0WjsgeisrKSB7XG4gICAgICB0aGlzLnRocmVhZC56ID0gejtcbiAgICAgIGNvbnN0IHJlc3VsdFkgPSByZXN1bHRbel0gPSBuZXcgQXJyYXkob3V0cHV0WSk7XG4gICAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0WV8keyBzdWJLZXJuZWwubmFtZSB9ID0gcmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9W3pdID0gbmV3IEFycmF5KG91dHB1dFkpO1xcbmApLmpvaW4oJyAgICAgICcpIH1cbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0cHV0WTsgeSsrKSB7XG4gICAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xuICAgICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0WVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcbiAgICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFhfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdFlfJHtzdWJLZXJuZWwubmFtZX1beV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XFxuYCkuam9pbignICAgICAgICAnKSB9XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0cHV0WDsgeCsrKSB7XG4gICAgICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1gO1xuICB9XG5cbiAgX211dGFibGVLZXJuZWwzRFJlc3VsdHMoKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCBvdXRwdXRZID0gX3RoaXMub3V0cHV0WzFdO1xuICAgIGNvbnN0IG91dHB1dFogPSBfdGhpcy5vdXRwdXRbMl07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KG91dHB1dFopO1xuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IG5ldyBBcnJheShvdXRwdXRaKTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBsZXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH07XFxuYCkuam9pbignICAgICcpIH1cbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8IG91dHB1dFo7IHorKykge1xuICAgICAgY29uc3QgcmVzdWx0WSA9IHJlc3VsdFt6XSA9IG5ldyBBcnJheShvdXRwdXRZKTtcbiAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRZXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bel0gPSBuZXcgQXJyYXkob3V0cHV0WSk7XFxuYCkuam9pbignICAgICAgJykgfVxuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRwdXRZOyB5KyspIHtcbiAgICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFlbeV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XG4gICAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRYXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRZXyR7c3ViS2VybmVsLm5hbWV9W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xcbmApLmpvaW4oJyAgICAgICAgJykgfVxuICAgICAgfVxuICAgIH1gO1xuICB9XG5cbiAgX3Jlc3VsdE11dGFibGVLZXJuZWwzRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0WSA9IF90aGlzLm91dHB1dFsxXTtcbiAgICBjb25zdCBvdXRwdXRaID0gX3RoaXMub3V0cHV0WzJdO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgb3V0cHV0WjsgeisrKSB7XG4gICAgICB0aGlzLnRocmVhZC56ID0gejtcbiAgICAgIGNvbnN0IHJlc3VsdFkgPSByZXN1bHRbel07XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dHB1dFk7IHkrKykge1xuICAgICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFlbeV07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0cHV0WDsgeCsrKSB7XG4gICAgICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1gO1xuICB9XG5cbiAgX2tlcm5lbE91dHB1dCgpIHtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykge1xuICAgICAgcmV0dXJuICdcXG4gICAgcmV0dXJuIHJlc3VsdDsnO1xuICAgIH1cbiAgICByZXR1cm4gYFxcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAkeyB0aGlzLnN1Yktlcm5lbHMubWFwKHN1Yktlcm5lbCA9PiBgJHsgc3ViS2VybmVsLnByb3BlcnR5IH06IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9YCkuam9pbignLFxcbiAgICAgICcpIH1cbiAgICB9O2A7XG4gIH1cblxuICBfbWFwU3ViS2VybmVscyhmbikge1xuICAgIHJldHVybiB0aGlzLnN1Yktlcm5lbHMgPT09IG51bGwgPyBbJyddIDpcbiAgICAgIHRoaXMuc3ViS2VybmVscy5tYXAoZm4pO1xuICB9XG5cbiAgZGVzdHJveShyZW1vdmVDYW52YXNSZWZlcmVuY2UpIHtcbiAgICBpZiAocmVtb3ZlQ2FudmFzUmVmZXJlbmNlKSB7XG4gICAgICBkZWxldGUgdGhpcy5jYW52YXM7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGRlc3Ryb3lDb250ZXh0KGNvbnRleHQpIHt9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGpzb24gPSBzdXBlci50b0pTT04oKTtcbiAgICBqc29uLmZ1bmN0aW9uTm9kZXMgPSBGdW5jdGlvbkJ1aWxkZXIuZnJvbUtlcm5lbCh0aGlzLCBDUFVGdW5jdGlvbk5vZGUpLnRvSlNPTigpO1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgc2V0T3V0cHV0KG91dHB1dCkge1xuICAgIHN1cGVyLnNldE91dHB1dChvdXRwdXQpO1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMub3V0cHV0O1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgdGhpcy5faW1hZ2VEYXRhID0gdGhpcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuX2NvbG9yRGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIH1cbiAgfVxuXG4gIHByZXBlbmRTdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fa2VybmVsU3RyaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0tlcm5lbCBhbHJlYWR5IGJ1aWx0Jyk7XG4gICAgdGhpcy5fcHJlcGVuZGVkU3RyaW5nLnB1c2godmFsdWUpO1xuICB9XG5cbiAgaGFzUHJlcGVuZFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wcmVwZW5kZWRTdHJpbmcuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1BVS2VybmVsXG59O1xufSx7XCIuLi8uLi91dGlsc1wiOjExNCxcIi4uL2Z1bmN0aW9uLWJ1aWxkZXJcIjo5LFwiLi4va2VybmVsXCI6MzYsXCIuL2Z1bmN0aW9uLW5vZGVcIjo2LFwiLi9rZXJuZWwtc3RyaW5nXCI6N31dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY2xhc3MgRnVuY3Rpb25CdWlsZGVyIHtcbiAgc3RhdGljIGZyb21LZXJuZWwoa2VybmVsLCBGdW5jdGlvbk5vZGUsIGV4dHJhTm9kZU9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBrZXJuZWxBcmd1bWVudHMsXG4gICAgICBrZXJuZWxDb25zdGFudHMsXG4gICAgICBhcmd1bWVudE5hbWVzLFxuICAgICAgYXJndW1lbnRTaXplcyxcbiAgICAgIGFyZ3VtZW50Qml0UmF0aW9zLFxuICAgICAgY29uc3RhbnRzLFxuICAgICAgY29uc3RhbnRCaXRSYXRpb3MsXG4gICAgICBkZWJ1ZyxcbiAgICAgIGxvb3BNYXhJdGVyYXRpb25zLFxuICAgICAgbmF0aXZlRnVuY3Rpb25zLFxuICAgICAgb3V0cHV0LFxuICAgICAgb3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgIHByZWNpc2lvbixcbiAgICAgIHBsdWdpbnMsXG4gICAgICBzb3VyY2UsXG4gICAgICBzdWJLZXJuZWxzLFxuICAgICAgZnVuY3Rpb25zLFxuICAgICAgbGVhZGluZ1JldHVyblN0YXRlbWVudCxcbiAgICAgIGZvbGxvd2luZ1JldHVyblN0YXRlbWVudCxcbiAgICAgIGR5bmFtaWNBcmd1bWVudHMsXG4gICAgICBkeW5hbWljT3V0cHV0LFxuICAgIH0gPSBrZXJuZWw7XG5cbiAgICBjb25zdCBhcmd1bWVudFR5cGVzID0gbmV3IEFycmF5KGtlcm5lbEFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGNvbnN0IGNvbnN0YW50VHlwZXMgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsQXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmd1bWVudFR5cGVzW2ldID0ga2VybmVsQXJndW1lbnRzW2ldLnR5cGU7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxDb25zdGFudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtlcm5lbENvbnN0YW50ID0ga2VybmVsQ29uc3RhbnRzW2ldO1xuICAgICAgY29uc3RhbnRUeXBlc1trZXJuZWxDb25zdGFudC5uYW1lXSA9IGtlcm5lbENvbnN0YW50LnR5cGU7XG4gICAgfVxuXG4gICAgY29uc3QgbmVlZHNBcmd1bWVudFR5cGUgPSAoZnVuY3Rpb25OYW1lLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlci5uZWVkc0FyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGluZGV4KTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXNzaWduQXJndW1lbnRUeXBlID0gKGZ1bmN0aW9uTmFtZSwgaW5kZXgsIHR5cGUpID0+IHtcbiAgICAgIGZ1bmN0aW9uQnVpbGRlci5hc3NpZ25Bcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpbmRleCwgdHlwZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxvb2t1cFJldHVyblR5cGUgPSAoZnVuY3Rpb25OYW1lLCBhc3QsIHJlcXVlc3RpbmdOb2RlKSA9PiB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25CdWlsZGVyLmxvb2t1cFJldHVyblR5cGUoZnVuY3Rpb25OYW1lLCBhc3QsIHJlcXVlc3RpbmdOb2RlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgbG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzID0gKGZ1bmN0aW9uTmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlci5sb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMoZnVuY3Rpb25OYW1lKTtcbiAgICB9O1xuXG4gICAgY29uc3QgbG9va3VwRnVuY3Rpb25Bcmd1bWVudE5hbWUgPSAoZnVuY3Rpb25OYW1lLCBhcmd1bWVudEluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25CdWlsZGVyLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyA9IChmdW5jdGlvbk5hbWUsIGFyZ3VtZW50TmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlci5sb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8oZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUpO1xuICAgIH07XG5cbiAgICBjb25zdCB0cmlnZ2VySW1wbHlBcmd1bWVudFR5cGUgPSAoZnVuY3Rpb25OYW1lLCBpLCBhcmd1bWVudFR5cGUsIHJlcXVlc3RpbmdOb2RlKSA9PiB7XG4gICAgICBmdW5jdGlvbkJ1aWxkZXIuYXNzaWduQXJndW1lbnRUeXBlKGZ1bmN0aW9uTmFtZSwgaSwgYXJndW1lbnRUeXBlLCByZXF1ZXN0aW5nTm9kZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHRyaWdnZXJJbXBseUFyZ3VtZW50Qml0UmF0aW8gPSAoZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCkgPT4ge1xuICAgICAgZnVuY3Rpb25CdWlsZGVyLmFzc2lnbkFyZ3VtZW50Qml0UmF0aW8oZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uRnVuY3Rpb25DYWxsID0gKGZ1bmN0aW9uTmFtZSwgY2FsbGVlRnVuY3Rpb25OYW1lLCBhcmdzKSA9PiB7XG4gICAgICBmdW5jdGlvbkJ1aWxkZXIudHJhY2tGdW5jdGlvbkNhbGwoZnVuY3Rpb25OYW1lLCBjYWxsZWVGdW5jdGlvbk5hbWUsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbk5lc3RlZEZ1bmN0aW9uID0gKGFzdCwgc291cmNlKSA9PiB7XG4gICAgICBjb25zdCBhcmd1bWVudE5hbWVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5wYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJndW1lbnROYW1lcy5wdXNoKGFzdC5wYXJhbXNbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXN0ZWRGdW5jdGlvbiA9IG5ldyBGdW5jdGlvbk5vZGUoc291cmNlLCBPYmplY3QuYXNzaWduKHt9LCBub2RlT3B0aW9ucywge1xuICAgICAgICByZXR1cm5UeXBlOiBudWxsLFxuICAgICAgICBhc3QsXG4gICAgICAgIG5hbWU6IGFzdC5pZC5uYW1lLFxuICAgICAgICBhcmd1bWVudE5hbWVzLFxuICAgICAgICBsb29rdXBSZXR1cm5UeXBlLFxuICAgICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMsXG4gICAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lLFxuICAgICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8sXG4gICAgICAgIG5lZWRzQXJndW1lbnRUeXBlLFxuICAgICAgICBhc3NpZ25Bcmd1bWVudFR5cGUsXG4gICAgICAgIHRyaWdnZXJJbXBseUFyZ3VtZW50VHlwZSxcbiAgICAgICAgdHJpZ2dlckltcGx5QXJndW1lbnRCaXRSYXRpbyxcbiAgICAgICAgb25GdW5jdGlvbkNhbGwsXG4gICAgICB9KSk7XG4gICAgICBuZXN0ZWRGdW5jdGlvbi50cmFjZUZ1bmN0aW9uQVNUKGFzdCk7XG4gICAgICBmdW5jdGlvbkJ1aWxkZXIuYWRkRnVuY3Rpb25Ob2RlKG5lc3RlZEZ1bmN0aW9uKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgbm9kZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGlzUm9vdEtlcm5lbDogZmFsc2UsXG4gICAgICBvbk5lc3RlZEZ1bmN0aW9uLFxuICAgICAgbG9va3VwUmV0dXJuVHlwZSxcbiAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyxcbiAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lLFxuICAgICAgbG9va3VwRnVuY3Rpb25Bcmd1bWVudEJpdFJhdGlvLFxuICAgICAgbmVlZHNBcmd1bWVudFR5cGUsXG4gICAgICBhc3NpZ25Bcmd1bWVudFR5cGUsXG4gICAgICB0cmlnZ2VySW1wbHlBcmd1bWVudFR5cGUsXG4gICAgICB0cmlnZ2VySW1wbHlBcmd1bWVudEJpdFJhdGlvLFxuICAgICAgb25GdW5jdGlvbkNhbGwsXG4gICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgcHJlY2lzaW9uLFxuICAgICAgY29uc3RhbnRzLFxuICAgICAgY29uc3RhbnRUeXBlcyxcbiAgICAgIGNvbnN0YW50Qml0UmF0aW9zLFxuICAgICAgZGVidWcsXG4gICAgICBsb29wTWF4SXRlcmF0aW9ucyxcbiAgICAgIG91dHB1dCxcbiAgICAgIHBsdWdpbnMsXG4gICAgICBkeW5hbWljQXJndW1lbnRzLFxuICAgICAgZHluYW1pY091dHB1dCxcbiAgICB9LCBleHRyYU5vZGVPcHRpb25zIHx8IHt9KTtcblxuICAgIGNvbnN0IHJvb3ROb2RlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGVPcHRpb25zLCB7XG4gICAgICBpc1Jvb3RLZXJuZWw6IHRydWUsXG4gICAgICBuYW1lOiAna2VybmVsJyxcbiAgICAgIGFyZ3VtZW50TmFtZXMsXG4gICAgICBhcmd1bWVudFR5cGVzLFxuICAgICAgYXJndW1lbnRTaXplcyxcbiAgICAgIGFyZ3VtZW50Qml0UmF0aW9zLFxuICAgICAgbGVhZGluZ1JldHVyblN0YXRlbWVudCxcbiAgICAgIGZvbGxvd2luZ1JldHVyblN0YXRlbWVudCxcbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JyAmJiBzb3VyY2UuZnVuY3Rpb25Ob2Rlcykge1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkJ1aWxkZXIoKS5mcm9tSlNPTihzb3VyY2UuZnVuY3Rpb25Ob2RlcywgRnVuY3Rpb25Ob2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCByb290Tm9kZSA9IG5ldyBGdW5jdGlvbk5vZGUoc291cmNlLCByb290Tm9kZU9wdGlvbnMpO1xuXG4gICAgbGV0IGZ1bmN0aW9uTm9kZXMgPSBudWxsO1xuICAgIGlmIChmdW5jdGlvbnMpIHtcbiAgICAgIGZ1bmN0aW9uTm9kZXMgPSBmdW5jdGlvbnMubWFwKChmbikgPT4gbmV3IEZ1bmN0aW9uTm9kZShmbi5zb3VyY2UsIHtcbiAgICAgICAgcmV0dXJuVHlwZTogZm4ucmV0dXJuVHlwZSxcbiAgICAgICAgYXJndW1lbnRUeXBlczogZm4uYXJndW1lbnRUeXBlcyxcbiAgICAgICAgb3V0cHV0LFxuICAgICAgICBwbHVnaW5zLFxuICAgICAgICBjb25zdGFudHMsXG4gICAgICAgIGNvbnN0YW50VHlwZXMsXG4gICAgICAgIGNvbnN0YW50Qml0UmF0aW9zLFxuICAgICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgIGxvb2t1cFJldHVyblR5cGUsXG4gICAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyxcbiAgICAgICAgbG9va3VwRnVuY3Rpb25Bcmd1bWVudE5hbWUsXG4gICAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyxcbiAgICAgICAgbmVlZHNBcmd1bWVudFR5cGUsXG4gICAgICAgIGFzc2lnbkFyZ3VtZW50VHlwZSxcbiAgICAgICAgdHJpZ2dlckltcGx5QXJndW1lbnRUeXBlLFxuICAgICAgICB0cmlnZ2VySW1wbHlBcmd1bWVudEJpdFJhdGlvLFxuICAgICAgICBvbkZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgb25OZXN0ZWRGdW5jdGlvbixcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBsZXQgc3ViS2VybmVsTm9kZXMgPSBudWxsO1xuICAgIGlmIChzdWJLZXJuZWxzKSB7XG4gICAgICBzdWJLZXJuZWxOb2RlcyA9IHN1Yktlcm5lbHMubWFwKChzdWJLZXJuZWwpID0+IHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBzb3VyY2UgfSA9IHN1Yktlcm5lbDtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbk5vZGUoc291cmNlLCBPYmplY3QuYXNzaWduKHt9LCBub2RlT3B0aW9ucywge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaXNTdWJLZXJuZWw6IHRydWUsXG4gICAgICAgICAgaXNSb290S2VybmVsOiBmYWxzZSxcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZnVuY3Rpb25CdWlsZGVyID0gbmV3IEZ1bmN0aW9uQnVpbGRlcih7XG4gICAgICBrZXJuZWwsXG4gICAgICByb290Tm9kZSxcbiAgICAgIGZ1bmN0aW9uTm9kZXMsXG4gICAgICBuYXRpdmVGdW5jdGlvbnMsXG4gICAgICBzdWJLZXJuZWxOb2Rlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlcjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICB0aGlzLmtlcm5lbCA9IHNldHRpbmdzLmtlcm5lbDtcbiAgICB0aGlzLnJvb3ROb2RlID0gc2V0dGluZ3Mucm9vdE5vZGU7XG4gICAgdGhpcy5mdW5jdGlvbk5vZGVzID0gc2V0dGluZ3MuZnVuY3Rpb25Ob2RlcyB8fCBbXTtcbiAgICB0aGlzLnN1Yktlcm5lbE5vZGVzID0gc2V0dGluZ3Muc3ViS2VybmVsTm9kZXMgfHwgW107XG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMgPSBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMgfHwgW107XG4gICAgdGhpcy5mdW5jdGlvbk1hcCA9IHt9O1xuICAgIHRoaXMubmF0aXZlRnVuY3Rpb25OYW1lcyA9IFtdO1xuICAgIHRoaXMubG9va3VwQ2hhaW4gPSBbXTtcbiAgICB0aGlzLmZ1bmN0aW9uTm9kZURlcGVuZGVuY2llcyA9IHt9O1xuICAgIHRoaXMuZnVuY3Rpb25DYWxscyA9IHt9O1xuXG4gICAgaWYgKHRoaXMucm9vdE5vZGUpIHtcbiAgICAgIHRoaXMuZnVuY3Rpb25NYXBbJ2tlcm5lbCddID0gdGhpcy5yb290Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mdW5jdGlvbk5vZGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZnVuY3Rpb25Ob2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTWFwW3RoaXMuZnVuY3Rpb25Ob2Rlc1tpXS5uYW1lXSA9IHRoaXMuZnVuY3Rpb25Ob2Rlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdWJLZXJuZWxOb2Rlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25NYXBbdGhpcy5zdWJLZXJuZWxOb2Rlc1tpXS5uYW1lXSA9IHRoaXMuc3ViS2VybmVsTm9kZXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmF0aXZlRnVuY3Rpb25zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmF0aXZlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUZ1bmN0aW9uID0gdGhpcy5uYXRpdmVGdW5jdGlvbnNbaV07XG4gICAgICAgIHRoaXMubmF0aXZlRnVuY3Rpb25OYW1lcy5wdXNoKG5hdGl2ZUZ1bmN0aW9uLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFkZEZ1bmN0aW9uTm9kZShmdW5jdGlvbk5vZGUpIHtcbiAgICBpZiAoIWZ1bmN0aW9uTm9kZS5uYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uTm9kZS5uYW1lIG5lZWRzIHNldCcpO1xuICAgIHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25Ob2RlLm5hbWVdID0gZnVuY3Rpb25Ob2RlO1xuICAgIGlmIChmdW5jdGlvbk5vZGUuaXNSb290S2VybmVsKSB7XG4gICAgICB0aGlzLnJvb3ROb2RlID0gZnVuY3Rpb25Ob2RlO1xuICAgIH1cbiAgfVxuXG4gIHRyYWNlRnVuY3Rpb25DYWxscyhmdW5jdGlvbk5hbWUsIHJldExpc3QpIHtcbiAgICBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWUgfHwgJ2tlcm5lbCc7XG4gICAgcmV0TGlzdCA9IHJldExpc3QgfHwgW107XG5cbiAgICBpZiAodGhpcy5uYXRpdmVGdW5jdGlvbk5hbWVzLmluZGV4T2YoZnVuY3Rpb25OYW1lKSA+IC0xKSB7XG4gICAgICBjb25zdCBuYXRpdmVGdW5jdGlvbkluZGV4ID0gcmV0TGlzdC5pbmRleE9mKGZ1bmN0aW9uTmFtZSk7XG4gICAgICBpZiAobmF0aXZlRnVuY3Rpb25JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0TGlzdC5wdXNoKGZ1bmN0aW9uTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZXBlbmRhbnROYXRpdmVGdW5jdGlvbk5hbWUgPSByZXRMaXN0LnNwbGljZShuYXRpdmVGdW5jdGlvbkluZGV4LCAxKVswXTtcbiAgICAgICAgcmV0TGlzdC5wdXNoKGRlcGVuZGFudE5hdGl2ZUZ1bmN0aW9uTmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0TGlzdDtcbiAgICB9XG5cbiAgICBjb25zdCBmdW5jdGlvbk5vZGUgPSB0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTmFtZV07XG4gICAgaWYgKGZ1bmN0aW9uTm9kZSkge1xuICAgICAgY29uc3QgZnVuY3Rpb25JbmRleCA9IHJldExpc3QuaW5kZXhPZihmdW5jdGlvbk5hbWUpO1xuICAgICAgaWYgKGZ1bmN0aW9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldExpc3QucHVzaChmdW5jdGlvbk5hbWUpO1xuICAgICAgICBmdW5jdGlvbk5vZGUudG9TdHJpbmcoKTsgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25Ob2RlLmNhbGxlZEZ1bmN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRoaXMudHJhY2VGdW5jdGlvbkNhbGxzKGZ1bmN0aW9uTm9kZS5jYWxsZWRGdW5jdGlvbnNbaV0sIHJldExpc3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZXBlbmRhbnRGdW5jdGlvbk5hbWUgPSByZXRMaXN0LnNwbGljZShmdW5jdGlvbkluZGV4LCAxKVswXTtcbiAgICAgICAgcmV0TGlzdC5wdXNoKGRlcGVuZGFudEZ1bmN0aW9uTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldExpc3Q7XG4gIH1cblxuICBnZXRQcm90b3R5cGVTdHJpbmcoZnVuY3Rpb25OYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJvdG90eXBlcyhmdW5jdGlvbk5hbWUpLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgZ2V0UHJvdG90eXBlcyhmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAodGhpcy5yb290Tm9kZSkge1xuICAgICAgdGhpcy5yb290Tm9kZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQcm90b3R5cGVzRnJvbUZ1bmN0aW9uTmFtZXModGhpcy50cmFjZUZ1bmN0aW9uQ2FsbHMoZnVuY3Rpb25OYW1lLCBbXSkucmV2ZXJzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJvdG90eXBlc0Zyb21GdW5jdGlvbk5hbWVzKE9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25NYXApKTtcbiAgfVxuXG4gIGdldFN0cmluZ0Zyb21GdW5jdGlvbk5hbWVzKGZ1bmN0aW9uTGlzdCkge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25MaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbkxpc3RbaV1dO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgcmV0LnB1c2godGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbkxpc3RbaV1dLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgZ2V0UHJvdG90eXBlc0Zyb21GdW5jdGlvbk5hbWVzKGZ1bmN0aW9uTGlzdCkge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25MaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbkxpc3RbaV07XG4gICAgICBjb25zdCBmdW5jdGlvbkluZGV4ID0gdGhpcy5uYXRpdmVGdW5jdGlvbk5hbWVzLmluZGV4T2YoZnVuY3Rpb25OYW1lKTtcbiAgICAgIGlmIChmdW5jdGlvbkluZGV4ID4gLTEpIHtcbiAgICAgICAgcmV0LnB1c2godGhpcy5uYXRpdmVGdW5jdGlvbnNbZnVuY3Rpb25JbmRleF0uc291cmNlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbk5hbWVdO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgcmV0LnB1c2gobm9kZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjZUZ1bmN0aW9uQ2FsbHModGhpcy5yb290Tm9kZS5uYW1lKS5yZXZlcnNlKCkubWFwKG5hbWUgPT4ge1xuICAgICAgY29uc3QgbmF0aXZlSW5kZXggPSB0aGlzLm5hdGl2ZUZ1bmN0aW9ucy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKG5hdGl2ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHNvdXJjZTogdGhpcy5uYXRpdmVGdW5jdGlvbnNbbmF0aXZlSW5kZXhdLnNvdXJjZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmZ1bmN0aW9uTWFwW25hbWVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uTWFwW25hbWVdLnRvSlNPTigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmdW5jdGlvbiAkeyBuYW1lIH0gbm90IGZvdW5kYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmcm9tSlNPTihqc29uRnVuY3Rpb25Ob2RlcywgRnVuY3Rpb25Ob2RlKSB7XG4gICAgdGhpcy5mdW5jdGlvbk1hcCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbkZ1bmN0aW9uTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGpzb25GdW5jdGlvbk5vZGUgPSBqc29uRnVuY3Rpb25Ob2Rlc1tpXTtcbiAgICAgIHRoaXMuZnVuY3Rpb25NYXBbanNvbkZ1bmN0aW9uTm9kZS5zZXR0aW5ncy5uYW1lXSA9IG5ldyBGdW5jdGlvbk5vZGUoanNvbkZ1bmN0aW9uTm9kZS5hc3QsIGpzb25GdW5jdGlvbk5vZGUuc2V0dGluZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldFN0cmluZyhmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdHJpbmdGcm9tRnVuY3Rpb25OYW1lcyh0aGlzLnRyYWNlRnVuY3Rpb25DYWxscyhmdW5jdGlvbk5hbWUpLnJldmVyc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFN0cmluZ0Zyb21GdW5jdGlvbk5hbWVzKE9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25NYXApKTtcbiAgfVxuXG4gIGxvb2t1cFJldHVyblR5cGUoZnVuY3Rpb25OYW1lLCBhc3QsIHJlcXVlc3RpbmdOb2RlKSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnQ2FsbEV4cHJlc3Npb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIGFzdCB0eXBlIG9mIFwiQ2FsbEV4cHJlc3Npb25cIiwgYnV0IGlzICR7IGFzdC50eXBlIH1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzTmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvb2t1cE5hdGl2ZUZ1bmN0aW9uUmV0dXJuVHlwZShmdW5jdGlvbk5hbWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faXNGdW5jdGlvbihmdW5jdGlvbk5hbWUpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5fZ2V0RnVuY3Rpb24oZnVuY3Rpb25OYW1lKTtcbiAgICAgIGlmIChub2RlLnJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmV0dXJuVHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb29rdXBDaGFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLmxvb2t1cENoYWluW2ldLmFzdCA9PT0gYXN0KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5hcmd1bWVudFR5cGVzLmxlbmd0aCA9PT0gMCAmJiBhc3QuYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGFzdC5hcmd1bWVudHM7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9va3VwQ2hhaW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiByZXF1ZXN0aW5nTm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXN0OiBhcmdzW2ldLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdGluZ05vZGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50VHlwZXNbal0gPSByZXF1ZXN0aW5nTm9kZS5nZXRUeXBlKGFyZ3Nbal0pO1xuICAgICAgICAgICAgICAgIHRoaXMubG9va3VwQ2hhaW4ucG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucmV0dXJuVHlwZSA9IG5vZGUuZ2V0VHlwZShub2RlLmdldEpzQVNUKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NpcmNsaWNhbCBsb2dpYyBkZXRlY3RlZCEnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb29rdXBDaGFpbi5wdXNoKHtcbiAgICAgICAgICBuYW1lOiByZXF1ZXN0aW5nTm9kZS5uYW1lLFxuICAgICAgICAgIGFzdCxcbiAgICAgICAgICByZXF1ZXN0aW5nTm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHlwZSA9IG5vZGUuZ2V0VHlwZShub2RlLmdldEpzQVNUKCkpO1xuICAgICAgICB0aGlzLmxvb2t1cENoYWluLnBvcCgpO1xuICAgICAgICByZXR1cm4gbm9kZS5yZXR1cm5UeXBlID0gdHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgbmV3IEVycm9yKGBGdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTmFtZV07XG4gIH1cblxuICBfaXNGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTmFtZV0pO1xuICB9XG5cbiAgX2dldE5hdGl2ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uYXRpdmVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLm5hdGl2ZUZ1bmN0aW9uc1tpXS5uYW1lID09PSBmdW5jdGlvbk5hbWUpIHJldHVybiB0aGlzLm5hdGl2ZUZ1bmN0aW9uc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBfaXNOYXRpdmVGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9nZXROYXRpdmVGdW5jdGlvbihmdW5jdGlvbk5hbWUpKTtcbiAgfVxuXG4gIF9sb29rdXBOYXRpdmVGdW5jdGlvblJldHVyblR5cGUoZnVuY3Rpb25OYW1lKSB7XG4gICAgbGV0IG5hdGl2ZUZ1bmN0aW9uID0gdGhpcy5fZ2V0TmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKTtcbiAgICBpZiAobmF0aXZlRnVuY3Rpb24pIHtcbiAgICAgIHJldHVybiBuYXRpdmVGdW5jdGlvbi5yZXR1cm5UeXBlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5hdGl2ZSBmdW5jdGlvbiAkeyBmdW5jdGlvbk5hbWUgfSBub3QgZm91bmRgKTtcbiAgfVxuXG4gIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyhmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAodGhpcy5faXNOYXRpdmVGdW5jdGlvbihmdW5jdGlvbk5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKS5hcmd1bWVudFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faXNGdW5jdGlvbihmdW5jdGlvbk5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RnVuY3Rpb24oZnVuY3Rpb25OYW1lKS5hcmd1bWVudFR5cGVzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpLmFyZ3VtZW50TmFtZXNbYXJndW1lbnRJbmRleF07XG4gIH1cblxuICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8oZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvbiBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucm9vdE5vZGUubmFtZSA9PT0gZnVuY3Rpb25OYW1lKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5yb290Tm9kZS5hcmd1bWVudE5hbWVzLmluZGV4T2YoYXJndW1lbnROYW1lKTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Tm9kZS5hcmd1bWVudEJpdFJhdGlvc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgY29uc3QgaSA9IG5vZGUuYXJndW1lbnROYW1lcy5pbmRleE9mKGFyZ3VtZW50TmFtZSk7XG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyZ3VtZW50IG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBiaXRSYXRpbyA9IG5vZGUuYXJndW1lbnRCaXRSYXRpb3NbaV07XG4gICAgaWYgKHR5cGVvZiBiaXRSYXRpbyAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXJndW1lbnQgYml0IHJhdGlvIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gYml0UmF0aW87XG4gIH1cblxuICBuZWVkc0FyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGkpIHtcbiAgICBpZiAoIXRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGZuTm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgcmV0dXJuICFmbk5vZGUuYXJndW1lbnRUeXBlc1tpXTtcbiAgfVxuXG4gIGFzc2lnbkFyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGksIGFyZ3VtZW50VHlwZSwgcmVxdWVzdGluZ05vZGUpIHtcbiAgICBpZiAoIXRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkgcmV0dXJuO1xuICAgIGNvbnN0IGZuTm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgaWYgKCFmbk5vZGUuYXJndW1lbnRUeXBlc1tpXSkge1xuICAgICAgZm5Ob2RlLmFyZ3VtZW50VHlwZXNbaV0gPSBhcmd1bWVudFR5cGU7XG4gICAgfVxuICB9XG5cbiAgYXNzaWduQXJndW1lbnRCaXRSYXRpbyhmdW5jdGlvbk5hbWUsIGFyZ3VtZW50TmFtZSwgY2FsbGVlRnVuY3Rpb25OYW1lLCBhcmd1bWVudEluZGV4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgaWYgKHRoaXMuX2lzTmF0aXZlRnVuY3Rpb24oY2FsbGVlRnVuY3Rpb25OYW1lKSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY2FsbGVlTm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGNhbGxlZUZ1bmN0aW9uTmFtZSk7XG4gICAgY29uc3QgaSA9IG5vZGUuYXJndW1lbnROYW1lcy5pbmRleE9mKGFyZ3VtZW50TmFtZSk7XG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50ICR7YXJndW1lbnROYW1lfSBub3QgZm91bmQgaW4gYXJndW1lbnRzIGZyb20gZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9YCk7XG4gICAgfVxuICAgIGNvbnN0IGJpdFJhdGlvID0gbm9kZS5hcmd1bWVudEJpdFJhdGlvc1tpXTtcbiAgICBpZiAodHlwZW9mIGJpdFJhdGlvICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXQgcmF0aW8gZm9yIGFyZ3VtZW50ICR7YXJndW1lbnROYW1lfSBub3QgZm91bmQgaW4gZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9YCk7XG4gICAgfVxuICAgIGlmICghY2FsbGVlTm9kZS5hcmd1bWVudEJpdFJhdGlvcykge1xuICAgICAgY2FsbGVlTm9kZS5hcmd1bWVudEJpdFJhdGlvcyA9IG5ldyBBcnJheShjYWxsZWVOb2RlLmFyZ3VtZW50TmFtZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgY2FsbGVlQml0UmF0aW8gPSBjYWxsZWVOb2RlLmFyZ3VtZW50Qml0UmF0aW9zW2ldO1xuICAgIGlmICh0eXBlb2YgY2FsbGVlQml0UmF0aW8gPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoY2FsbGVlQml0UmF0aW8gIT09IGJpdFJhdGlvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wYXRpYmxlIGJpdCByYXRpbyBmb3VuZCBhdCBmdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0gYXQgYXJndW1lbnQgJHthcmd1bWVudE5hbWV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGVlQml0UmF0aW87XG4gICAgfVxuICAgIGNhbGxlZU5vZGUuYXJndW1lbnRCaXRSYXRpb3NbaV0gPSBiaXRSYXRpbztcbiAgICByZXR1cm4gYml0UmF0aW87XG4gIH1cblxuICB0cmFja0Z1bmN0aW9uQ2FsbChmdW5jdGlvbk5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJncykge1xuICAgIGlmICghdGhpcy5mdW5jdGlvbk5vZGVEZXBlbmRlbmNpZXNbZnVuY3Rpb25OYW1lXSkge1xuICAgICAgdGhpcy5mdW5jdGlvbk5vZGVEZXBlbmRlbmNpZXNbZnVuY3Rpb25OYW1lXSA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuZnVuY3Rpb25DYWxsc1tmdW5jdGlvbk5hbWVdID0gW107XG4gICAgfVxuICAgIHRoaXMuZnVuY3Rpb25Ob2RlRGVwZW5kZW5jaWVzW2Z1bmN0aW9uTmFtZV0uYWRkKGNhbGxlZUZ1bmN0aW9uTmFtZSk7XG4gICAgdGhpcy5mdW5jdGlvbkNhbGxzW2Z1bmN0aW9uTmFtZV0ucHVzaChhcmdzKTtcbiAgfVxuXG4gIGdldEtlcm5lbFJlc3VsdFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdE5vZGUucmV0dXJuVHlwZSB8fCB0aGlzLnJvb3ROb2RlLmdldFR5cGUodGhpcy5yb290Tm9kZS5hc3QpO1xuICB9XG5cbiAgZ2V0U3ViS2VybmVsUmVzdWx0VHlwZShpbmRleCkge1xuICAgIGNvbnN0IHN1Yktlcm5lbE5vZGUgPSB0aGlzLnN1Yktlcm5lbE5vZGVzW2luZGV4XTtcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgZnVuY3Rpb25DYWxsSW5kZXggPSAwOyBmdW5jdGlvbkNhbGxJbmRleCA8IHRoaXMucm9vdE5vZGUuZnVuY3Rpb25DYWxscy5sZW5ndGg7IGZ1bmN0aW9uQ2FsbEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IHRoaXMucm9vdE5vZGUuZnVuY3Rpb25DYWxsc1tmdW5jdGlvbkNhbGxJbmRleF07XG4gICAgICBpZiAoZnVuY3Rpb25DYWxsLmFzdC5jYWxsZWUubmFtZSA9PT0gc3ViS2VybmVsTm9kZS5uYW1lKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1Yktlcm5lbCAkeyBzdWJLZXJuZWxOb2RlLm5hbWUgfSBuZXZlciBjYWxsZWQgYnkga2VybmVsYCk7XG4gICAgfVxuICAgIHJldHVybiBzdWJLZXJuZWxOb2RlLnJldHVyblR5cGUgfHwgc3ViS2VybmVsTm9kZS5nZXRUeXBlKHN1Yktlcm5lbE5vZGUuZ2V0SnNBU1QoKSk7XG4gIH1cblxuICBnZXRSZXR1cm5UeXBlcygpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBbdGhpcy5yb290Tm9kZS5uYW1lXTogdGhpcy5yb290Tm9kZS5nZXRUeXBlKHRoaXMucm9vdE5vZGUuYXN0KSxcbiAgICB9O1xuICAgIGNvbnN0IGxpc3QgPSB0aGlzLnRyYWNlRnVuY3Rpb25DYWxscyh0aGlzLnJvb3ROb2RlLm5hbWUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gbGlzdFtpXTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTm9kZSA9IHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25OYW1lXTtcbiAgICAgIHJlc3VsdFtmdW5jdGlvbk5hbWVdID0gZnVuY3Rpb25Ob2RlLmdldFR5cGUoZnVuY3Rpb25Ob2RlLmFzdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEZ1bmN0aW9uQnVpbGRlclxufTtcbn0se31dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IGFjb3JuID0gcmVxdWlyZSgnYWNvcm4nKTtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCB7IEZ1bmN0aW9uVHJhY2VyIH0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uLXRyYWNlcicpO1xuXG5jbGFzcyBGdW5jdGlvbk5vZGUge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgaWYgKCFzb3VyY2UgJiYgIXNldHRpbmdzLmFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgcGFyYW1ldGVyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmFzdCA9IG51bGw7XG4gICAgdGhpcy5uYW1lID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzZXR0aW5ncy5pc1Jvb3RLZXJuZWwgP1xuICAgICAgJ2tlcm5lbCcgOlxuICAgICAgKHNldHRpbmdzLm5hbWUgfHwgdXRpbHMuZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZyhzb3VyY2UpKSA6IG51bGw7XG4gICAgdGhpcy5jYWxsZWRGdW5jdGlvbnMgPSBbXTtcbiAgICB0aGlzLmNvbnN0YW50cyA9IHt9O1xuICAgIHRoaXMuY29uc3RhbnRUeXBlcyA9IHt9O1xuICAgIHRoaXMuY29uc3RhbnRCaXRSYXRpb3MgPSB7fTtcbiAgICB0aGlzLmlzUm9vdEtlcm5lbCA9IGZhbHNlO1xuICAgIHRoaXMuaXNTdWJLZXJuZWwgPSBmYWxzZTtcbiAgICB0aGlzLmRlYnVnID0gbnVsbDtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5pZGVudGlmaWVycyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0cyA9IG51bGw7XG4gICAgdGhpcy5mdW5jdGlvbkNhbGxzID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgIHRoaXMubmVlZHNBcmd1bWVudFR5cGUgPSBudWxsO1xuICAgIHRoaXMuYXNzaWduQXJndW1lbnRUeXBlID0gbnVsbDtcbiAgICB0aGlzLmxvb2t1cFJldHVyblR5cGUgPSBudWxsO1xuICAgIHRoaXMubG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzID0gbnVsbDtcbiAgICB0aGlzLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyA9IG51bGw7XG4gICAgdGhpcy50cmlnZ2VySW1wbHlBcmd1bWVudFR5cGUgPSBudWxsO1xuICAgIHRoaXMudHJpZ2dlckltcGx5QXJndW1lbnRCaXRSYXRpbyA9IG51bGw7XG4gICAgdGhpcy5vbk5lc3RlZEZ1bmN0aW9uID0gbnVsbDtcbiAgICB0aGlzLm9uRnVuY3Rpb25DYWxsID0gbnVsbDtcbiAgICB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkgPSBudWxsO1xuICAgIHRoaXMucHJlY2lzaW9uID0gbnVsbDtcbiAgICB0aGlzLmxvb3BNYXhJdGVyYXRpb25zID0gbnVsbDtcbiAgICB0aGlzLmFyZ3VtZW50TmFtZXMgPSAodHlwZW9mIHRoaXMuc291cmNlID09PSAnc3RyaW5nJyA/IHV0aWxzLmdldEFyZ3VtZW50TmFtZXNGcm9tU3RyaW5nKHRoaXMuc291cmNlKSA6IG51bGwpO1xuICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IFtdO1xuICAgIHRoaXMuYXJndW1lbnRTaXplcyA9IFtdO1xuICAgIHRoaXMuYXJndW1lbnRCaXRSYXRpb3MgPSBudWxsO1xuICAgIHRoaXMucmV0dXJuVHlwZSA9IG51bGw7XG4gICAgdGhpcy5vdXRwdXQgPSBbXTtcbiAgICB0aGlzLnBsdWdpbnMgPSBudWxsO1xuICAgIHRoaXMubGVhZGluZ1JldHVyblN0YXRlbWVudCA9IG51bGw7XG4gICAgdGhpcy5mb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY091dHB1dCA9IG51bGw7XG4gICAgdGhpcy5keW5hbWljQXJndW1lbnRzID0gbnVsbDtcbiAgICB0aGlzLnN0cmljdFR5cGluZ0NoZWNraW5nID0gZmFsc2U7XG4gICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IG51bGw7XG5cbiAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgIGZvciAoY29uc3QgcCBpbiBzZXR0aW5ncykge1xuICAgICAgICBpZiAoIXNldHRpbmdzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgICAgdGhpc1twXSA9IHNldHRpbmdzW3BdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGl0ZXJhbFR5cGVzID0ge307XG5cbiAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgdGhpcy5fc3RyaW5nID0gbnVsbDtcbiAgICB0aGlzLl9pbnRlcm5hbFZhcmlhYmxlTmFtZXMgPSB7fTtcbiAgfVxuXG4gIHZhbGlkYXRlKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgIT09ICdzdHJpbmcnICYmICF0aGlzLmFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzLnNvdXJjZSBub3QgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYXN0ICYmICF1dGlscy5pc0Z1bmN0aW9uU3RyaW5nKHRoaXMuc291cmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzLnNvdXJjZSBub3QgYSBmdW5jdGlvbiBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzLm5hbWUgY291bGQgbm90IGJlIHNldCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoID4gMCAmJiB0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoICE9PSB0aGlzLmFyZ3VtZW50TmFtZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyZ3VtZW50VHlwZXMgY291bnQgb2YgJHsgdGhpcy5hcmd1bWVudFR5cGVzLmxlbmd0aCB9IGV4Y2VlZHMgJHsgdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aCB9YCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3V0cHV0Lmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhpcy5vdXRwdXQgaXMgbm90IGJpZyBlbm91Z2gnKTtcbiAgICB9XG4gIH1cblxuICBpc0lkZW50aWZpZXJDb25zdGFudChuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0YW50cykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgfVxuXG4gIGlzSW5wdXQoYXJndW1lbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJndW1lbnRUeXBlc1t0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihhcmd1bWVudE5hbWUpXSA9PT0gJ0lucHV0JztcbiAgfVxuXG4gIHB1c2hTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGVzLnB1c2goc3RhdGUpO1xuICB9XG5cbiAgcG9wU3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBvcFN0YXRlICR7IHN0YXRlIH0gd2hlbiBpbiAkeyB0aGlzLnN0YXRlIH1gKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZXMucG9wKCk7XG4gIH1cblxuICBpc1N0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IHN0YXRlO1xuICB9XG5cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0KSB7XG4gICAgaWYgKGFzdC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHJldHVybiBhc3QubmFtZTtcbiAgICB9IGVsc2UgaWYgKGFzdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICByZXR1cm4gJ3RoaXMnO1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgICBpZiAoYXN0Lm9iamVjdCAmJiBhc3QucHJvcGVydHkpIHtcbiAgICAgICAgaWYgKGFzdC5vYmplY3QuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiBhc3Qub2JqZWN0Lm5hbWUgIT09ICdNYXRoJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0LnByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdGhpcy5hc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdC5vYmplY3QpICtcbiAgICAgICAgICAnLicgK1xuICAgICAgICAgIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3QucHJvcGVydHkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFzdC5oYXNPd25Qcm9wZXJ0eSgnZXhwcmVzc2lvbnMnKSkge1xuICAgICAgY29uc3QgZmlyc3RFeHByZXNzaW9uID0gYXN0LmV4cHJlc3Npb25zWzBdO1xuICAgICAgaWYgKGZpcnN0RXhwcmVzc2lvbi50eXBlID09PSAnTGl0ZXJhbCcgJiYgZmlyc3RFeHByZXNzaW9uLnZhbHVlID09PSAwICYmIGFzdC5leHByZXNzaW9ucy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3QuZXhwcmVzc2lvbnNbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1Vua25vd24gYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbCcsIGFzdCk7XG4gIH1cblxuICBnZXRKc0FTVChpblBhcnNlcikge1xuICAgIGlmICh0aGlzLmFzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXN0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuc291cmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy50cmFjZUZ1bmN0aW9uQVNUKHRoaXMuc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzLmFzdCA9IHRoaXMuc291cmNlO1xuICAgIH1cblxuICAgIGluUGFyc2VyID0gaW5QYXJzZXIgfHwgYWNvcm47XG4gICAgaWYgKGluUGFyc2VyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgSlMgdG8gQVNUIHBhcnNlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IGFzdCA9IE9iamVjdC5mcmVlemUoaW5QYXJzZXIucGFyc2UoYGNvbnN0IHBhcnNlcl8keyB0aGlzLm5hbWUgfSA9ICR7IHRoaXMuc291cmNlIH07YCwge1xuICAgICAgbG9jYXRpb25zOiB0cnVlXG4gICAgfSkpO1xuICAgIGNvbnN0IGZ1bmN0aW9uQVNUID0gYXN0LmJvZHlbMF0uZGVjbGFyYXRpb25zWzBdLmluaXQ7XG4gICAgdGhpcy50cmFjZUZ1bmN0aW9uQVNUKGZ1bmN0aW9uQVNUKTtcblxuICAgIGlmICghYXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBKUyBjb2RlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXN0ID0gZnVuY3Rpb25BU1Q7XG4gIH1cblxuICB0cmFjZUZ1bmN0aW9uQVNUKGFzdCkge1xuICAgIGNvbnN0IHsgY29udGV4dHMsIGRlY2xhcmF0aW9ucywgZnVuY3Rpb25zLCBpZGVudGlmaWVycywgZnVuY3Rpb25DYWxscyB9ID0gbmV3IEZ1bmN0aW9uVHJhY2VyKGFzdCk7XG4gICAgdGhpcy5jb250ZXh0cyA9IGNvbnRleHRzO1xuICAgIHRoaXMuaWRlbnRpZmllcnMgPSBpZGVudGlmaWVycztcbiAgICB0aGlzLmZ1bmN0aW9uQ2FsbHMgPSBmdW5jdGlvbkNhbGxzO1xuICAgIHRoaXMuZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uc1tpXTtcbiAgICAgIGNvbnN0IHsgYXN0LCBpbkZvckxvb3BJbml0LCBpbkZvckxvb3BUZXN0IH0gPSBkZWNsYXJhdGlvbjtcbiAgICAgIGNvbnN0IHsgaW5pdCB9ID0gYXN0O1xuICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gdGhpcy5nZXREZXBlbmRlbmNpZXMoaW5pdCk7XG4gICAgICBsZXQgdmFsdWVUeXBlID0gbnVsbDtcblxuICAgICAgaWYgKGluRm9yTG9vcEluaXQgJiYgaW5Gb3JMb29wVGVzdCkge1xuICAgICAgICB2YWx1ZVR5cGUgPSAnSW50ZWdlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgIGNvbnN0IHJlYWxUeXBlID0gdGhpcy5nZXRUeXBlKGluaXQpO1xuICAgICAgICAgIHN3aXRjaCAocmVhbFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICAgICAgaWYgKGluaXQudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gcmVhbFR5cGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gJ051bWJlcic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgICAgIHZhbHVlVHlwZSA9ICdOdW1iZXInO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHZhbHVlVHlwZSA9IHJlYWxUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVjbGFyYXRpb24udmFsdWVUeXBlID0gdmFsdWVUeXBlO1xuICAgICAgZGVjbGFyYXRpb24uZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgZGVjbGFyYXRpb24uaXNTYWZlID0gdGhpcy5pc1NhZmVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5vbk5lc3RlZEZ1bmN0aW9uKGZ1bmN0aW9uc1tpXSwgdGhpcy5zb3VyY2UpO1xuICAgIH1cbiAgfVxuXG4gIGdldERlY2xhcmF0aW9uKGFzdCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMuaWRlbnRpZmllcnNbaV07XG4gICAgICBpZiAoYXN0ID09PSBpZGVudGlmaWVyLmFzdCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllci5kZWNsYXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRWYXJpYWJsZVR5cGUoYXN0KSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYXN0IG9mICR7YXN0LnR5cGV9IG5vdCBcIklkZW50aWZpZXJcImApO1xuICAgIH1cbiAgICBsZXQgdHlwZSA9IG51bGw7XG4gICAgY29uc3QgYXJndW1lbnRJbmRleCA9IHRoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKGFzdC5uYW1lKTtcbiAgICBpZiAoYXJndW1lbnRJbmRleCA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdGhpcy5nZXREZWNsYXJhdGlvbihhc3QpO1xuICAgICAgaWYgKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBkZWNsYXJhdGlvbi52YWx1ZVR5cGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFyZ3VtZW50VHlwZSA9IHRoaXMuYXJndW1lbnRUeXBlc1thcmd1bWVudEluZGV4XTtcbiAgICAgIGlmIChhcmd1bWVudFR5cGUpIHtcbiAgICAgICAgdHlwZSA9IGFyZ3VtZW50VHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlICYmIHRoaXMuc3RyaWN0VHlwaW5nQ2hlY2tpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGVjbGFyYXRpb24gb2YgJHtuYW1lfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBnZXRMb29rdXBUeXBlKHR5cGUpIHtcbiAgICBpZiAoIXR5cGVMb29rdXBNYXAuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlTG9va3VwTWFwICR7IHR5cGUgfWApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZUxvb2t1cE1hcFt0eXBlXTtcbiAgfVxuXG4gIGdldENvbnN0YW50VHlwZShjb25zdGFudE5hbWUpIHtcbiAgICBpZiAodGhpcy5jb25zdGFudFR5cGVzW2NvbnN0YW50TmFtZV0pIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmNvbnN0YW50VHlwZXNbY29uc3RhbnROYW1lXTtcbiAgICAgIGlmICh0eXBlID09PSAnRmxvYXQnKSB7XG4gICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgZm9yIGNvbnN0YW50IFwiJHsgY29uc3RhbnROYW1lIH1cIiBub3QgZGVjbGFyZWRgKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLl9zdHJpbmcpIHJldHVybiB0aGlzLl9zdHJpbmc7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmluZyA9IHRoaXMuYXN0R2VuZXJpYyh0aGlzLmdldEpzQVNUKCksIFtdKS5qb2luKCcnKS50cmltKCk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgY29uc3RhbnRzOiB0aGlzLmNvbnN0YW50cyxcbiAgICAgIGNvbnN0YW50VHlwZXM6IHRoaXMuY29uc3RhbnRUeXBlcyxcbiAgICAgIGlzUm9vdEtlcm5lbDogdGhpcy5pc1Jvb3RLZXJuZWwsXG4gICAgICBpc1N1Yktlcm5lbDogdGhpcy5pc1N1Yktlcm5lbCxcbiAgICAgIGRlYnVnOiB0aGlzLmRlYnVnLFxuICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgIGxvb3BNYXhJdGVyYXRpb25zOiB0aGlzLmxvb3BNYXhJdGVyYXRpb25zLFxuICAgICAgYXJndW1lbnROYW1lczogdGhpcy5hcmd1bWVudE5hbWVzLFxuICAgICAgYXJndW1lbnRUeXBlczogdGhpcy5hcmd1bWVudFR5cGVzLFxuICAgICAgYXJndW1lbnRTaXplczogdGhpcy5hcmd1bWVudFNpemVzLFxuICAgICAgcmV0dXJuVHlwZTogdGhpcy5yZXR1cm5UeXBlLFxuICAgICAgbGVhZGluZ1JldHVyblN0YXRlbWVudDogdGhpcy5sZWFkaW5nUmV0dXJuU3RhdGVtZW50LFxuICAgICAgZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50OiB0aGlzLmZvbGxvd2luZ1JldHVyblN0YXRlbWVudCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFzdDogdGhpcy5hc3QsXG4gICAgICBzZXR0aW5nc1xuICAgIH07XG4gIH1cblxuICBnZXRUeXBlKGFzdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0W2FzdC5sZW5ndGggLSAxXSk7XG4gICAgfVxuICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuYm9keSk7XG4gICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LmVsZW1lbnRzWzBdKTtcbiAgICAgICAgc3dpdGNoIChjaGlsZFR5cGUpIHtcbiAgICAgICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgICAgIHJldHVybiBgTWF0cml4KCR7YXN0LmVsZW1lbnRzLmxlbmd0aH0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYEFycmF5KCR7IGFzdC5lbGVtZW50cy5sZW5ndGggfSlgO1xuICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgIGNvbnN0IGxpdGVyYWxLZXkgPSB0aGlzLmFzdEtleShhc3QpO1xuICAgICAgICBpZiAodGhpcy5saXRlcmFsVHlwZXNbbGl0ZXJhbEtleV0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsVHlwZXNbbGl0ZXJhbEtleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXN0LnZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiAnTGl0ZXJhbEludGVnZXInO1xuICAgICAgICB9IGVsc2UgaWYgKGFzdC52YWx1ZSA9PT0gdHJ1ZSB8fCBhc3QudmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuICdCb29sZWFuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmxlZnQpO1xuICAgICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6XG4gICAgICAgICAgaWYgKHRoaXMuaXNBc3RNYXRoRnVuY3Rpb24oYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWFzdC5jYWxsZWUgfHwgIWFzdC5jYWxsZWUubmFtZSkge1xuICAgICAgICAgICAgaWYgKGFzdC5jYWxsZWUudHlwZSA9PT0gJ1NlcXVlbmNlRXhwcmVzc2lvbicgJiYgYXN0LmNhbGxlZS5leHByZXNzaW9uc1thc3QuY2FsbGVlLmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdLnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYXN0LmNhbGxlZS5leHByZXNzaW9uc1thc3QuY2FsbGVlLmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdLnByb3BlcnR5Lm5hbWU7XG4gICAgICAgICAgICAgIHRoaXMuaW5mZXJBcmd1bWVudFR5cGVzSWZOZWVkZWQoZnVuY3Rpb25OYW1lLCBhc3QuYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwUmV0dXJuVHlwZShmdW5jdGlvbk5hbWUsIGFzdCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRWYXJpYWJsZVNpZ25hdHVyZShhc3QuY2FsbGVlLCB0cnVlKSA9PT0gJ3RoaXMuY29sb3InKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzdC5jYWxsZWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmIGFzdC5jYWxsZWUub2JqZWN0ICYmIGFzdC5jYWxsZWUucHJvcGVydHkgJiYgYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lICYmIGFzdC5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgICAgICB0aGlzLmluZmVyQXJndW1lbnRUeXBlc0lmTmVlZGVkKGZ1bmN0aW9uTmFtZSwgYXN0LmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvb2t1cFJldHVyblR5cGUoZnVuY3Rpb25OYW1lLCBhc3QsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5rbm93biBjYWxsIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXN0LmNhbGxlZSAmJiBhc3QuY2FsbGVlLm5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGFzdC5jYWxsZWUubmFtZTtcbiAgICAgICAgICAgIHRoaXMuaW5mZXJBcmd1bWVudFR5cGVzSWZOZWVkZWQoZnVuY3Rpb25OYW1lLCBhc3QuYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvb2t1cFJldHVyblR5cGUoZnVuY3Rpb25OYW1lLCBhc3QsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgZ2V0VHlwZSBUeXBlIFwiJHsgYXN0LnR5cGUgfVwiYCwgYXN0KTtcbiAgICAgICAgY2FzZSAnTG9naWNhbEV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiAnQm9vbGVhbic7XG4gICAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdCb29sZWFuJztcbiAgICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICAgICAgY2FzZSAnPDwnOlxuICAgICAgICAgICAgICBjYXNlICc+Pic6XG4gICAgICAgICAgICAgIGNhc2UgJz4+Pic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QubGVmdCk7XG4gICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnc2tpcC1saXRlcmFsLWNvcnJlY3Rpb24nKSkgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QucmlnaHQpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0VHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuICAgICAgICAgICAgICBpZiAoYXN0LmxlZnQudmFsdWUgJSAxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0Zsb2F0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0VHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVMb29rdXBNYXBbdHlwZV0gfHwgdHlwZTtcbiAgICAgICAgY2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpO1xuICAgICAgICBjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgIGlmIChhc3Qub3BlcmF0b3IgPT09ICd+Jykge1xuICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpO1xuICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzoge1xuICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IGFzdC5kZWNsYXJhdGlvbnM7XG4gICAgICAgICAgbGV0IGxhc3RUeXBlO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIGxhc3RUeXBlID0gdGhpcy5nZXRUeXBlKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFsYXN0VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5hYmxlIHRvIGZpbmQgdHlwZSBmb3IgZGVjbGFyYXRpb25gLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGFzdFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcbiAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHRoaXMuZ2V0RGVjbGFyYXRpb24oYXN0LmlkKTtcbiAgICAgICAgICBpZiAoIWRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmFibGUgdG8gZmluZCBkZWNsYXJhdG9yYCwgYXN0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWRlY2xhcmF0aW9uLnZhbHVlVHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5hYmxlIHRvIGZpbmQgZGVjbGFyYXRvciB2YWx1ZVR5cGVgLCBhc3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbi52YWx1ZVR5cGU7XG4gICAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxuICAgICAgICAgIGlmIChhc3QubmFtZSA9PT0gJ0luZmluaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5pc0FzdFZhcmlhYmxlKGFzdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuZ2V0VmFyaWFibGVTaWduYXR1cmUoYXN0KTtcbiAgICAgICAgICAgIGlmIChzaWduYXR1cmUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5maW5kSWRlbnRpZmllck9yaWdpbihhc3QpO1xuICAgICAgICAgIGlmIChvcmlnaW4gJiYgb3JpZ2luLmluaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUob3JpZ2luLmluaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnUmV0dXJuU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5hcmd1bWVudCk7XG4gICAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICAgIGlmICh0aGlzLmlzQXN0TWF0aEZ1bmN0aW9uKGFzdCkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXN0LnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY2VpbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICAgICAgICAgIHJldHVybiAnSW50ZWdlcic7XG4gICAgICAgICAgICAgIGNhc2UgJ3JvdW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0ludGVnZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5pc0FzdFZhcmlhYmxlKGFzdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlU2lnbmF0dXJlID0gdGhpcy5nZXRWYXJpYWJsZVNpZ25hdHVyZShhc3QpO1xuICAgICAgICAgICAgc3dpdGNoICh2YXJpYWJsZVNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZVtdW10nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRDaGVja1ZhcmlhYmxlVHlwZShhc3Qub2JqZWN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZVtdW11bXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENoZWNrVmFyaWFibGVUeXBlKGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZVtdW11bXVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZS50aHJlYWQudmFsdWUnOlxuICAgICAgICAgICAgICBjYXNlICd0aGlzLnRocmVhZC52YWx1ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmR5bmFtaWNPdXRwdXQgPyAnSW50ZWdlcicgOiAnTGl0ZXJhbEludGVnZXInO1xuICAgICAgICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uc3RhbnRUeXBlKGFzdC5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENvbnN0YW50VHlwZShhc3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q29uc3RhbnRUeXBlKGFzdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW10nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRDb25zdGFudFR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW11bXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENvbnN0YW50VHlwZShhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgY2FzZSAnZm4oKVtdJzpcbiAgICAgICAgICAgICAgY2FzZSAnZm4oKVtdW10nOlxuICAgICAgICAgICAgICBjYXNlICdmbigpW11bXVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0VHlwZShhc3Qub2JqZWN0KSk7XG4gICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FzdE1hdGhWYXJpYWJsZShhc3QpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXN0LnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdbXVtdJzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuaGFuZGxlZCBnZXRUeXBlIE1lbWJlckV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmhhbmRsZWQgZ2V0VHlwZSBNZW1iZXJFeHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5jb25zZXF1ZW50KTtcbiAgICAgICAgY2FzZSAnRnVuY3Rpb25EZWNsYXJhdGlvbic6XG4gICAgICAgIGNhc2UgJ0Z1bmN0aW9uRXhwcmVzc2lvbic6XG4gICAgICAgICAgY29uc3QgbGFzdFJldHVybiA9IHRoaXMuZmluZExhc3RSZXR1cm4oYXN0LmJvZHkpO1xuICAgICAgICAgIGlmIChsYXN0UmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGxhc3RSZXR1cm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmNvbnNlcXVlbnQpO1xuICAgICAgICBjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmV4cHJlc3Npb25zW2FzdC5leHByZXNzaW9ucy5sZW5ndGggLSAxXSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIGdldFR5cGUgVHlwZSBcIiR7IGFzdC50eXBlIH1cImAsIGFzdCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0KSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VmFyaWFibGVUeXBlKGFzdCk7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGAke2FzdC50eXBlfSBpcyBub3QgZGVmaW5lZGAsIGFzdCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgaW5mZXJBcmd1bWVudFR5cGVzSWZOZWVkZWQoZnVuY3Rpb25OYW1lLCBhcmdzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMubmVlZHNBcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpKSkgY29udGludWU7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGFyZ3NbaV0pO1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuYWJsZSB0byBpbmZlciBhcmd1bWVudCAke2l9YCwgYXJnc1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFzc2lnbkFyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGksIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlzQXN0TWF0aFZhcmlhYmxlKGFzdCkge1xuICAgIGNvbnN0IG1hdGhQcm9wZXJ0aWVzID0gW1xuICAgICAgJ0UnLFxuICAgICAgJ1BJJyxcbiAgICAgICdTUVJUMicsXG4gICAgICAnU1FSVDFfMicsXG4gICAgICAnTE4yJyxcbiAgICAgICdMTjEwJyxcbiAgICAgICdMT0cyRScsXG4gICAgICAnTE9HMTBFJyxcbiAgICBdO1xuICAgIHJldHVybiBhc3QudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmXG4gICAgICBhc3Qub2JqZWN0ICYmIGFzdC5vYmplY3QudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG4gICAgICBhc3Qub2JqZWN0Lm5hbWUgPT09ICdNYXRoJyAmJlxuICAgICAgYXN0LnByb3BlcnR5ICYmXG4gICAgICBhc3QucHJvcGVydHkudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG4gICAgICBtYXRoUHJvcGVydGllcy5pbmRleE9mKGFzdC5wcm9wZXJ0eS5uYW1lKSA+IC0xO1xuICB9XG5cbiAgaXNBc3RNYXRoRnVuY3Rpb24oYXN0KSB7XG4gICAgY29uc3QgbWF0aEZ1bmN0aW9ucyA9IFtcbiAgICAgICdhYnMnLFxuICAgICAgJ2Fjb3MnLFxuICAgICAgJ2Fjb3NoJyxcbiAgICAgICdhc2luJyxcbiAgICAgICdhc2luaCcsXG4gICAgICAnYXRhbicsXG4gICAgICAnYXRhbjInLFxuICAgICAgJ2F0YW5oJyxcbiAgICAgICdjYnJ0JyxcbiAgICAgICdjZWlsJyxcbiAgICAgICdjbHozMicsXG4gICAgICAnY29zJyxcbiAgICAgICdjb3NoJyxcbiAgICAgICdleHBtMScsXG4gICAgICAnZXhwJyxcbiAgICAgICdmbG9vcicsXG4gICAgICAnZnJvdW5kJyxcbiAgICAgICdpbXVsJyxcbiAgICAgICdsb2cnLFxuICAgICAgJ2xvZzInLFxuICAgICAgJ2xvZzEwJyxcbiAgICAgICdsb2cxcCcsXG4gICAgICAnbWF4JyxcbiAgICAgICdtaW4nLFxuICAgICAgJ3BvdycsXG4gICAgICAncmFuZG9tJyxcbiAgICAgICdyb3VuZCcsXG4gICAgICAnc2lnbicsXG4gICAgICAnc2luJyxcbiAgICAgICdzaW5oJyxcbiAgICAgICdzcXJ0JyxcbiAgICAgICd0YW4nLFxuICAgICAgJ3RhbmgnLFxuICAgICAgJ3RydW5jJyxcbiAgICBdO1xuICAgIHJldHVybiBhc3QudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJyAmJlxuICAgICAgYXN0LmNhbGxlZSAmJlxuICAgICAgYXN0LmNhbGxlZS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgJiZcbiAgICAgIGFzdC5jYWxsZWUub2JqZWN0ICYmXG4gICAgICBhc3QuY2FsbGVlLm9iamVjdC50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgIGFzdC5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdNYXRoJyAmJlxuICAgICAgYXN0LmNhbGxlZS5wcm9wZXJ0eSAmJlxuICAgICAgYXN0LmNhbGxlZS5wcm9wZXJ0eS50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgIG1hdGhGdW5jdGlvbnMuaW5kZXhPZihhc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWUpID4gLTE7XG4gIH1cblxuICBpc0FzdFZhcmlhYmxlKGFzdCkge1xuICAgIHJldHVybiBhc3QudHlwZSA9PT0gJ0lkZW50aWZpZXInIHx8IGFzdC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbic7XG4gIH1cblxuICBpc1NhZmUoYXN0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTYWZlRGVwZW5kZW5jaWVzKHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdCkpO1xuICB9XG5cbiAgaXNTYWZlRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcykge1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXMgJiYgZGVwZW5kZW5jaWVzLmV2ZXJ5ID8gZGVwZW5kZW5jaWVzLmV2ZXJ5KGRlcGVuZGVuY3kgPT4gZGVwZW5kZW5jeS5pc1NhZmUpIDogdHJ1ZTtcbiAgfVxuXG4gIGdldERlcGVuZGVuY2llcyhhc3QsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKSB7XG4gICAgaWYgKCFkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoIWFzdCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXN0KSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0W2ldLCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5sZWZ0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5yaWdodCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LnRlc3QsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmFsdGVybmF0ZSwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QuY29uc2VxdWVudCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICBvcmlnaW46ICdsaXRlcmFsJyxcbiAgICAgICAgICB2YWx1ZTogYXN0LnZhbHVlLFxuICAgICAgICAgIGlzU2FmZTogaXNOb3RTYWZlID09PSB0cnVlID8gZmFsc2UgOiBhc3QudmFsdWUgPiAtSW5maW5pdHkgJiYgYXN0LnZhbHVlIDwgSW5maW5pdHkgJiYgIWlzTmFOKGFzdC52YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5pbml0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICBjYXNlICdJZGVudGlmaWVyJzpcbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmdldERlY2xhcmF0aW9uKGFzdCk7XG4gICAgICAgIGlmIChkZWNsYXJhdGlvbikge1xuICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGFzdC5uYW1lLFxuICAgICAgICAgICAgb3JpZ2luOiAnZGVjbGFyYXRpb24nLFxuICAgICAgICAgICAgaXNTYWZlOiBpc05vdFNhZmUgPyBmYWxzZSA6IHRoaXMuaXNTYWZlRGVwZW5kZW5jaWVzKGRlY2xhcmF0aW9uLmRlcGVuZGVuY2llcyksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YoYXN0Lm5hbWUpID4gLTEpIHtcbiAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBhc3QubmFtZSxcbiAgICAgICAgICAgIG9yaWdpbjogJ2FyZ3VtZW50JyxcbiAgICAgICAgICAgIGlzU2FmZTogZmFsc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdHJpY3RUeXBpbmdDaGVja2luZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgaWRlbnRpZmllciBvcmlnaW4gXCIke2FzdC5uYW1lfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdGdW5jdGlvbkRlY2xhcmF0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5ib2R5LmJvZHlbYXN0LmJvZHkuYm9keS5sZW5ndGggLSAxXSwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgY2FzZSAnUmV0dXJuU3RhdGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5hcmd1bWVudCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnTG9naWNhbEV4cHJlc3Npb24nOlxuICAgICAgICBpc05vdFNhZmUgPSAoYXN0Lm9wZXJhdG9yID09PSAnLycgfHwgYXN0Lm9wZXJhdG9yID09PSAnKicpO1xuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QubGVmdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QucmlnaHQsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5hcmd1bWVudCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdGlvbic6XG4gICAgICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QuZGVjbGFyYXRpb25zLCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgb3JpZ2luOiAnZGVjbGFyYXRpb24nLFxuICAgICAgICAgIGlzU2FmZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6XG4gICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICBvcmlnaW46ICdmdW5jdGlvbicsXG4gICAgICAgICAgaXNTYWZlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICBjb25zdCBkZXRhaWxzID0gdGhpcy5nZXRNZW1iZXJFeHByZXNzaW9uRGV0YWlscyhhc3QpO1xuICAgICAgICBzd2l0Y2ggKGRldGFpbHMuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgY2FzZSAndmFsdWVbXSc6XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3Qub2JqZWN0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd2YWx1ZVtdW10nOlxuICAgICAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0Lm9iamVjdC5vYmplY3QsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdJzpcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuICAgICAgICAgICAgaWYgKHRoaXMuZHluYW1pY091dHB1dCkge1xuICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogZGV0YWlscy5uYW1lLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogJ291dHB1dCcsXG4gICAgICAgICAgICAgICAgaXNTYWZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICAgIGlmIChkZXRhaWxzLnByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhkZXRhaWxzLnByb3BlcnR5LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZXRhaWxzLnhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoZGV0YWlscy54UHJvcGVydHksIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRldGFpbHMueVByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhkZXRhaWxzLnlQcm9wZXJ0eSwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGV0YWlscy56UHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGRldGFpbHMuelByb3BlcnR5LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnU2VxdWVuY2VFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmV4cHJlc3Npb25zLCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIHR5cGUgJHsgYXN0LnR5cGUgfSBpbiBnZXREZXBlbmRlbmNpZXNgLCBhc3QpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVTaWduYXR1cmUoYXN0LCByZXR1cm5SYXdWYWx1ZSkge1xuICAgIGlmICghdGhpcy5pc0FzdFZhcmlhYmxlKGFzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYXN0IG9mIHR5cGUgXCIkeyBhc3QudHlwZSB9XCIgaXMgbm90IGEgdmFyaWFibGUgc2lnbmF0dXJlYCk7XG4gICAgfVxuICAgIGlmIChhc3QudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICByZXR1cm4gJ3ZhbHVlJztcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gW107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICghYXN0KSBicmVhaztcbiAgICAgIGlmIChhc3QuY29tcHV0ZWQpIHtcbiAgICAgICAgc2lnbmF0dXJlLnB1c2goJ1tdJyk7XG4gICAgICB9IGVsc2UgaWYgKGFzdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KCd0aGlzJyk7XG4gICAgICB9IGVsc2UgaWYgKGFzdC5wcm9wZXJ0eSAmJiBhc3QucHJvcGVydHkubmFtZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICd4JyB8fFxuICAgICAgICAgIGFzdC5wcm9wZXJ0eS5uYW1lID09PSAneScgfHxcbiAgICAgICAgICBhc3QucHJvcGVydHkubmFtZSA9PT0gJ3onXG4gICAgICAgICkge1xuICAgICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KHJldHVyblJhd1ZhbHVlID8gJy4nICsgYXN0LnByb3BlcnR5Lm5hbWUgOiAnLnZhbHVlJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICdjb25zdGFudHMnIHx8XG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICd0aHJlYWQnIHx8XG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICdvdXRwdXQnXG4gICAgICAgICkge1xuICAgICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KCcuJyArIGFzdC5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaWduYXR1cmUudW5zaGlmdChyZXR1cm5SYXdWYWx1ZSA/ICcuJyArIGFzdC5wcm9wZXJ0eS5uYW1lIDogJy52YWx1ZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFzdC5uYW1lKSB7XG4gICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KHJldHVyblJhd1ZhbHVlID8gYXN0Lm5hbWUgOiAndmFsdWUnKTtcbiAgICAgIH0gZWxzZSBpZiAoYXN0LmNhbGxlZSAmJiBhc3QuY2FsbGVlLm5hbWUpIHtcbiAgICAgICAgc2lnbmF0dXJlLnVuc2hpZnQocmV0dXJuUmF3VmFsdWUgPyBhc3QuY2FsbGVlLm5hbWUgKyAnKCknIDogJ2ZuKCknKTtcbiAgICAgIH0gZWxzZSBpZiAoYXN0LmVsZW1lbnRzKSB7XG4gICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KCdbXScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2lnbmF0dXJlLnVuc2hpZnQoJ3Vua25vd24nKTtcbiAgICAgIH1cbiAgICAgIGFzdCA9IGFzdC5vYmplY3Q7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmF0dXJlU3RyaW5nID0gc2lnbmF0dXJlLmpvaW4oJycpO1xuICAgIGlmIChyZXR1cm5SYXdWYWx1ZSkge1xuICAgICAgcmV0dXJuIHNpZ25hdHVyZVN0cmluZztcbiAgICB9XG5cbiAgICBjb25zdCBhbGxvd2VkRXhwcmVzc2lvbnMgPSBbXG4gICAgICAndmFsdWUnLFxuICAgICAgJ3ZhbHVlW10nLFxuICAgICAgJ3ZhbHVlW11bXScsXG4gICAgICAndmFsdWVbXVtdW10nLFxuICAgICAgJ3ZhbHVlW11bXVtdW10nLFxuICAgICAgJ3ZhbHVlLnZhbHVlJyxcbiAgICAgICd2YWx1ZS50aHJlYWQudmFsdWUnLFxuICAgICAgJ3RoaXMudGhyZWFkLnZhbHVlJyxcbiAgICAgICd0aGlzLm91dHB1dC52YWx1ZScsXG4gICAgICAndGhpcy5jb25zdGFudHMudmFsdWUnLFxuICAgICAgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW10nLFxuICAgICAgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXScsXG4gICAgICAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW10nLFxuICAgICAgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdW10nLFxuICAgICAgJ2ZuKClbXScsXG4gICAgICAnZm4oKVtdW10nLFxuICAgICAgJ2ZuKClbXVtdW10nLFxuICAgICAgJ1tdW10nLFxuICAgIF07XG4gICAgaWYgKGFsbG93ZWRFeHByZXNzaW9ucy5pbmRleE9mKHNpZ25hdHVyZVN0cmluZykgPiAtMSkge1xuICAgICAgcmV0dXJuIHNpZ25hdHVyZVN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBidWlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpLmxlbmd0aCA+IDA7XG4gIH1cblxuICBhc3RHZW5lcmljKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKGFzdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnTlVMTCBhc3QnLCBhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhc3QpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdFtpXSwgcmV0QXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uRGVjbGFyYXRpb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdGdW5jdGlvbkV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0UmV0dXJuU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0TGl0ZXJhbChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEJpbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdJZGVudGlmaWVyJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RJZGVudGlmaWVyRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RBc3NpZ25tZW50RXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEV4cHJlc3Npb25TdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdFbXB0eVN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0RW1wdHlTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdCbG9ja1N0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0QmxvY2tTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdJZlN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0SWZTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdTd2l0Y2hTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFN3aXRjaFN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0JyZWFrU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RCcmVha1N0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0NvbnRpbnVlU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RDb250aW51ZVN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0Rm9yU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFdoaWxlU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnRG9XaGlsZVN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0RG9XaGlsZVN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFZhcmlhYmxlRGVjbGFyYXRpb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0b3InOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFZhcmlhYmxlRGVjbGFyYXRvcihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1RoaXNFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RUaGlzRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0U2VxdWVuY2VFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RVbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RVcGRhdGVFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnTG9naWNhbEV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdExvZ2ljYWxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RDYWxsRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0QXJyYXlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnRGVidWdnZXJTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdERlYnVnZ2VyU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RDb25kaXRpb25hbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmtub3duIGFzdCB0eXBlIDogJyArIGFzdC50eXBlLCBhc3QpO1xuICAgIH1cbiAgfVxuICBhc3RFcnJvck91dHB1dChlcnJvciwgYXN0KSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlYnVnU3RyaW5nID0gdXRpbHMuZ2V0QXN0U3RyaW5nKHRoaXMuc291cmNlLCBhc3QpO1xuICAgIGNvbnN0IGxlYWRpbmdTb3VyY2UgPSB0aGlzLnNvdXJjZS5zdWJzdHIoYXN0LnN0YXJ0KTtcbiAgICBjb25zdCBzcGxpdExpbmVzID0gbGVhZGluZ1NvdXJjZS5zcGxpdCgvXFxuLyk7XG4gICAgY29uc3QgbGluZUJlZm9yZSA9IHNwbGl0TGluZXMubGVuZ3RoID4gMCA/IHNwbGl0TGluZXNbc3BsaXRMaW5lcy5sZW5ndGggLSAxXSA6IDA7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgJHtlcnJvcn0gb24gbGluZSAkeyBzcGxpdExpbmVzLmxlbmd0aCB9LCBwb3NpdGlvbiAkeyBsaW5lQmVmb3JlLmxlbmd0aCB9OlxcbiAkeyBkZWJ1Z1N0cmluZyB9YCk7XG4gIH1cblxuICBhc3REZWJ1Z2dlclN0YXRlbWVudChhcnJOb2RlLCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0Q29uZGl0aW9uYWxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnTm90IGEgY29uZGl0aW9uYWwgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCc/Jyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCc6Jyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0RnVuY3Rpb24oYXN0LCByZXRBcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiYXN0RnVuY3Rpb25cIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgYXN0RnVuY3Rpb25EZWNsYXJhdGlvbihhc3QsIHJldEFycikge1xuICAgIGlmICh0aGlzLmlzQ2hpbGRGdW5jdGlvbihhc3QpKSB7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hc3RGdW5jdGlvbihhc3QsIHJldEFycik7XG4gIH1cbiAgYXN0RnVuY3Rpb25FeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKHRoaXMuaXNDaGlsZEZ1bmN0aW9uKGFzdCkpIHtcbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uKGFzdCwgcmV0QXJyKTtcbiAgfVxuICBpc0NoaWxkRnVuY3Rpb24oYXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zW2ldID09PSBhc3QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3RSZXR1cm5TdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdExpdGVyYWwoYXN0LCByZXRBcnIpIHtcbiAgICB0aGlzLmxpdGVyYWxUeXBlc1t0aGlzLmFzdEtleShhc3QpXSA9ICdOdW1iZXInO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0QmluYXJ5RXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0SWRlbnRpZmllckV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdEFzc2lnbm1lbnRFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RFeHByZXNzaW9uU3RhdGVtZW50KGVzTm9kZSwgcmV0QXJyKSB7XG4gICAgdGhpcy5hc3RHZW5lcmljKGVzTm9kZS5leHByZXNzaW9uLCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RFbXB0eVN0YXRlbWVudChlTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RCbG9ja1N0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0SWZTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdFN3aXRjaFN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0QnJlYWtTdGF0ZW1lbnQoYnJOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnYnJlYWs7Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RDb250aW51ZVN0YXRlbWVudChjck5vZGUsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKCdjb250aW51ZTtcXG4nKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdEZvclN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0V2hpbGVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdERvV2hpbGVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdFZhcmlhYmxlRGVjbGFyYXRvcihpVmFyRGVjTm9kZSwgcmV0QXJyKSB7XG4gICAgdGhpcy5hc3RHZW5lcmljKGlWYXJEZWNOb2RlLmlkLCByZXRBcnIpO1xuICAgIGlmIChpVmFyRGVjTm9kZS5pbml0ICE9PSBudWxsKSB7XG4gICAgICByZXRBcnIucHVzaCgnPScpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGlWYXJEZWNOb2RlLmluaXQsIHJldEFycik7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0VGhpc0V4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdFNlcXVlbmNlRXhwcmVzc2lvbihzTm9kZSwgcmV0QXJyKSB7XG4gICAgY29uc3QgeyBleHByZXNzaW9ucyB9ID0gc05vZGU7XG4gICAgY29uc3Qgc2VxdWVuY2VSZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gZXhwcmVzc2lvbnNbaV07XG4gICAgICBjb25zdCBleHByZXNzaW9uUmVzdWx0ID0gW107XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZXhwcmVzc2lvbiwgZXhwcmVzc2lvblJlc3VsdCk7XG4gICAgICBzZXF1ZW5jZVJlc3VsdC5wdXNoKGV4cHJlc3Npb25SZXN1bHQuam9pbignJykpO1xuICAgIH1cbiAgICBpZiAoc2VxdWVuY2VSZXN1bHQubGVuZ3RoID4gMSkge1xuICAgICAgcmV0QXJyLnB1c2goJygnLCBzZXF1ZW5jZVJlc3VsdC5qb2luKCcsJyksICcpJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKHNlcXVlbmNlUmVzdWx0WzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RVbmFyeUV4cHJlc3Npb24odU5vZGUsIHJldEFycikge1xuICAgIGNvbnN0IHVuYXJ5UmVzdWx0ID0gdGhpcy5jaGVja0FuZFVwY29udmVydEJpdHdpc2VVbmFyeSh1Tm9kZSwgcmV0QXJyKTtcbiAgICBpZiAodW5hcnlSZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfVxuXG4gICAgaWYgKHVOb2RlLnByZWZpeCkge1xuICAgICAgcmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKHVOb2RlLmFyZ3VtZW50LCByZXRBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWModU5vZGUuYXJndW1lbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCh1Tm9kZS5vcGVyYXRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNoZWNrQW5kVXBjb252ZXJ0Qml0d2lzZVVuYXJ5KHVOb2RlLCByZXRBcnIpIHt9XG5cbiAgYXN0VXBkYXRlRXhwcmVzc2lvbih1Tm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKHVOb2RlLnByZWZpeCkge1xuICAgICAgcmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKHVOb2RlLmFyZ3VtZW50LCByZXRBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWModU5vZGUuYXJndW1lbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCh1Tm9kZS5vcGVyYXRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RMb2dpY2FsRXhwcmVzc2lvbihsb2dOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhsb2dOb2RlLmxlZnQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2gobG9nTm9kZS5vcGVyYXRvcik7XG4gICAgdGhpcy5hc3RHZW5lcmljKGxvZ05vZGUucmlnaHQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdE1lbWJlckV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdENhbGxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RBcnJheUV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgZ2V0TWVtYmVyRXhwcmVzc2lvbkRldGFpbHMoYXN0KSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYEV4cHJlc3Npb24gJHsgYXN0LnR5cGUgfSBub3QgYSBNZW1iZXJFeHByZXNzaW9uYCwgYXN0KTtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSBudWxsO1xuICAgIGxldCB0eXBlID0gbnVsbDtcbiAgICBjb25zdCB2YXJpYWJsZVNpZ25hdHVyZSA9IHRoaXMuZ2V0VmFyaWFibGVTaWduYXR1cmUoYXN0KTtcbiAgICBzd2l0Y2ggKHZhcmlhYmxlU2lnbmF0dXJlKSB7XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSAndmFsdWUudGhyZWFkLnZhbHVlJzpcbiAgICAgIGNhc2UgJ3RoaXMudGhyZWFkLnZhbHVlJzpcbiAgICAgIGNhc2UgJ3RoaXMub3V0cHV0LnZhbHVlJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgdHlwZTogJ0ludGVnZXInLFxuICAgICAgICAgICAgbmFtZTogYXN0LnByb3BlcnR5Lm5hbWVcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3ZhbHVlW10nOlxuICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3QubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm5hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBvcmlnaW46ICd1c2VyJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmdldFZhcmlhYmxlVHlwZShhc3Qub2JqZWN0KSxcbiAgICAgICAgICAgIHhQcm9wZXJ0eTogYXN0LnByb3BlcnR5XG4gICAgICAgIH07XG4gICAgICBjYXNlICd2YWx1ZVtdW10nOlxuICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3Qub2JqZWN0Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5vYmplY3QubmFtZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIG9yaWdpbjogJ3VzZXInLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0VmFyaWFibGVUeXBlKGFzdC5vYmplY3Qub2JqZWN0KSxcbiAgICAgICAgICAgIHlQcm9wZXJ0eTogYXN0Lm9iamVjdC5wcm9wZXJ0eSxcbiAgICAgICAgICAgIHhQcm9wZXJ0eTogYXN0LnByb3BlcnR5LFxuICAgICAgICB9O1xuICAgICAgY2FzZSAndmFsdWVbXVtdW10nOlxuICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5uYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgb3JpZ2luOiAndXNlcicsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0KSxcbiAgICAgICAgICAgIHpQcm9wZXJ0eTogYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdW10nOlxuICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm5hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBvcmlnaW46ICd1c2VyJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmdldFZhcmlhYmxlVHlwZShhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0KSxcbiAgICAgICAgICAgIHpQcm9wZXJ0eTogYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlJzpcbiAgICAgICAgaWYgKHR5cGVvZiBhc3QucHJvcGVydHkubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQXN0TWF0aFZhcmlhYmxlKGFzdCkpIHtcbiAgICAgICAgICBuYW1lID0gYXN0LnByb3BlcnR5Lm5hbWU7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBvcmlnaW46ICdNYXRoJyxcbiAgICAgICAgICAgIHR5cGU6ICdOdW1iZXInLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYXN0LnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm5hbWU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBwcm9wZXJ0eTogYXN0LnByb3BlcnR5Lm5hbWUsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiAndXNlcicsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnTnVtYmVyJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZSc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBhc3QucHJvcGVydHkubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5hbWUgPSBhc3QucHJvcGVydHkubmFtZTtcbiAgICAgICAgICB0eXBlID0gdGhpcy5nZXRDb25zdGFudFR5cGUobmFtZSk7XG4gICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdDb25zdGFudCBoYXMgbm8gdHlwZScsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG9yaWdpbjogJ2NvbnN0YW50cycsXG4gICAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXSc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBhc3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgIHR5cGUgPSB0aGlzLmdldENvbnN0YW50VHlwZShuYW1lKTtcbiAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0NvbnN0YW50IGhhcyBubyB0eXBlJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb3JpZ2luOiAnY29uc3RhbnRzJyxcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgeFByb3BlcnR5OiBhc3QucHJvcGVydHksXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdJzoge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHkubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgIHR5cGUgPSB0aGlzLmdldENvbnN0YW50VHlwZShuYW1lKTtcbiAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0NvbnN0YW50IGhhcyBubyB0eXBlJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb3JpZ2luOiAnY29uc3RhbnRzJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdJzoge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWU7XG4gICAgICAgICAgdHlwZSA9IHRoaXMuZ2V0Q29uc3RhbnRUeXBlKG5hbWUpO1xuICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnQ29uc3RhbnQgaGFzIG5vIHR5cGUnLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBvcmlnaW46ICdjb25zdGFudHMnLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgIHpQcm9wZXJ0eTogYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2ZuKClbXSc6XG4gICAgICAgIGNhc2UgJ2ZuKClbXVtdJzpcbiAgICAgICAgY2FzZSAnW11bXSc6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBhc3QucHJvcGVydHksXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgIH1cbiAgfVxuXG4gIGZpbmRJZGVudGlmaWVyT3JpZ2luKGFzdFRvRmluZCkge1xuICAgIGNvbnN0IHN0YWNrID0gW3RoaXMuYXN0XTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBhdE5vZGUgPSBzdGFja1swXTtcbiAgICAgIGlmIChhdE5vZGUudHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRvcicgJiYgYXROb2RlLmlkICYmIGF0Tm9kZS5pZC5uYW1lICYmIGF0Tm9kZS5pZC5uYW1lID09PSBhc3RUb0ZpbmQubmFtZSkge1xuICAgICAgICByZXR1cm4gYXROb2RlO1xuICAgICAgfVxuICAgICAgc3RhY2suc2hpZnQoKTtcbiAgICAgIGlmIChhdE5vZGUuYXJndW1lbnQpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuYXJndW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChhdE5vZGUuYm9keSkge1xuICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZS5ib2R5KTtcbiAgICAgIH0gZWxzZSBpZiAoYXROb2RlLmRlY2xhcmF0aW9ucykge1xuICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZS5kZWNsYXJhdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGF0Tm9kZSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdE5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmaW5kTGFzdFJldHVybihhc3QpIHtcbiAgICBjb25zdCBzdGFjayA9IFthc3QgfHwgdGhpcy5hc3RdO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGF0Tm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgaWYgKGF0Tm9kZS50eXBlID09PSAnUmV0dXJuU3RhdGVtZW50Jykge1xuICAgICAgICByZXR1cm4gYXROb2RlO1xuICAgICAgfVxuICAgICAgaWYgKGF0Tm9kZS50eXBlID09PSAnRnVuY3Rpb25EZWNsYXJhdGlvbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYXROb2RlLmFyZ3VtZW50KSB7XG4gICAgICAgIHN0YWNrLnB1c2goYXROb2RlLmFyZ3VtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoYXROb2RlLmJvZHkpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuYm9keSk7XG4gICAgICB9IGVsc2UgaWYgKGF0Tm9kZS5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuZGVjbGFyYXRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhdE5vZGUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXROb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChhdE5vZGVbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGF0Tm9kZS5jb25zZXF1ZW50KSB7XG4gICAgICAgIHN0YWNrLnB1c2goYXROb2RlLmNvbnNlcXVlbnQpO1xuICAgICAgfSBlbHNlIGlmIChhdE5vZGUuY2FzZXMpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuY2FzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldEludGVybmFsVmFyaWFibGVOYW1lKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2ludGVybmFsVmFyaWFibGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgdGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzW25hbWVdID0gMDtcbiAgICB9XG4gICAgdGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzW25hbWVdKys7XG4gICAgaWYgKHRoaXMuX2ludGVybmFsVmFyaWFibGVOYW1lc1tuYW1lXSA9PT0gMSkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBuYW1lICsgdGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzW25hbWVdO1xuICB9XG5cbiAgYXN0S2V5KGFzdCwgc2VwYXJhdG9yID0gJywnKSB7XG4gICAgaWYgKCFhc3Quc3RhcnQgfHwgIWFzdC5lbmQpIHRocm93IG5ldyBFcnJvcignQVNUIHN0YXJ0IGFuZCBlbmQgbmVlZGVkJyk7XG4gICAgcmV0dXJuIGAke2FzdC5zdGFydH0ke3NlcGFyYXRvcn0ke2FzdC5lbmR9YDtcbiAgfVxufVxuXG5jb25zdCB0eXBlTG9va3VwTWFwID0ge1xuICAnTnVtYmVyJzogJ051bWJlcicsXG4gICdGbG9hdCc6ICdGbG9hdCcsXG4gICdJbnRlZ2VyJzogJ0ludGVnZXInLFxuICAnQXJyYXknOiAnTnVtYmVyJyxcbiAgJ0FycmF5KDIpJzogJ051bWJlcicsXG4gICdBcnJheSgzKSc6ICdOdW1iZXInLFxuICAnQXJyYXkoNCknOiAnTnVtYmVyJyxcbiAgJ01hdHJpeCgyKSc6ICdOdW1iZXInLFxuICAnTWF0cml4KDMpJzogJ051bWJlcicsXG4gICdNYXRyaXgoNCknOiAnTnVtYmVyJyxcbiAgJ0FycmF5MkQnOiAnTnVtYmVyJyxcbiAgJ0FycmF5M0QnOiAnTnVtYmVyJyxcbiAgJ0lucHV0JzogJ051bWJlcicsXG4gICdIVE1MQ2FudmFzJzogJ0FycmF5KDQpJyxcbiAgJ09mZnNjcmVlbkNhbnZhcyc6ICdBcnJheSg0KScsXG4gICdIVE1MSW1hZ2UnOiAnQXJyYXkoNCknLFxuICAnSW1hZ2VCaXRtYXAnOiAnQXJyYXkoNCknLFxuICAnSW1hZ2VEYXRhJzogJ0FycmF5KDQpJyxcbiAgJ0hUTUxWaWRlbyc6ICdBcnJheSg0KScsXG4gICdIVE1MSW1hZ2VBcnJheSc6ICdBcnJheSg0KScsXG4gICdOdW1iZXJUZXh0dXJlJzogJ051bWJlcicsXG4gICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogJ051bWJlcicsXG4gICdBcnJheTFEKDIpJzogJ0FycmF5KDIpJyxcbiAgJ0FycmF5MUQoMyknOiAnQXJyYXkoMyknLFxuICAnQXJyYXkxRCg0KSc6ICdBcnJheSg0KScsXG4gICdBcnJheTJEKDIpJzogJ0FycmF5KDIpJyxcbiAgJ0FycmF5MkQoMyknOiAnQXJyYXkoMyknLFxuICAnQXJyYXkyRCg0KSc6ICdBcnJheSg0KScsXG4gICdBcnJheTNEKDIpJzogJ0FycmF5KDIpJyxcbiAgJ0FycmF5M0QoMyknOiAnQXJyYXkoMyknLFxuICAnQXJyYXkzRCg0KSc6ICdBcnJheSg0KScsXG4gICdBcnJheVRleHR1cmUoMSknOiAnTnVtYmVyJyxcbiAgJ0FycmF5VGV4dHVyZSgyKSc6ICdBcnJheSgyKScsXG4gICdBcnJheVRleHR1cmUoMyknOiAnQXJyYXkoMyknLFxuICAnQXJyYXlUZXh0dXJlKDQpJzogJ0FycmF5KDQpJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBGdW5jdGlvbk5vZGVcbn07XG59LHtcIi4uL3V0aWxzXCI6MTE0LFwiLi9mdW5jdGlvbi10cmFjZXJcIjoxMSxcImFjb3JuXCI6MX1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5Lmxlbmd0aCA+IDAgPyBhcnJheVthcnJheS5sZW5ndGggLSAxXSA6IG51bGw7XG59XG5cbmNvbnN0IHN0YXRlcyA9IHtcbiAgdHJhY2tJZGVudGlmaWVyczogJ3RyYWNrSWRlbnRpZmllcnMnLFxuICBtZW1iZXJFeHByZXNzaW9uOiAnbWVtYmVyRXhwcmVzc2lvbicsXG4gIGluRm9yTG9vcEluaXQ6ICdpbkZvckxvb3BJbml0J1xufTtcblxuY2xhc3MgRnVuY3Rpb25UcmFjZXIge1xuICBjb25zdHJ1Y3Rvcihhc3QpIHtcbiAgICB0aGlzLnJ1bm5pbmdDb250ZXh0cyA9IFtdO1xuICAgIHRoaXMuZnVuY3Rpb25Db250ZXh0cyA9IFtdO1xuICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICB0aGlzLmZ1bmN0aW9uQ2FsbHMgPSBbXTtcbiAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IFtdO1xuICAgIHRoaXMuaWRlbnRpZmllcnMgPSBbXTtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICAgIHRoaXMucmV0dXJuU3RhdGVtZW50cyA9IFtdO1xuICAgIHRoaXMudHJhY2tlZElkZW50aWZpZXJzID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgIHRoaXMubmV3RnVuY3Rpb25Db250ZXh0KCk7XG4gICAgdGhpcy5zY2FuKGFzdCk7XG4gIH1cblxuICBpc1N0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzW3RoaXMuc3RhdGVzLmxlbmd0aCAtIDFdID09PSBzdGF0ZTtcbiAgfVxuXG4gIGhhc1N0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzLmluZGV4T2Yoc3RhdGUpID4gLTE7XG4gIH1cblxuICBwdXNoU3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgfVxuXG4gIHBvcFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuaXNTdGF0ZShzdGF0ZSkpIHtcbiAgICAgIHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwb3AgdGhlIG5vbi1hY3RpdmUgc3RhdGUgXCIke3N0YXRlfVwiYCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGN1cnJlbnRGdW5jdGlvbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIGxhc3QodGhpcy5mdW5jdGlvbkNvbnRleHRzKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50Q29udGV4dCgpIHtcbiAgICByZXR1cm4gbGFzdCh0aGlzLnJ1bm5pbmdDb250ZXh0cyk7XG4gIH1cblxuICBuZXdGdW5jdGlvbkNvbnRleHQoKSB7XG4gICAgY29uc3QgbmV3Q29udGV4dCA9IHsgJ0Bjb250ZXh0VHlwZSc6ICdmdW5jdGlvbicgfTtcbiAgICB0aGlzLmNvbnRleHRzLnB1c2gobmV3Q29udGV4dCk7XG4gICAgdGhpcy5mdW5jdGlvbkNvbnRleHRzLnB1c2gobmV3Q29udGV4dCk7XG4gIH1cblxuICBuZXdDb250ZXh0KHJ1bikge1xuICAgIGNvbnN0IG5ld0NvbnRleHQgPSBPYmplY3QuYXNzaWduKHsgJ0Bjb250ZXh0VHlwZSc6ICdjb25zdC9sZXQnIH0sIHRoaXMuY3VycmVudENvbnRleHQpO1xuICAgIHRoaXMuY29udGV4dHMucHVzaChuZXdDb250ZXh0KTtcbiAgICB0aGlzLnJ1bm5pbmdDb250ZXh0cy5wdXNoKG5ld0NvbnRleHQpO1xuICAgIHJ1bigpO1xuICAgIGNvbnN0IHsgY3VycmVudEZ1bmN0aW9uQ29udGV4dCB9ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IHAgaW4gY3VycmVudEZ1bmN0aW9uQ29udGV4dCkge1xuICAgICAgaWYgKCFjdXJyZW50RnVuY3Rpb25Db250ZXh0Lmhhc093blByb3BlcnR5KHApIHx8IG5ld0NvbnRleHQuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgICAgbmV3Q29udGV4dFtwXSA9IGN1cnJlbnRGdW5jdGlvbkNvbnRleHRbcF07XG4gICAgfVxuICAgIHRoaXMucnVubmluZ0NvbnRleHRzLnBvcCgpO1xuICAgIHJldHVybiBuZXdDb250ZXh0O1xuICB9XG5cbiAgdXNlRnVuY3Rpb25Db250ZXh0KHJ1bikge1xuICAgIGNvbnN0IGZ1bmN0aW9uQ29udGV4dCA9IGxhc3QodGhpcy5mdW5jdGlvbkNvbnRleHRzKTtcbiAgICB0aGlzLnJ1bm5pbmdDb250ZXh0cy5wdXNoKGZ1bmN0aW9uQ29udGV4dCk7XG4gICAgcnVuKCk7XG4gICAgdGhpcy5ydW5uaW5nQ29udGV4dHMucG9wKCk7XG4gIH1cblxuICBnZXRJZGVudGlmaWVycyhydW4pIHtcbiAgICBjb25zdCB0cmFja2VkSWRlbnRpZmllcnMgPSB0aGlzLnRyYWNrZWRJZGVudGlmaWVycyA9IFtdO1xuICAgIHRoaXMucHVzaFN0YXRlKHN0YXRlcy50cmFja0lkZW50aWZpZXJzKTtcbiAgICBydW4oKTtcbiAgICB0aGlzLnRyYWNrZWRJZGVudGlmaWVycyA9IG51bGw7XG4gICAgdGhpcy5wb3BTdGF0ZShzdGF0ZXMudHJhY2tJZGVudGlmaWVycyk7XG4gICAgcmV0dXJuIHRyYWNrZWRJZGVudGlmaWVycztcbiAgfVxuXG4gIGdldERlY2xhcmF0aW9uKG5hbWUpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRDb250ZXh0LCBjdXJyZW50RnVuY3Rpb25Db250ZXh0LCBydW5uaW5nQ29udGV4dHMgfSA9IHRoaXM7XG4gICAgY29uc3QgZGVjbGFyYXRpb24gPSBjdXJyZW50Q29udGV4dFtuYW1lXSB8fCBjdXJyZW50RnVuY3Rpb25Db250ZXh0W25hbWVdIHx8IG51bGw7XG5cbiAgICBpZiAoXG4gICAgICAhZGVjbGFyYXRpb24gJiZcbiAgICAgIGN1cnJlbnRDb250ZXh0ID09PSBjdXJyZW50RnVuY3Rpb25Db250ZXh0ICYmXG4gICAgICBydW5uaW5nQ29udGV4dHMubGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgY29uc3QgcHJldmlvdXNSdW5uaW5nQ29udGV4dCA9IHJ1bm5pbmdDb250ZXh0c1tydW5uaW5nQ29udGV4dHMubGVuZ3RoIC0gMl07XG4gICAgICBpZiAocHJldmlvdXNSdW5uaW5nQ29udGV4dFtuYW1lXSkge1xuICAgICAgICByZXR1cm4gcHJldmlvdXNSdW5uaW5nQ29udGV4dFtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gIH1cblxuICBzY2FuKGFzdCkge1xuICAgIGlmICghYXN0KSByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXN0KSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5zY2FuKGFzdFtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ1Byb2dyYW0nOlxuICAgICAgICB0aGlzLnVzZUZ1bmN0aW9uQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC5ib2R5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuICAgICAgICB0aGlzLm5ld0NvbnRleHQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2Nhbihhc3QuYm9keSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ0xvZ2ljYWxFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5sZWZ0KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5yaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QubGVmdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QucmlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICBpZiAoYXN0Lm9wZXJhdG9yID09PSAnKysnKSB7XG4gICAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmdldERlY2xhcmF0aW9uKGFzdC5hcmd1bWVudC5uYW1lKTtcbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLnN1Z2dlc3RlZFR5cGUgPSAnSW50ZWdlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuYXJndW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuYXJndW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOlxuICAgICAgICBpZiAoYXN0LmtpbmQgPT09ICd2YXInKSB7XG4gICAgICAgICAgdGhpcy51c2VGdW5jdGlvbkNvbnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgYXN0LmRlY2xhcmF0aW9ucyA9IHV0aWxzLm5vcm1hbGl6ZURlY2xhcmF0aW9ucyhhc3QpO1xuICAgICAgICAgICAgdGhpcy5zY2FuKGFzdC5kZWNsYXJhdGlvbnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzdC5kZWNsYXJhdGlvbnMgPSB1dGlscy5ub3JtYWxpemVEZWNsYXJhdGlvbnMoYXN0KTtcbiAgICAgICAgICB0aGlzLnNjYW4oYXN0LmRlY2xhcmF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0b3InOiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudENvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGluRm9yTG9vcEluaXQgPSB0aGlzLmhhc1N0YXRlKHN0YXRlcy5pbkZvckxvb3BJbml0KTtcbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB7XG4gICAgICAgICAgYXN0OiBhc3QsXG4gICAgICAgICAgY29udGV4dDogY3VycmVudENvbnRleHQsXG4gICAgICAgICAgbmFtZTogYXN0LmlkLm5hbWUsXG4gICAgICAgICAgb3JpZ2luOiAnZGVjbGFyYXRpb24nLFxuICAgICAgICAgIGluRm9yTG9vcEluaXQsXG4gICAgICAgICAgaW5Gb3JMb29wVGVzdDogbnVsbCxcbiAgICAgICAgICBhc3NpZ25hYmxlOiBjdXJyZW50Q29udGV4dCA9PT0gdGhpcy5jdXJyZW50RnVuY3Rpb25Db250ZXh0IHx8ICghaW5Gb3JMb29wSW5pdCAmJiAhY3VycmVudENvbnRleHQuaGFzT3duUHJvcGVydHkoYXN0LmlkLm5hbWUpKSxcbiAgICAgICAgICBzdWdnZXN0ZWRUeXBlOiBudWxsLFxuICAgICAgICAgIHZhbHVlVHlwZTogbnVsbCxcbiAgICAgICAgICBkZXBlbmRlbmNpZXM6IG51bGwsXG4gICAgICAgICAgaXNTYWZlOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWN1cnJlbnRDb250ZXh0W2FzdC5pZC5uYW1lXSkge1xuICAgICAgICAgIGN1cnJlbnRDb250ZXh0W2FzdC5pZC5uYW1lXSA9IGRlY2xhcmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zLnB1c2goZGVjbGFyYXRpb24pO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LmlkKTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5pbml0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdGdW5jdGlvbkV4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnRnVuY3Rpb25EZWNsYXJhdGlvbic6XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmdDb250ZXh0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnNjYW4oYXN0LmJvZHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZnVuY3Rpb25zLnB1c2goYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0lmU3RhdGVtZW50JzpcbiAgICAgICAgdGhpcy5zY2FuKGFzdC50ZXN0KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5jb25zZXF1ZW50KTtcbiAgICAgICAgaWYgKGFzdC5hbHRlcm5hdGUpIHRoaXMuc2Nhbihhc3QuYWx0ZXJuYXRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdGb3JTdGF0ZW1lbnQnOiB7XG4gICAgICAgIGxldCB0ZXN0SWRlbnRpZmllcnM7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLm5ld0NvbnRleHQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucHVzaFN0YXRlKHN0YXRlcy5pbkZvckxvb3BJbml0KTtcbiAgICAgICAgICB0aGlzLnNjYW4oYXN0LmluaXQpO1xuICAgICAgICAgIHRoaXMucG9wU3RhdGUoc3RhdGVzLmluRm9yTG9vcEluaXQpO1xuXG4gICAgICAgICAgdGVzdElkZW50aWZpZXJzID0gdGhpcy5nZXRJZGVudGlmaWVycygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjYW4oYXN0LnRlc3QpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC51cGRhdGUpO1xuICAgICAgICAgIHRoaXMubmV3Q29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjYW4oYXN0LmJvZHkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGVzdElkZW50aWZpZXJzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwIGluIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChwID09PSAnQGNvbnRleHRUeXBlJykgY29udGludWU7XG4gICAgICAgICAgICBpZiAodGVzdElkZW50aWZpZXJzLmluZGV4T2YocCkgPiAtMSkge1xuICAgICAgICAgICAgICBjb250ZXh0W3BdLmluRm9yTG9vcFRlc3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgY2FzZSAnV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICB0aGlzLm5ld0NvbnRleHQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2Nhbihhc3QuYm9keSk7XG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC50ZXN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSWRlbnRpZmllcic6IHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZShzdGF0ZXMudHJhY2tJZGVudGlmaWVycykpIHtcbiAgICAgICAgICB0aGlzLnRyYWNrZWRJZGVudGlmaWVycy5wdXNoKGFzdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkZW50aWZpZXJzLnB1c2goe1xuICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY3VycmVudENvbnRleHQsXG4gICAgICAgICAgZGVjbGFyYXRpb246IHRoaXMuZ2V0RGVjbGFyYXRpb24oYXN0Lm5hbWUpLFxuICAgICAgICAgIGFzdCxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnUmV0dXJuU3RhdGVtZW50JzpcbiAgICAgICAgdGhpcy5yZXR1cm5TdGF0ZW1lbnRzLnB1c2goYXN0KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5hcmd1bWVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKHN0YXRlcy5tZW1iZXJFeHByZXNzaW9uKTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5vYmplY3QpO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LnByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZShzdGF0ZXMubWVtYmVyRXhwcmVzc2lvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRXhwcmVzc2lvblN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuZXhwcmVzc2lvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnU2VxdWVuY2VFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5leHByZXNzaW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQ2FsbEV4cHJlc3Npb24nOlxuICAgICAgICB0aGlzLmZ1bmN0aW9uQ2FsbHMucHVzaCh7XG4gICAgICAgICAgY29udGV4dDogdGhpcy5jdXJyZW50Q29udGV4dCxcbiAgICAgICAgICBhc3QsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LmFyZ3VtZW50cyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXlFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5lbGVtZW50cyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5zY2FuKGFzdC50ZXN0KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5hbHRlcm5hdGUpO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LmNvbnNlcXVlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1N3aXRjaFN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuZGlzY3JpbWluYW50KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5jYXNlcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnU3dpdGNoQ2FzZSc6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QudGVzdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuY29uc2VxdWVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdUaGlzRXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgIGNhc2UgJ0RlYnVnZ2VyU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ0VtcHR5U3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ0JyZWFrU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ0NvbnRpbnVlU3RhdGVtZW50JzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCB0eXBlIFwiJHthc3QudHlwZX1cImApO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRnVuY3Rpb25UcmFjZXIsXG59O1xufSx7XCIuLi91dGlsc1wiOjExNH1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgZ2xXaXJldGFwIH0gPSByZXF1aXJlKCdnbC13aXJldGFwJyk7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiB0b1N0cmluZ1dpdGhvdXRVdGlscyhmbikge1xuICByZXR1cm4gZm4udG9TdHJpbmcoKVxuICAgIC5yZXBsYWNlKCc9PicsICcnKVxuICAgIC5yZXBsYWNlKC9eZnVuY3Rpb24gLywgJycpXG4gICAgLnJlcGxhY2UoL3V0aWxzWy5dL2csICcvKnV0aWxzLiovJyk7XG59XG5cbmZ1bmN0aW9uIGdsS2VybmVsU3RyaW5nKEtlcm5lbCwgYXJncywgb3JpZ2luS2VybmVsLCBzZXR1cENvbnRleHRTdHJpbmcsIGRlc3Ryb3lDb250ZXh0U3RyaW5nKSB7XG4gIGlmICghb3JpZ2luS2VybmVsLmJ1aWx0KSB7XG4gICAgb3JpZ2luS2VybmVsLmJ1aWxkLmFwcGx5KG9yaWdpbktlcm5lbCwgYXJncyk7XG4gIH1cbiAgYXJncyA9IGFyZ3MgPyBBcnJheS5mcm9tKGFyZ3MpLm1hcChhcmcgPT4ge1xuICAgIHN3aXRjaCAodHlwZW9mIGFyZykge1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiBuZXcgQm9vbGVhbihhcmcpO1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXIoYXJnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICB9KSA6IG51bGw7XG4gIGNvbnN0IHVwbG9hZGVkVmFsdWVzID0gW107XG4gIGNvbnN0IHBvc3RSZXN1bHQgPSBbXTtcbiAgY29uc3QgY29udGV4dCA9IGdsV2lyZXRhcChvcmlnaW5LZXJuZWwuY29udGV4dCwge1xuICAgIHVzZVRyYWNrYWJsZVByaW1pdGl2ZXM6IHRydWUsXG4gICAgb25SZWFkUGl4ZWxzOiAodGFyZ2V0TmFtZSkgPT4ge1xuICAgICAgaWYgKGtlcm5lbC5zdWJLZXJuZWxzKSB7XG4gICAgICAgIGlmICghc3ViS2VybmVsc1Jlc3VsdFZhcmlhYmxlU2V0dXApIHtcbiAgICAgICAgICBwb3N0UmVzdWx0LnB1c2goYCAgICBjb25zdCByZXN1bHQgPSB7IHJlc3VsdDogJHtnZXRSZW5kZXJTdHJpbmcodGFyZ2V0TmFtZSwga2VybmVsKX0gfTtgKTtcbiAgICAgICAgICBzdWJLZXJuZWxzUmVzdWx0VmFyaWFibGVTZXR1cCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBrZXJuZWwuc3ViS2VybmVsc1tzdWJLZXJuZWxzUmVzdWx0SW5kZXgrK10ucHJvcGVydHk7XG4gICAgICAgICAgcG9zdFJlc3VsdC5wdXNoKGAgICAgcmVzdWx0JHtpc05hTihwcm9wZXJ0eSkgPyAnLicgKyBwcm9wZXJ0eSA6IGBbJHtwcm9wZXJ0eX1dYH0gPSAke2dldFJlbmRlclN0cmluZyh0YXJnZXROYW1lLCBrZXJuZWwpfTtgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViS2VybmVsc1Jlc3VsdEluZGV4ID09PSBrZXJuZWwuc3ViS2VybmVscy5sZW5ndGgpIHtcbiAgICAgICAgICBwb3N0UmVzdWx0LnB1c2goJyAgICByZXR1cm4gcmVzdWx0OycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXROYW1lKSB7XG4gICAgICAgIHBvc3RSZXN1bHQucHVzaChgICAgIHJldHVybiAke2dldFJlbmRlclN0cmluZyh0YXJnZXROYW1lLCBrZXJuZWwpfTtgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvc3RSZXN1bHQucHVzaChgICAgIHJldHVybiBudWxsO2ApO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cDogKGFyZ3VtZW50KSA9PiB7XG4gICAgICBjb25zdCBhcmd1bWVudE5hbWUgPSBmaW5kS2VybmVsVmFsdWUoYXJndW1lbnQsIGtlcm5lbC5rZXJuZWxBcmd1bWVudHMsIFtdLCBjb250ZXh0LCB1cGxvYWRlZFZhbHVlcyk7XG4gICAgICBpZiAoYXJndW1lbnROYW1lKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudE5hbWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25zdGFudE5hbWUgPSBmaW5kS2VybmVsVmFsdWUoYXJndW1lbnQsIGtlcm5lbC5rZXJuZWxDb25zdGFudHMsIGNvbnN0YW50cyA/IE9iamVjdC5rZXlzKGNvbnN0YW50cykubWFwKGtleSA9PiBjb25zdGFudHNba2V5XSkgOiBbXSwgY29udGV4dCwgdXBsb2FkZWRWYWx1ZXMpO1xuICAgICAgaWYgKGNvbnN0YW50TmFtZSkge1xuICAgICAgICByZXR1cm4gY29uc3RhbnROYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9KTtcbiAgbGV0IHN1Yktlcm5lbHNSZXN1bHRWYXJpYWJsZVNldHVwID0gZmFsc2U7XG4gIGxldCBzdWJLZXJuZWxzUmVzdWx0SW5kZXggPSAwO1xuICBjb25zdCB7XG4gICAgc291cmNlLFxuICAgIGNhbnZhcyxcbiAgICBvdXRwdXQsXG4gICAgcGlwZWxpbmUsXG4gICAgZ3JhcGhpY2FsLFxuICAgIGxvb3BNYXhJdGVyYXRpb25zLFxuICAgIGNvbnN0YW50cyxcbiAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgIHByZWNpc2lvbixcbiAgICBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSxcbiAgICBmdW5jdGlvbnMsXG4gICAgbmF0aXZlRnVuY3Rpb25zLFxuICAgIHN1Yktlcm5lbHMsXG4gICAgaW1tdXRhYmxlLFxuICAgIGFyZ3VtZW50VHlwZXMsXG4gICAgY29uc3RhbnRUeXBlcyxcbiAgICBrZXJuZWxBcmd1bWVudHMsXG4gICAga2VybmVsQ29uc3RhbnRzLFxuICAgIHRhY3RpYyxcbiAgfSA9IG9yaWdpbktlcm5lbDtcbiAgY29uc3Qga2VybmVsID0gbmV3IEtlcm5lbChzb3VyY2UsIHtcbiAgICBjYW52YXMsXG4gICAgY29udGV4dCxcbiAgICBjaGVja0NvbnRleHQ6IGZhbHNlLFxuICAgIG91dHB1dCxcbiAgICBwaXBlbGluZSxcbiAgICBncmFwaGljYWwsXG4gICAgbG9vcE1heEl0ZXJhdGlvbnMsXG4gICAgY29uc3RhbnRzLFxuICAgIG9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgcHJlY2lzaW9uLFxuICAgIGZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5LFxuICAgIGZ1bmN0aW9ucyxcbiAgICBuYXRpdmVGdW5jdGlvbnMsXG4gICAgc3ViS2VybmVscyxcbiAgICBpbW11dGFibGUsXG4gICAgYXJndW1lbnRUeXBlcyxcbiAgICBjb25zdGFudFR5cGVzLFxuICAgIHRhY3RpYyxcbiAgfSk7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgY29udGV4dC5zZXRJbmRlbnQoMik7XG4gIGtlcm5lbC5idWlsZC5hcHBseShrZXJuZWwsIGFyZ3MpO1xuICByZXN1bHQucHVzaChjb250ZXh0LnRvU3RyaW5nKCkpO1xuICBjb250ZXh0LnJlc2V0KCk7XG5cbiAga2VybmVsLmtlcm5lbEFyZ3VtZW50cy5mb3JFYWNoKChrZXJuZWxBcmd1bWVudCwgaSkgPT4ge1xuICAgIHN3aXRjaCAoa2VybmVsQXJndW1lbnQudHlwZSkge1xuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICBjYXNlICdBcnJheSc6XG4gICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICBjYXNlICdIVE1MQ2FudmFzJzpcbiAgICAgIGNhc2UgJ0hUTUxJbWFnZSc6XG4gICAgICBjYXNlICdIVE1MVmlkZW8nOlxuICAgICAgICBjb250ZXh0Lmluc2VydFZhcmlhYmxlKGB1cGxvYWRWYWx1ZV8ke2tlcm5lbEFyZ3VtZW50Lm5hbWV9YCwga2VybmVsQXJndW1lbnQudXBsb2FkVmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0hUTUxJbWFnZUFycmF5JzpcbiAgICAgICAgZm9yIChsZXQgaW1hZ2VJbmRleCA9IDA7IGltYWdlSW5kZXggPCBhcmdzW2ldLmxlbmd0aDsgaW1hZ2VJbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICBjb250ZXh0Lmluc2VydFZhcmlhYmxlKGB1cGxvYWRWYWx1ZV8ke2tlcm5lbEFyZ3VtZW50Lm5hbWV9WyR7aW1hZ2VJbmRleH1dYCwgYXJnW2ltYWdlSW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0lucHV0JzpcbiAgICAgICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZShgdXBsb2FkVmFsdWVfJHtrZXJuZWxBcmd1bWVudC5uYW1lfWAsIGtlcm5lbEFyZ3VtZW50LnVwbG9hZFZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzpcbiAgICAgIGNhc2UgJ051bWJlclRleHR1cmUnOlxuICAgICAgY2FzZSAnQXJyYXkxRCgyKSc6XG4gICAgICBjYXNlICdBcnJheTFEKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5MUQoNCknOlxuICAgICAgY2FzZSAnQXJyYXkyRCgyKSc6XG4gICAgICBjYXNlICdBcnJheTJEKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5MkQoNCknOlxuICAgICAgY2FzZSAnQXJyYXkzRCgyKSc6XG4gICAgICBjYXNlICdBcnJheTNEKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5M0QoNCknOlxuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoMyknOlxuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcbiAgICAgICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZShgdXBsb2FkVmFsdWVfJHtrZXJuZWxBcmd1bWVudC5uYW1lfWAsIGFyZ3NbaV0udGV4dHVyZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQga2VybmVsQXJndW1lbnRUeXBlIGluc2VydGlvbiBmb3IgZ2xXaXJldGFwIG9mIHR5cGUgJHtrZXJuZWxBcmd1bWVudC50eXBlfWApO1xuICAgIH1cbiAgfSk7XG4gIHJlc3VsdC5wdXNoKCcvKiogc3RhcnQgb2YgaW5qZWN0ZWQgZnVuY3Rpb25zICoqLycpO1xuICByZXN1bHQucHVzaChgZnVuY3Rpb24gJHt0b1N0cmluZ1dpdGhvdXRVdGlscyh1dGlscy5mbGF0dGVuVG8pfWApO1xuICByZXN1bHQucHVzaChgZnVuY3Rpb24gJHt0b1N0cmluZ1dpdGhvdXRVdGlscyh1dGlscy5mbGF0dGVuMmRBcnJheVRvKX1gKTtcbiAgcmVzdWx0LnB1c2goYGZ1bmN0aW9uICR7dG9TdHJpbmdXaXRob3V0VXRpbHModXRpbHMuZmxhdHRlbjNkQXJyYXlUbyl9YCk7XG4gIHJlc3VsdC5wdXNoKGBmdW5jdGlvbiAke3RvU3RyaW5nV2l0aG91dFV0aWxzKHV0aWxzLmZsYXR0ZW40ZEFycmF5VG8pfWApO1xuICByZXN1bHQucHVzaChgZnVuY3Rpb24gJHt0b1N0cmluZ1dpdGhvdXRVdGlscyh1dGlscy5pc0FycmF5KX1gKTtcbiAgaWYgKGtlcm5lbC5yZW5kZXJPdXRwdXQgIT09IGtlcm5lbC5yZW5kZXJUZXh0dXJlICYmIGtlcm5lbC5mb3JtYXRWYWx1ZXMpIHtcbiAgICByZXN1bHQucHVzaChcbiAgICAgIGAgIGNvbnN0IHJlbmRlck91dHB1dCA9IGZ1bmN0aW9uICR7dG9TdHJpbmdXaXRob3V0VXRpbHMoa2VybmVsLmZvcm1hdFZhbHVlcyl9O2BcbiAgICApO1xuICB9XG4gIHJlc3VsdC5wdXNoKCcvKiogZW5kIG9mIGluamVjdGVkIGZ1bmN0aW9ucyAqKi8nKTtcbiAgcmVzdWx0LnB1c2goYCAgY29uc3QgaW5uZXJLZXJuZWwgPSBmdW5jdGlvbiAoJHtrZXJuZWwua2VybmVsQXJndW1lbnRzLm1hcChrZXJuZWxBcmd1bWVudCA9PiBrZXJuZWxBcmd1bWVudC52YXJOYW1lKS5qb2luKCcsICcpfSkge2ApO1xuICBjb250ZXh0LnNldEluZGVudCg0KTtcbiAga2VybmVsLnJ1bi5hcHBseShrZXJuZWwsIGFyZ3MpO1xuICBpZiAoa2VybmVsLnJlbmRlcktlcm5lbHMpIHtcbiAgICBrZXJuZWwucmVuZGVyS2VybmVscygpO1xuICB9IGVsc2UgaWYgKGtlcm5lbC5yZW5kZXJPdXRwdXQpIHtcbiAgICBrZXJuZWwucmVuZGVyT3V0cHV0KCk7XG4gIH1cbiAgcmVzdWx0LnB1c2goJyAgICAvKiogc3RhcnQgc2V0dXAgdXBsb2FkcyBmb3Iga2VybmVsIHZhbHVlcyAqKi8nKTtcbiAga2VybmVsLmtlcm5lbEFyZ3VtZW50cy5mb3JFYWNoKGtlcm5lbEFyZ3VtZW50ID0+IHtcbiAgICByZXN1bHQucHVzaCgnICAgICcgKyBrZXJuZWxBcmd1bWVudC5nZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKS5zcGxpdCgnXFxuJykuam9pbignXFxuICAgICcpKTtcbiAgfSk7XG4gIHJlc3VsdC5wdXNoKCcgICAgLyoqIGVuZCBzZXR1cCB1cGxvYWRzIGZvciBrZXJuZWwgdmFsdWVzICoqLycpO1xuICByZXN1bHQucHVzaChjb250ZXh0LnRvU3RyaW5nKCkpO1xuICBpZiAoa2VybmVsLnJlbmRlck91dHB1dCA9PT0ga2VybmVsLnJlbmRlclRleHR1cmUpIHtcbiAgICBjb250ZXh0LnJlc2V0KCk7XG4gICAgY29uc3QgZnJhbWVidWZmZXJOYW1lID0gY29udGV4dC5nZXRDb250ZXh0VmFyaWFibGVOYW1lKGtlcm5lbC5mcmFtZWJ1ZmZlcik7XG4gICAgaWYgKGtlcm5lbC5yZW5kZXJLZXJuZWxzKSB7XG4gICAgICBjb25zdCByZXN1bHRzID0ga2VybmVsLnJlbmRlcktlcm5lbHMoKTtcbiAgICAgIGNvbnN0IHRleHR1cmVOYW1lID0gY29udGV4dC5nZXRDb250ZXh0VmFyaWFibGVOYW1lKGtlcm5lbC50ZXh0dXJlLnRleHR1cmUpO1xuICAgICAgcmVzdWx0LnB1c2goYCAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiB7XG4gICAgICAgIHRleHR1cmU6ICR7IHRleHR1cmVOYW1lIH0sXG4gICAgICAgIHR5cGU6ICckeyByZXN1bHRzLnJlc3VsdC50eXBlIH0nLFxuICAgICAgICB0b0FycmF5OiAkeyBnZXRUb0FycmF5U3RyaW5nKHJlc3VsdHMucmVzdWx0LCB0ZXh0dXJlTmFtZSwgZnJhbWVidWZmZXJOYW1lKSB9XG4gICAgICB9LGApO1xuICAgICAgY29uc3QgeyBzdWJLZXJuZWxzLCBtYXBwZWRUZXh0dXJlcyB9ID0ga2VybmVsO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBtYXBwZWRUZXh0dXJlc1tpXTtcbiAgICAgICAgY29uc3Qgc3ViS2VybmVsID0gc3ViS2VybmVsc1tpXTtcbiAgICAgICAgY29uc3Qgc3ViS2VybmVsUmVzdWx0ID0gcmVzdWx0c1tzdWJLZXJuZWwucHJvcGVydHldO1xuICAgICAgICBjb25zdCBzdWJLZXJuZWxUZXh0dXJlTmFtZSA9IGNvbnRleHQuZ2V0Q29udGV4dFZhcmlhYmxlTmFtZSh0ZXh0dXJlLnRleHR1cmUpO1xuICAgICAgICByZXN1bHQucHVzaChgXG4gICAgICAke3N1Yktlcm5lbC5wcm9wZXJ0eX06IHtcbiAgICAgICAgdGV4dHVyZTogJHsgc3ViS2VybmVsVGV4dHVyZU5hbWUgfSxcbiAgICAgICAgdHlwZTogJyR7IHN1Yktlcm5lbFJlc3VsdC50eXBlIH0nLFxuICAgICAgICB0b0FycmF5OiAkeyBnZXRUb0FycmF5U3RyaW5nKHN1Yktlcm5lbFJlc3VsdCwgc3ViS2VybmVsVGV4dHVyZU5hbWUsIGZyYW1lYnVmZmVyTmFtZSkgfVxuICAgICAgfSxgKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGAgICAgfTtgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVuZGVyZWQgPSBrZXJuZWwucmVuZGVyT3V0cHV0KCk7XG4gICAgICBjb25zdCB0ZXh0dXJlTmFtZSA9IGNvbnRleHQuZ2V0Q29udGV4dFZhcmlhYmxlTmFtZShrZXJuZWwudGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgIHJlc3VsdC5wdXNoKGAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dHVyZTogJHsgdGV4dHVyZU5hbWUgfSxcbiAgICAgICAgdHlwZTogJyR7IHJlbmRlcmVkLnR5cGUgfScsXG4gICAgICAgIHRvQXJyYXk6ICR7IGdldFRvQXJyYXlTdHJpbmcocmVuZGVyZWQsIHRleHR1cmVOYW1lLCBmcmFtZWJ1ZmZlck5hbWUpIH1cbiAgICAgIH07YCk7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5wdXNoKGAgICAgJHtkZXN0cm95Q29udGV4dFN0cmluZyA/ICdcXG4nICsgZGVzdHJveUNvbnRleHRTdHJpbmcgKyAnICAgICc6ICcnfWApO1xuICByZXN1bHQucHVzaChwb3N0UmVzdWx0LmpvaW4oJ1xcbicpKTtcbiAgcmVzdWx0LnB1c2goJyAgfTsnKTtcbiAgaWYgKGtlcm5lbC5ncmFwaGljYWwpIHtcbiAgICByZXN1bHQucHVzaChnZXRHZXRQaXhlbHNTdHJpbmcoa2VybmVsKSk7XG4gICAgcmVzdWx0LnB1c2goYCAgaW5uZXJLZXJuZWwuZ2V0UGl4ZWxzID0gZ2V0UGl4ZWxzO2ApO1xuICB9XG4gIHJlc3VsdC5wdXNoKCcgIHJldHVybiBpbm5lcktlcm5lbDsnKTtcblxuICBsZXQgY29uc3RhbnRzVXBsb2FkID0gW107XG4gIGtlcm5lbENvbnN0YW50cy5mb3JFYWNoKChrZXJuZWxDb25zdGFudCkgPT4ge1xuICAgIGNvbnN0YW50c1VwbG9hZC5wdXNoKGAke2tlcm5lbENvbnN0YW50LmdldFN0cmluZ1ZhbHVlSGFuZGxlcigpfWApO1xuICB9KTtcbiAgcmV0dXJuIGBmdW5jdGlvbiBrZXJuZWwoc2V0dGluZ3MpIHtcbiAgY29uc3QgeyBjb250ZXh0LCBjb25zdGFudHMgfSA9IHNldHRpbmdzO1xuICAke2NvbnN0YW50c1VwbG9hZC5qb2luKCcnKX1cbiAgJHtzZXR1cENvbnRleHRTdHJpbmcgPyBzZXR1cENvbnRleHRTdHJpbmcgOiAnJ31cbiR7cmVzdWx0LmpvaW4oJ1xcbicpfVxufWA7XG59XG5cbmZ1bmN0aW9uIGdldFJlbmRlclN0cmluZyh0YXJnZXROYW1lLCBrZXJuZWwpIHtcbiAgY29uc3QgcmVhZEJhY2tWYWx1ZSA9IGtlcm5lbC5wcmVjaXNpb24gPT09ICdzaW5nbGUnID8gdGFyZ2V0TmFtZSA6IGBuZXcgRmxvYXQzMkFycmF5KCR7dGFyZ2V0TmFtZX0uYnVmZmVyKWA7XG4gIGlmIChrZXJuZWwub3V0cHV0WzJdKSB7XG4gICAgcmV0dXJuIGByZW5kZXJPdXRwdXQoJHtyZWFkQmFja1ZhbHVlfSwgJHtrZXJuZWwub3V0cHV0WzBdfSwgJHtrZXJuZWwub3V0cHV0WzFdfSwgJHtrZXJuZWwub3V0cHV0WzJdfSlgO1xuICB9XG4gIGlmIChrZXJuZWwub3V0cHV0WzFdKSB7XG4gICAgcmV0dXJuIGByZW5kZXJPdXRwdXQoJHtyZWFkQmFja1ZhbHVlfSwgJHtrZXJuZWwub3V0cHV0WzBdfSwgJHtrZXJuZWwub3V0cHV0WzFdfSlgO1xuICB9XG5cbiAgcmV0dXJuIGByZW5kZXJPdXRwdXQoJHtyZWFkQmFja1ZhbHVlfSwgJHtrZXJuZWwub3V0cHV0WzBdfSlgO1xufVxuXG5mdW5jdGlvbiBnZXRHZXRQaXhlbHNTdHJpbmcoa2VybmVsKSB7XG4gIGNvbnN0IGdldFBpeGVscyA9IGtlcm5lbC5nZXRQaXhlbHMudG9TdHJpbmcoKTtcbiAgY29uc3QgdXNlRnVuY3Rpb25LZXl3b3JkID0gIS9eZnVuY3Rpb24vLnRlc3QoZ2V0UGl4ZWxzKTtcbiAgcmV0dXJuIHV0aWxzLmZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nKGAke3VzZUZ1bmN0aW9uS2V5d29yZCA/ICdmdW5jdGlvbiAnIDogJyd9JHsgZ2V0UGl4ZWxzIH1gLCB7XG4gICAgZmluZERlcGVuZGVuY3k6IChvYmplY3QsIG5hbWUpID0+IHtcbiAgICAgIGlmIChvYmplY3QgPT09ICd1dGlscycpIHtcbiAgICAgICAgcmV0dXJuIGBjb25zdCAke25hbWV9ID0gJHt1dGlsc1tuYW1lXS50b1N0cmluZygpfTtgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICB0aGlzTG9va3VwOiAocHJvcGVydHkpID0+IHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2NvbnRleHQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGtlcm5lbC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtlcm5lbFtwcm9wZXJ0eV0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgdGhpc0xvb2t1cCAkeyBwcm9wZXJ0eSB9YCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9BcnJheVN0cmluZyhrZXJuZWxSZXN1bHQsIHRleHR1cmVOYW1lLCBmcmFtZWJ1ZmZlck5hbWUpIHtcbiAgY29uc3QgdG9BcnJheSA9IGtlcm5lbFJlc3VsdC50b0FycmF5LnRvU3RyaW5nKCk7XG4gIGNvbnN0IHVzZUZ1bmN0aW9uS2V5d29yZCA9ICEvXmZ1bmN0aW9uLy50ZXN0KHRvQXJyYXkpO1xuICBjb25zdCBmbGF0dGVuZWRGdW5jdGlvbnMgPSB1dGlscy5mbGF0dGVuRnVuY3Rpb25Ub1N0cmluZyhgJHt1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnfSR7IHRvQXJyYXkgfWAsIHtcbiAgICBmaW5kRGVwZW5kZW5jeTogKG9iamVjdCwgbmFtZSkgPT4ge1xuICAgICAgaWYgKG9iamVjdCA9PT0gJ3V0aWxzJykge1xuICAgICAgICByZXR1cm4gYGNvbnN0ICR7bmFtZX0gPSAke3V0aWxzW25hbWVdLnRvU3RyaW5nKCl9O2A7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdCA9PT0gJ3RoaXMnKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnZnJhbWVidWZmZXInKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnfSR7a2VybmVsUmVzdWx0W25hbWVdLnRvU3RyaW5nKCl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5oYW5kbGVkIGZyb21PYmplY3QnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRoaXNMb29rdXA6IChwcm9wZXJ0eSwgaXNEZWNsYXJhdGlvbikgPT4ge1xuICAgICAgaWYgKHByb3BlcnR5ID09PSAndGV4dHVyZScpIHtcbiAgICAgICAgcmV0dXJuIHRleHR1cmVOYW1lO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BlcnR5ID09PSAnY29udGV4dCcpIHtcbiAgICAgICAgaWYgKGlzRGVjbGFyYXRpb24pIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gJ2dsJztcbiAgICAgIH1cbiAgICAgIGlmIChrZXJuZWxSZXN1bHQuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXJuZWxSZXN1bHRbcHJvcGVydHldKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHRoaXNMb29rdXAgJHsgcHJvcGVydHkgfWApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBgKCkgPT4ge1xuICBmdW5jdGlvbiBmcmFtZWJ1ZmZlcigpIHsgcmV0dXJuICR7ZnJhbWVidWZmZXJOYW1lfTsgfTtcbiAgJHtmbGF0dGVuZWRGdW5jdGlvbnN9XG4gIHJldHVybiB0b0FycmF5KCk7XG4gIH1gO1xufVxuXG5mdW5jdGlvbiBmaW5kS2VybmVsVmFsdWUoYXJndW1lbnQsIGtlcm5lbFZhbHVlcywgdmFsdWVzLCBjb250ZXh0LCB1cGxvYWRlZFZhbHVlcykge1xuICBpZiAoYXJndW1lbnQgPT09IG51bGwpIHJldHVybiBudWxsO1xuICBpZiAoa2VybmVsVmFsdWVzID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgc3dpdGNoICh0eXBlb2YgYXJndW1lbnQpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKFxuICAgIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIGFyZ3VtZW50IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudFxuICApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2VybmVsVmFsdWUgPSBrZXJuZWxWYWx1ZXNbaV07XG4gICAgICBpZiAoa2VybmVsVmFsdWUudHlwZSAhPT0gJ0hUTUxJbWFnZUFycmF5JyAmJiBrZXJuZWxWYWx1ZSkgY29udGludWU7XG4gICAgICBpZiAoa2VybmVsVmFsdWUudXBsb2FkVmFsdWUgIT09IGFyZ3VtZW50KSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlSW5kZXggPSB2YWx1ZXNbaV0uaW5kZXhPZihhcmd1bWVudCk7XG4gICAgICBpZiAodmFyaWFibGVJbmRleCA9PT0gLTEpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gYHVwbG9hZFZhbHVlXyR7a2VybmVsVmFsdWUubmFtZX1bJHt2YXJpYWJsZUluZGV4fV1gO1xuICAgICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZSh2YXJpYWJsZU5hbWUsIGFyZ3VtZW50KTtcbiAgICAgIHJldHVybiB2YXJpYWJsZU5hbWU7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXJuZWxWYWx1ZSA9IGtlcm5lbFZhbHVlc1tpXTtcbiAgICBpZiAoYXJndW1lbnQgIT09IGtlcm5lbFZhbHVlLnVwbG9hZFZhbHVlKSBjb250aW51ZTtcbiAgICBjb25zdCB2YXJpYWJsZSA9IGB1cGxvYWRWYWx1ZV8ke2tlcm5lbFZhbHVlLm5hbWV9YDtcbiAgICBjb250ZXh0Lmluc2VydFZhcmlhYmxlKHZhcmlhYmxlLCBrZXJuZWxWYWx1ZSk7XG4gICAgcmV0dXJuIHZhcmlhYmxlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2xLZXJuZWxTdHJpbmdcbn07XG59LHtcIi4uLy4uL3V0aWxzXCI6MTE0LFwiZ2wtd2lyZXRhcFwiOjN9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IEtlcm5lbCB9ID0gcmVxdWlyZSgnLi4va2VybmVsJyk7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTJGbG9hdCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTItZmxvYXQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXkyRmxvYXQyRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTItZmxvYXQtMmQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXkyRmxvYXQzRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTItZmxvYXQtM2QnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXkzRmxvYXQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS0zLWZsb2F0Jyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5M0Zsb2F0MkQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS0zLWZsb2F0LTJkJyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5M0Zsb2F0M0QgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS0zLWZsb2F0LTNkJyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5NEZsb2F0IH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktNC1mbG9hdCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTRGbG9hdDJEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktNC1mbG9hdC0yZCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTRGbG9hdDNEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktNC1mbG9hdC0zZCcpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2Zsb2F0Jyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0MkQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9mbG9hdC0yZCcpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdDNEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvZmxvYXQtM2QnKTtcbmNvbnN0IHsgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvbWVtb3J5LW9wdGltaXplZCcpO1xuY29uc3QgeyBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQyRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL21lbW9yeS1vcHRpbWl6ZWQtMmQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkM0QgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9tZW1vcnktb3B0aW1pemVkLTNkJyk7XG5jb25zdCB7IEdMVGV4dHVyZVVuc2lnbmVkIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvdW5zaWduZWQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlVW5zaWduZWQyRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL3Vuc2lnbmVkLTJkJyk7XG5jb25zdCB7IEdMVGV4dHVyZVVuc2lnbmVkM0QgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS91bnNpZ25lZC0zZCcpO1xuY29uc3QgeyBHTFRleHR1cmVHcmFwaGljYWwgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9ncmFwaGljYWwnKTtcblxuY2xhc3MgR0xLZXJuZWwgZXh0ZW5kcyBLZXJuZWwge1xuICBzdGF0aWMgZ2V0IG1vZGUoKSB7XG4gICAgcmV0dXJuICdncHUnO1xuICB9XG5cbiAgc3RhdGljIGdldElzRmxvYXRSZWFkKCkge1xuICAgIGNvbnN0IGtlcm5lbFN0cmluZyA9IGBmdW5jdGlvbiBrZXJuZWxGdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1gO1xuICAgIGNvbnN0IGtlcm5lbCA9IG5ldyB0aGlzKGtlcm5lbFN0cmluZywge1xuICAgICAgY29udGV4dDogdGhpcy50ZXN0Q29udGV4dCxcbiAgICAgIGNhbnZhczogdGhpcy50ZXN0Q2FudmFzLFxuICAgICAgdmFsaWRhdGU6IGZhbHNlLFxuICAgICAgb3V0cHV0OiBbMV0sXG4gICAgICBwcmVjaXNpb246ICdzaW5nbGUnLFxuICAgICAgcmV0dXJuVHlwZTogJ051bWJlcicsXG4gICAgICB0YWN0aWM6ICdzcGVlZCcsXG4gICAgfSk7XG4gICAga2VybmVsLmJ1aWxkKCk7XG4gICAga2VybmVsLnJ1bigpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbC5yZW5kZXJPdXRwdXQoKTtcbiAgICBrZXJuZWwuZGVzdHJveSh0cnVlKTtcbiAgICByZXR1cm4gcmVzdWx0WzBdID09PSAxO1xuICB9XG5cbiAgc3RhdGljIGdldElzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUoKSB7XG4gICAgZnVuY3Rpb24ga2VybmVsRnVuY3Rpb24odjEsIHYyKSB7XG4gICAgICByZXR1cm4gdjFbdGhpcy50aHJlYWQueF0gLyB2Mlt0aGlzLnRocmVhZC54XTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsID0gbmV3IHRoaXMoa2VybmVsRnVuY3Rpb24udG9TdHJpbmcoKSwge1xuICAgICAgY29udGV4dDogdGhpcy50ZXN0Q29udGV4dCxcbiAgICAgIGNhbnZhczogdGhpcy50ZXN0Q2FudmFzLFxuICAgICAgdmFsaWRhdGU6IGZhbHNlLFxuICAgICAgb3V0cHV0OiBbMl0sXG4gICAgICByZXR1cm5UeXBlOiAnTnVtYmVyJyxcbiAgICAgIHByZWNpc2lvbjogJ3Vuc2lnbmVkJyxcbiAgICAgIHRhY3RpYzogJ3NwZWVkJyxcbiAgICB9KTtcbiAgICBjb25zdCBhcmdzID0gW1xuICAgICAgWzYsIDYwMzA0MDFdLFxuICAgICAgWzMsIDM5OTFdXG4gICAgXTtcbiAgICBrZXJuZWwuYnVpbGQuYXBwbHkoa2VybmVsLCBhcmdzKTtcbiAgICBrZXJuZWwucnVuLmFwcGx5KGtlcm5lbCwgYXJncyk7XG4gICAgY29uc3QgcmVzdWx0ID0ga2VybmVsLnJlbmRlck91dHB1dCgpO1xuICAgIGtlcm5lbC5kZXN0cm95KHRydWUpO1xuICAgIHJldHVybiByZXN1bHRbMF0gPT09IDIgJiYgcmVzdWx0WzFdID09PSAxNTExO1xuICB9XG5cbiAgc3RhdGljIGdldElzU3BlZWRUYWN0aWNTdXBwb3J0ZWQoKSB7XG4gICAgZnVuY3Rpb24ga2VybmVsRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVt0aGlzLnRocmVhZC54XTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsID0gbmV3IHRoaXMoa2VybmVsRnVuY3Rpb24udG9TdHJpbmcoKSwge1xuICAgICAgY29udGV4dDogdGhpcy50ZXN0Q29udGV4dCxcbiAgICAgIGNhbnZhczogdGhpcy50ZXN0Q2FudmFzLFxuICAgICAgdmFsaWRhdGU6IGZhbHNlLFxuICAgICAgb3V0cHV0OiBbNF0sXG4gICAgICByZXR1cm5UeXBlOiAnTnVtYmVyJyxcbiAgICAgIHByZWNpc2lvbjogJ3Vuc2lnbmVkJyxcbiAgICAgIHRhY3RpYzogJ3NwZWVkJyxcbiAgICB9KTtcbiAgICBjb25zdCBhcmdzID0gW1xuICAgICAgWzAsIDEsIDIsIDNdXG4gICAgXTtcbiAgICBrZXJuZWwuYnVpbGQuYXBwbHkoa2VybmVsLCBhcmdzKTtcbiAgICBrZXJuZWwucnVuLmFwcGx5KGtlcm5lbCwgYXJncyk7XG4gICAgY29uc3QgcmVzdWx0ID0ga2VybmVsLnJlbmRlck91dHB1dCgpO1xuICAgIGtlcm5lbC5kZXN0cm95KHRydWUpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHJlc3VsdFswXSkgPT09IDAgJiYgTWF0aC5yb3VuZChyZXN1bHRbMV0pID09PSAxICYmIE1hdGgucm91bmQocmVzdWx0WzJdKSA9PT0gMiAmJiBNYXRoLnJvdW5kKHJlc3VsdFszXSkgPT09IDM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDYW52YXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInRlc3RDYW52YXNcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q29udGV4dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwidGVzdENvbnRleHRcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgc3RhdGljIGdldEZlYXR1cmVzKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy50ZXN0Q29udGV4dDtcbiAgICBjb25zdCBpc0RyYXdCdWZmZXJzID0gdGhpcy5nZXRJc0RyYXdCdWZmZXJzKCk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgaXNGbG9hdFJlYWQ6IHRoaXMuZ2V0SXNGbG9hdFJlYWQoKSxcbiAgICAgIGlzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGU6IHRoaXMuZ2V0SXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZSgpLFxuICAgICAgaXNTcGVlZFRhY3RpY1N1cHBvcnRlZDogdGhpcy5nZXRJc1NwZWVkVGFjdGljU3VwcG9ydGVkKCksXG4gICAgICBpc1RleHR1cmVGbG9hdDogdGhpcy5nZXRJc1RleHR1cmVGbG9hdCgpLFxuICAgICAgaXNEcmF3QnVmZmVycyxcbiAgICAgIGtlcm5lbE1hcDogaXNEcmF3QnVmZmVycyxcbiAgICAgIGNoYW5uZWxDb3VudDogdGhpcy5nZXRDaGFubmVsQ291bnQoKSxcbiAgICAgIG1heFRleHR1cmVTaXplOiB0aGlzLmdldE1heFRleHR1cmVTaXplKCksXG4gICAgICBsb3dJbnRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkxPV19JTlQpLFxuICAgICAgbG93RmxvYXRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkxPV19GTE9BVCksXG4gICAgICBtZWRpdW1JbnRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9JTlQpLFxuICAgICAgbWVkaXVtRmxvYXRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCksXG4gICAgICBoaWdoSW50UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0lOVCksXG4gICAgICBoaWdoRmxvYXRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpLFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIHNldHVwRmVhdHVyZUNoZWNrcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwic2V0dXBGZWF0dXJlQ2hlY2tzXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRTaWduYXR1cmUoa2VybmVsLCBhcmd1bWVudFR5cGVzKSB7XG4gICAgcmV0dXJuIGtlcm5lbC5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpICsgKGFyZ3VtZW50VHlwZXMubGVuZ3RoID4gMCA/ICc6JyArIGFyZ3VtZW50VHlwZXMuam9pbignLCcpIDogJycpO1xuICB9XG5cbiAgc2V0Rml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3koZml4KSB7XG4gICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IGZpeDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFByZWNpc2lvbihmbGFnKSB7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RmxvYXRUZXh0dXJlcyhmbGFnKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdzZXRGbG9hdFRleHR1cmVzJywgJ3NldE9wdGltaXplRmxvYXRNZW1vcnknKTtcbiAgICB0aGlzLmZsb2F0VGV4dHVyZXMgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RhdGljIG5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKHNvdXJjZSkge1xuICAgIGNvbnN0IGFyZ3VtZW50VHlwZXMgPSBbXTtcbiAgICBjb25zdCBhcmd1bWVudE5hbWVzID0gW107XG4gICAgY29uc3Qgc3RhdGVzID0gW107XG4gICAgY29uc3QgaXNTdGFydGluZ1ZhcmlhYmxlTmFtZSA9IC9eW2EtekEtWl9dLztcbiAgICBjb25zdCBpc1ZhcmlhYmxlQ2hhciA9IC9bYS16QS1aXzAtOV0vO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgYXJndW1lbnROYW1lID0gbnVsbDtcbiAgICBsZXQgYXJndW1lbnRUeXBlID0gbnVsbDtcbiAgICB3aGlsZSAoaSA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBzb3VyY2VbaV07XG4gICAgICBjb25zdCBuZXh0Q2hhciA9IHNvdXJjZVtpICsgMV07XG4gICAgICBjb25zdCBzdGF0ZSA9IHN0YXRlcy5sZW5ndGggPiAwID8gc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXSA6IG51bGw7XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gJ0ZVTkNUSU9OX0FSR1VNRU5UUycgJiYgY2hhciA9PT0gJy8nICYmIG5leHRDaGFyID09PSAnKicpIHtcbiAgICAgICAgc3RhdGVzLnB1c2goJ01VTFRJX0xJTkVfQ09NTUVOVCcpO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ01VTFRJX0xJTkVfQ09NTUVOVCcgJiYgY2hhciA9PT0gJyonICYmIG5leHRDaGFyID09PSAnLycpIHtcbiAgICAgICAgc3RhdGVzLnBvcCgpO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ0ZVTkNUSU9OX0FSR1VNRU5UUycgJiYgY2hhciA9PT0gJy8nICYmIG5leHRDaGFyID09PSAnLycpIHtcbiAgICAgICAgc3RhdGVzLnB1c2goJ0NPTU1FTlQnKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdDT01NRU5UJyAmJiBjaGFyID09PSAnXFxuJykge1xuICAgICAgICBzdGF0ZXMucG9wKCk7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGVsc2UgaWYgKHN0YXRlID09PSBudWxsICYmIGNoYXIgPT09ICcoJykge1xuICAgICAgICBzdGF0ZXMucHVzaCgnRlVOQ1RJT05fQVJHVU1FTlRTJyk7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnRlVOQ1RJT05fQVJHVU1FTlRTJykge1xuICAgICAgICBpZiAoY2hhciA9PT0gJyknKSB7XG4gICAgICAgICAgc3RhdGVzLnBvcCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSAnZicgJiYgbmV4dENoYXIgPT09ICdsJyAmJiBzb3VyY2VbaSArIDJdID09PSAnbycgJiYgc291cmNlW2kgKyAzXSA9PT0gJ2EnICYmIHNvdXJjZVtpICsgNF0gPT09ICd0JyAmJiBzb3VyY2VbaSArIDVdID09PSAnICcpIHtcbiAgICAgICAgICBzdGF0ZXMucHVzaCgnREVDTEFSRV9WQVJJQUJMRScpO1xuICAgICAgICAgIGFyZ3VtZW50VHlwZSA9ICdmbG9hdCc7XG4gICAgICAgICAgYXJndW1lbnROYW1lID0gJyc7XG4gICAgICAgICAgaSArPSA2O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdpJyAmJiBuZXh0Q2hhciA9PT0gJ24nICYmIHNvdXJjZVtpICsgMl0gPT09ICd0JyAmJiBzb3VyY2VbaSArIDNdID09PSAnICcpIHtcbiAgICAgICAgICBzdGF0ZXMucHVzaCgnREVDTEFSRV9WQVJJQUJMRScpO1xuICAgICAgICAgIGFyZ3VtZW50VHlwZSA9ICdpbnQnO1xuICAgICAgICAgIGFyZ3VtZW50TmFtZSA9ICcnO1xuICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAndicgJiYgbmV4dENoYXIgPT09ICdlJyAmJiBzb3VyY2VbaSArIDJdID09PSAnYycgJiYgc291cmNlW2kgKyAzXSA9PT0gJzInICYmIHNvdXJjZVtpICsgNF0gPT09ICcgJykge1xuICAgICAgICAgIHN0YXRlcy5wdXNoKCdERUNMQVJFX1ZBUklBQkxFJyk7XG4gICAgICAgICAgYXJndW1lbnRUeXBlID0gJ3ZlYzInO1xuICAgICAgICAgIGFyZ3VtZW50TmFtZSA9ICcnO1xuICAgICAgICAgIGkgKz0gNTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAndicgJiYgbmV4dENoYXIgPT09ICdlJyAmJiBzb3VyY2VbaSArIDJdID09PSAnYycgJiYgc291cmNlW2kgKyAzXSA9PT0gJzMnICYmIHNvdXJjZVtpICsgNF0gPT09ICcgJykge1xuICAgICAgICAgIHN0YXRlcy5wdXNoKCdERUNMQVJFX1ZBUklBQkxFJyk7XG4gICAgICAgICAgYXJndW1lbnRUeXBlID0gJ3ZlYzMnO1xuICAgICAgICAgIGFyZ3VtZW50TmFtZSA9ICcnO1xuICAgICAgICAgIGkgKz0gNTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAndicgJiYgbmV4dENoYXIgPT09ICdlJyAmJiBzb3VyY2VbaSArIDJdID09PSAnYycgJiYgc291cmNlW2kgKyAzXSA9PT0gJzQnICYmIHNvdXJjZVtpICsgNF0gPT09ICcgJykge1xuICAgICAgICAgIHN0YXRlcy5wdXNoKCdERUNMQVJFX1ZBUklBQkxFJyk7XG4gICAgICAgICAgYXJndW1lbnRUeXBlID0gJ3ZlYzQnO1xuICAgICAgICAgIGFyZ3VtZW50TmFtZSA9ICcnO1xuICAgICAgICAgIGkgKz0gNTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ0RFQ0xBUkVfVkFSSUFCTEUnKSB7XG4gICAgICAgIGlmIChhcmd1bWVudE5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgaWYgKGNoYXIgPT09ICcgJykge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNTdGFydGluZ1ZhcmlhYmxlTmFtZS50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhcmlhYmxlIG5hbWUgaXMgbm90IGV4cGVjdGVkIHN0cmluZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcmd1bWVudE5hbWUgKz0gY2hhcjtcbiAgICAgICAgaWYgKCFpc1ZhcmlhYmxlQ2hhci50ZXN0KG5leHRDaGFyKSkge1xuICAgICAgICAgIHN0YXRlcy5wb3AoKTtcbiAgICAgICAgICBhcmd1bWVudE5hbWVzLnB1c2goYXJndW1lbnROYW1lKTtcbiAgICAgICAgICBhcmd1bWVudFR5cGVzLnB1c2godHlwZU1hcFthcmd1bWVudFR5cGVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuICAgIGlmIChzdGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHTFNMIGZ1bmN0aW9uIHdhcyBub3QgcGFyc2FibGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGFyZ3VtZW50TmFtZXMsXG4gICAgICBhcmd1bWVudFR5cGVzLFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgbmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlKHNvdXJjZSkge1xuICAgIHJldHVybiB0eXBlTWFwW3NvdXJjZS5tYXRjaCgvaW50fGZsb2F0fHZlY1syLTRdLylbMF1dO1xuICB9XG5cbiAgc3RhdGljIGNvbWJpbmVLZXJuZWxzKGNvbWJpbmVkS2VybmVsLCBsYXN0S2VybmVsKSB7XG4gICAgY29tYmluZWRLZXJuZWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBjb25zdCB7XG4gICAgICB0ZXhTaXplLFxuICAgICAgY29udGV4dCxcbiAgICAgIHRocmVhZERpbVxuICAgIH0gPSBsYXN0S2VybmVsLnRleFNpemU7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAobGFzdEtlcm5lbC5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICBjb25zdCB3ID0gdGV4U2l6ZVswXTtcbiAgICAgIGNvbnN0IGggPSBNYXRoLmNlaWwodGV4U2l6ZVsxXSAvIDQpO1xuICAgICAgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheSh3ICogaCAqIDQgKiA0KTtcbiAgICAgIGNvbnRleHQucmVhZFBpeGVscygwLCAwLCB3LCBoICogNCwgY29udGV4dC5SR0JBLCBjb250ZXh0LkZMT0FULCByZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHRleFNpemVbMF0gKiB0ZXhTaXplWzFdICogNCk7XG4gICAgICBjb250ZXh0LnJlYWRQaXhlbHMoMCwgMCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgY29udGV4dC5SR0JBLCBjb250ZXh0LlVOU0lHTkVEX0JZVEUsIGJ5dGVzKTtcbiAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkoYnl0ZXMuYnVmZmVyKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSByZXN1bHQuc3ViYXJyYXkoMCwgdGhyZWFkRGltWzBdICogdGhyZWFkRGltWzFdICogdGhyZWFkRGltWzJdKTtcblxuICAgIGlmIChsYXN0S2VybmVsLm91dHB1dC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChsYXN0S2VybmVsLm91dHB1dC5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldHVybiB1dGlscy5zcGxpdEFycmF5KHJlc3VsdCwgbGFzdEtlcm5lbC5vdXRwdXRbMF0pO1xuICAgIH0gZWxzZSBpZiAobGFzdEtlcm5lbC5vdXRwdXQubGVuZ3RoID09PSAzKSB7XG4gICAgICBjb25zdCBjdWJlID0gdXRpbHMuc3BsaXRBcnJheShyZXN1bHQsIGxhc3RLZXJuZWwub3V0cHV0WzBdICogbGFzdEtlcm5lbC5vdXRwdXRbMV0pO1xuICAgICAgcmV0dXJuIGN1YmUubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnNwbGl0QXJyYXkoeCwgbGFzdEtlcm5lbC5vdXRwdXRbMF0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3Ioc291cmNlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHNvdXJjZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMudHJhbnNmZXJWYWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJPdXRwdXQgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyUmF3T3V0cHV0ID0gbnVsbDtcbiAgICB0aGlzLnRleFNpemUgPSBudWxsO1xuICAgIHRoaXMudHJhbnNsYXRlZFNvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5jb21waWxlZEZyYWdtZW50U2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLmNvbXBpbGVkVmVydGV4U2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLnN3aXRjaGluZ0tlcm5lbHMgPSBudWxsO1xuICAgIHRoaXMuX3RleHR1cmVTd2l0Y2hlZCA9IG51bGw7XG4gICAgdGhpcy5fbWFwcGVkVGV4dHVyZVN3aXRjaGVkID0gbnVsbDtcbiAgfVxuXG4gIGNoZWNrVGV4dHVyZVNpemUoKSB7XG4gICAgY29uc3QgeyBmZWF0dXJlcyB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBpZiAodGhpcy50ZXhTaXplWzBdID4gZmVhdHVyZXMubWF4VGV4dHVyZVNpemUgfHwgdGhpcy50ZXhTaXplWzFdID4gZmVhdHVyZXMubWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGV4dHVyZSBzaXplIFske3RoaXMudGV4U2l6ZVswXX0sJHt0aGlzLnRleFNpemVbMV19XSBnZW5lcmF0ZWQgYnkga2VybmVsIGlzIGxhcmdlciB0aGFuIHN1cHBvcnRlZCBzaXplIFske2ZlYXR1cmVzLm1heFRleHR1cmVTaXplfSwke2ZlYXR1cmVzLm1heFRleHR1cmVTaXplfV1gKTtcbiAgICB9XG4gIH1cblxuICB0cmFuc2xhdGVTb3VyY2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInRyYW5zbGF0ZVNvdXJjZVwiIG5vdCBkZWZpbmVkIG9uICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICB9XG5cbiAgcGlja1JlbmRlclN0cmF0ZWd5KGFyZ3MpIHtcbiAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgIHRoaXMucmVuZGVyUmF3T3V0cHV0ID0gdGhpcy5yZWFkUGFja2VkUGl4ZWxzVG9VaW50OEFycmF5O1xuICAgICAgdGhpcy50cmFuc2ZlclZhbHVlcyA9IChwaXhlbHMpID0+IHBpeGVscztcbiAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlR3JhcGhpY2FsO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3Vuc2lnbmVkJykge1xuICAgICAgdGhpcy5yZW5kZXJSYXdPdXRwdXQgPSB0aGlzLnJlYWRQYWNrZWRQaXhlbHNUb1VpbnQ4QXJyYXk7XG4gICAgICB0aGlzLnRyYW5zZmVyVmFsdWVzID0gdGhpcy5yZWFkUGFja2VkUGl4ZWxzVG9GbG9hdDMyQXJyYXk7XG4gICAgICBpZiAodGhpcy5waXBlbGluZSkge1xuICAgICAgICB0aGlzLnJlbmRlck91dHB1dCA9IHRoaXMucmVuZGVyVGV4dHVyZTtcbiAgICAgICAgaWYgKHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyS2VybmVscyA9IHRoaXMucmVuZGVyS2VybmVsc1RvVGV4dHVyZXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlVW5zaWduZWQzRDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZVVuc2lnbmVkMkQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVVbnNpZ25lZDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICAgICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RGYWxsYmFjayhhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyS2VybmVscyA9IHRoaXMucmVuZGVyS2VybmVsc1RvQXJyYXlzO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlclZhbHVlcztcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVVbnNpZ25lZDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RQYWNrZWRGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZVVuc2lnbmVkMkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyRFBhY2tlZEZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlVW5zaWduZWQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RQYWNrZWRGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICAgICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RGYWxsYmFjayhhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICB0aGlzLnJlbmRlclJhd091dHB1dCA9IHRoaXMucmVhZEZsb2F0UGl4ZWxzVG9GbG9hdDMyQXJyYXk7XG4gICAgICB0aGlzLnRyYW5zZmVyVmFsdWVzID0gdGhpcy5yZWFkRmxvYXRQaXhlbHNUb0Zsb2F0MzJBcnJheTtcbiAgICAgIGlmICh0aGlzLnBpcGVsaW5lKSB7XG4gICAgICAgIHRoaXMucmVuZGVyT3V0cHV0ID0gdGhpcy5yZW5kZXJUZXh0dXJlO1xuICAgICAgICBpZiAodGhpcy5zdWJLZXJuZWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJLZXJuZWxzID0gdGhpcy5yZW5kZXJLZXJuZWxzVG9UZXh0dXJlcztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQzRDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDJEO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVGbG9hdDNEO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlRmxvYXQyRDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUZsb2F0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDIpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0M0Q7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDJEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkyRmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSgzKSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTNGbG9hdDNEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQyRDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoNCknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQzRDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5NEZsb2F0MkQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlck91dHB1dCA9IHRoaXMucmVuZGVyVmFsdWVzO1xuICAgICAgaWYgKHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlbmRlcktlcm5lbHMgPSB0aGlzLnJlbmRlcktlcm5lbHNUb0FycmF5cztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZDNERmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQyRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZDJERmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWRGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDIpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0M0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QzREFycmF5MjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0MkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyREFycmF5MjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0O1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0QXJyYXkyO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMyknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNEQXJyYXkzO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQyRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDJEQXJyYXkzO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RBcnJheTM7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSg0KSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RBcnJheTQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRBcnJheTQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdEFycmF5NDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUZsb2F0M0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QzREZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlRmxvYXQyRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDJERmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVGbG9hdDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdEZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMiknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkyRmxvYXQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNEQXJyYXkyO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkyRmxvYXQyRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDJEQXJyYXkyO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkyRmxvYXQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RBcnJheTI7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSgzKSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTNGbG9hdDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RBcnJheTM7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTNGbG9hdDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRBcnJheTM7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTNGbG9hdDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdEFycmF5MztcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDQpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5NEZsb2F0M0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QzREFycmF5NDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5NEZsb2F0MkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyREFycmF5NDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5NEZsb2F0O1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0QXJyYXk0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcHJlY2lzaW9uIG9mIFwiJHt0aGlzLnByZWNpc2lvbn1cImApO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHJldHVybiB0eXBlIFwiJHt0aGlzLnJldHVyblR5cGV9XCJgKTtcbiAgfVxuXG4gIGdldEtlcm5lbFN0cmluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0VGV4dHVyZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0TnVtYmVyVGV4dHVyZSgpO1xuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0QXJyYXkyVGV4dHVyZSgpO1xuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0QXJyYXkzVGV4dHVyZSgpO1xuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0QXJyYXk0VGV4dHVyZSgpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcmV0dXJuVHlwZSB0eXBlICR7IHRoaXMucmV0dXJuVHlwZSB9YCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbE51bWJlclRleHR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxOdW1iZXJUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkyVGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5MlRleHR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTNUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkzVGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5NFRleHR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0R3JhcGhpY2FsKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0TWVtb3J5T3B0aW1pemVkRmxvYXRzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0UGFja2VkUGl4ZWxzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0R3JhcGhpY2FsKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIGlmICh0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdE1lbW9yeU9wdGltaXplZEZsb2F0cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdFRleHR1cmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdFBhY2tlZFBpeGVscygpO1xuICAgIH1cbiAgfVxuXG4gIGdldE1haW5SZXN1bHROdW1iZXJUZXh0dXJlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbE51bWJlclRleHR1cmUoKSkgK1xuICAgICAgdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRTdWJLZXJuZWxOdW1iZXJUZXh0dXJlKCkpO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEFycmF5MlRleHR1cmUoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0S2VybmVsQXJyYXkyVGV4dHVyZSgpKSArXG4gICAgICB1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5MlRleHR1cmUoKSk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0QXJyYXkzVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxBcnJheTNUZXh0dXJlKCkpICtcbiAgICAgIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkzVGV4dHVyZSgpKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRBcnJheTRUZXh0dXJlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5NFRleHR1cmUoKSkgK1xuICAgICAgdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTRUZXh0dXJlKCkpO1xuICB9XG5cbiAgZ2V0RmxvYXRUYWN0aWNEZWNsYXJhdGlvbigpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcodGhpcy50ZXhTaXplLCB0aGlzLnRhY3RpYyk7XG4gICAgcmV0dXJuIGBwcmVjaXNpb24gJHt2YXJpYWJsZVByZWNpc2lvbn0gZmxvYXQ7XFxuYDtcbiAgfVxuXG4gIGdldEludFRhY3RpY0RlY2xhcmF0aW9uKCkge1xuICAgIHJldHVybiBgcHJlY2lzaW9uICR7dGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZyh0aGlzLnRleFNpemUsIHRoaXMudGFjdGljLCB0cnVlKX0gaW50O1xcbmA7XG4gIH1cblxuICBnZXRTYW1wbGVyMkRUYWN0aWNEZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gYHByZWNpc2lvbiAke3RoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcodGhpcy50ZXhTaXplLCB0aGlzLnRhY3RpYyl9IHNhbXBsZXIyRDtcXG5gO1xuICB9XG5cbiAgZ2V0U2FtcGxlcjJEQXJyYXlUYWN0aWNEZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gYHByZWNpc2lvbiAke3RoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcodGhpcy50ZXhTaXplLCB0aGlzLnRhY3RpYyl9IHNhbXBsZXIyREFycmF5O1xcbmA7XG4gIH1cblxuICByZW5kZXJUZXh0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLmltbXV0YWJsZSA/IHRoaXMudGV4dHVyZS5jbG9uZSgpIDogdGhpcy50ZXh0dXJlO1xuICB9XG4gIHJlYWRQYWNrZWRQaXhlbHNUb1VpbnQ4QXJyYXkoKSB7XG4gICAgaWYgKHRoaXMucHJlY2lzaW9uICE9PSAndW5zaWduZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVzIHRoaXMucHJlY2lzaW9uIHRvIGJlIFwidW5zaWduZWRcIicpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRleFNpemUsXG4gICAgICBjb250ZXh0OiBnbFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRleFNpemVbMF0gKiB0ZXhTaXplWzFdICogNCk7XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZWFkUGFja2VkUGl4ZWxzVG9GbG9hdDMyQXJyYXkoKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5yZWFkUGFja2VkUGl4ZWxzVG9VaW50OEFycmF5KCkuYnVmZmVyKTtcbiAgfVxuXG4gIHJlYWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5KCkge1xuICAgIGlmICh0aGlzLnByZWNpc2lvbiAhPT0gJ3NpbmdsZScpIHRocm93IG5ldyBFcnJvcignUmVxdWlyZXMgdGhpcy5wcmVjaXNpb24gdG8gYmUgXCJzaW5nbGVcIicpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRleFNpemUsXG4gICAgICBjb250ZXh0OiBnbFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHcgPSB0ZXhTaXplWzBdO1xuICAgIGNvbnN0IGggPSB0ZXhTaXplWzFdO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkodyAqIGggKiA0KTtcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHcsIGgsIGdsLlJHQkEsIGdsLkZMT0FULCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRQaXhlbHMoZmxpcCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQ6IGdsLFxuICAgICAgb3V0cHV0XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gb3V0cHV0O1xuICAgIGNvbnN0IHBpeGVscyA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpO1xuICAgIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkoKGZsaXAgPyBwaXhlbHMgOiB1dGlscy5mbGlwUGl4ZWxzKHBpeGVscywgd2lkdGgsIGhlaWdodCkpLmJ1ZmZlcik7XG4gIH1cblxuICByZW5kZXJLZXJuZWxzVG9BcnJheXMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcmVzdWx0OiB0aGlzLnJlbmRlck91dHB1dCgpLFxuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFt0aGlzLnN1Yktlcm5lbHNbaV0ucHJvcGVydHldID0gdGhpcy5tYXBwZWRUZXh0dXJlc1tpXS50b0FycmF5KCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZW5kZXJLZXJuZWxzVG9UZXh0dXJlcygpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICByZXN1bHQ6IHRoaXMucmVuZGVyT3V0cHV0KCksXG4gICAgfTtcbiAgICBpZiAodGhpcy5pbW11dGFibGUpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFt0aGlzLnN1Yktlcm5lbHNbaV0ucHJvcGVydHldID0gdGhpcy5tYXBwZWRUZXh0dXJlc1tpXS5jbG9uZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRbdGhpcy5zdWJLZXJuZWxzW2ldLnByb3BlcnR5XSA9IHRoaXMubWFwcGVkVGV4dHVyZXNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXNldFN3aXRjaGluZ0tlcm5lbHMoKSB7XG4gICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IHRoaXMuc3dpdGNoaW5nS2VybmVscztcbiAgICB0aGlzLnN3aXRjaGluZ0tlcm5lbHMgPSBudWxsO1xuICAgIHJldHVybiBleGlzdGluZ1ZhbHVlO1xuICB9XG5cbiAgc2V0T3V0cHV0KG91dHB1dCkge1xuICAgIGNvbnN0IG5ld091dHB1dCA9IHRoaXMudG9LZXJuZWxPdXRwdXQob3V0cHV0KTtcbiAgICBpZiAodGhpcy5wcm9ncmFtKSB7XG4gICAgICBpZiAoIXRoaXMuZHluYW1pY091dHB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6aW5nIGEga2VybmVsIHdpdGggZHluYW1pY091dHB1dDogZmFsc2UgaXMgbm90IHBvc3NpYmxlJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdUaHJlYWREaW0gPSBbbmV3T3V0cHV0WzBdLCBuZXdPdXRwdXRbMV0gfHwgMSwgbmV3T3V0cHV0WzJdIHx8IDFdO1xuICAgICAgY29uc3QgbmV3VGV4U2l6ZSA9IHV0aWxzLmdldEtlcm5lbFRleHR1cmVTaXplKHtcbiAgICAgICAgb3B0aW1pemVGbG9hdE1lbW9yeTogdGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgICBwcmVjaXNpb246IHRoaXMucHJlY2lzaW9uLFxuICAgICAgfSwgbmV3VGhyZWFkRGltKTtcbiAgICAgIGNvbnN0IG9sZFRleFNpemUgPSB0aGlzLnRleFNpemU7XG4gICAgICBpZiAob2xkVGV4U2l6ZSkge1xuICAgICAgICBjb25zdCBvbGRQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKG9sZFRleFNpemUsIHRoaXMudGFjdGljKTtcbiAgICAgICAgY29uc3QgbmV3UHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZyhuZXdUZXhTaXplLCB0aGlzLnRhY3RpYyk7XG4gICAgICAgIGlmIChvbGRQcmVjaXNpb24gIT09IG5ld1ByZWNpc2lvbikge1xuICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1ByZWNpc2lvbiByZXF1aXJlbWVudCBjaGFuZ2VkLCBhc2tpbmcgR1BVIGluc3RhbmNlIHRvIHJlY29tcGlsZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN3aXRjaEtlcm5lbHMoe1xuICAgICAgICAgICAgdHlwZTogJ291dHB1dFByZWNpc2lvbk1pc21hdGNoJyxcbiAgICAgICAgICAgIHByZWNpc2lvbjogbmV3UHJlY2lzaW9uLFxuICAgICAgICAgICAgbmVlZGVkOiBvdXRwdXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub3V0cHV0ID0gbmV3T3V0cHV0O1xuICAgICAgdGhpcy50aHJlYWREaW0gPSBuZXdUaHJlYWREaW07XG4gICAgICB0aGlzLnRleFNpemUgPSBuZXdUZXhTaXplO1xuICAgICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICB0aGlzLnVwZGF0ZU1heFRleFNpemUoKTtcbiAgICAgIHRoaXMuZnJhbWVidWZmZXIud2lkdGggPSB0aGlzLnRleFNpemVbMF07XG4gICAgICB0aGlzLmZyYW1lYnVmZmVyLmhlaWdodCA9IHRoaXMudGV4U2l6ZVsxXTtcbiAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMubWF4VGV4U2l6ZVswXSwgdGhpcy5tYXhUZXhTaXplWzFdKTtcbiAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5tYXhUZXhTaXplWzBdO1xuICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5tYXhUZXhTaXplWzFdO1xuICAgICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUuZGVsZXRlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgICAgdGhpcy5fc2V0dXBPdXRwdXRUZXh0dXJlKCk7XG4gICAgICBpZiAodGhpcy5tYXBwZWRUZXh0dXJlcyAmJiB0aGlzLm1hcHBlZFRleHR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcHBlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5tYXBwZWRUZXh0dXJlc1tpXS5kZWxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcHBlZFRleHR1cmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2V0dXBTdWJPdXRwdXRUZXh0dXJlcygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm91dHB1dCA9IG5ld091dHB1dDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVuZGVyVmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdFZhbHVlcyhcbiAgICAgIHRoaXMudHJhbnNmZXJWYWx1ZXMoKSxcbiAgICAgIHRoaXMub3V0cHV0WzBdLFxuICAgICAgdGhpcy5vdXRwdXRbMV0sXG4gICAgICB0aGlzLm91dHB1dFsyXVxuICAgICk7XG4gIH1cbiAgc3dpdGNoS2VybmVscyhyZWFzb24pIHtcbiAgICBpZiAodGhpcy5zd2l0Y2hpbmdLZXJuZWxzKSB7XG4gICAgICB0aGlzLnN3aXRjaGluZ0tlcm5lbHMucHVzaChyZWFzb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN3aXRjaGluZ0tlcm5lbHMgPSBbcmVhc29uXTtcbiAgICB9XG4gIH1cbiAgZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcodGV4dHVyZVNpemUgPSB0aGlzLnRleFNpemUsIHRhY3RpYyA9IHRoaXMudGFjdGljLCBpc0ludCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0YWN0aWMpIHtcbiAgICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5mZWF0dXJlcy5pc1NwZWVkVGFjdGljU3VwcG9ydGVkKSByZXR1cm4gJ2hpZ2hwJztcbiAgICAgIGNvbnN0IGxvdyA9IHRoaXMuY29uc3RydWN0b3IuZmVhdHVyZXNbaXNJbnQgPyAnbG93SW50UHJlY2lzaW9uJyA6ICdsb3dGbG9hdFByZWNpc2lvbiddO1xuICAgICAgY29uc3QgbWVkaXVtID0gdGhpcy5jb25zdHJ1Y3Rvci5mZWF0dXJlc1tpc0ludCA/ICdtZWRpdW1JbnRQcmVjaXNpb24nIDogJ21lZGl1bUZsb2F0UHJlY2lzaW9uJ107XG4gICAgICBjb25zdCBoaWdoID0gdGhpcy5jb25zdHJ1Y3Rvci5mZWF0dXJlc1tpc0ludCA/ICdoaWdoSW50UHJlY2lzaW9uJyA6ICdoaWdoRmxvYXRQcmVjaXNpb24nXTtcbiAgICAgIGNvbnN0IHJlcXVpcmVkU2l6ZSA9IE1hdGgubG9nMih0ZXh0dXJlU2l6ZVswXSAqIHRleHR1cmVTaXplWzFdKTtcbiAgICAgIGlmIChyZXF1aXJlZFNpemUgPD0gbG93LnJhbmdlTWF4KSB7XG4gICAgICAgIHJldHVybiAnbG93cCc7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVpcmVkU2l6ZSA8PSBtZWRpdW0ucmFuZ2VNYXgpIHtcbiAgICAgICAgcmV0dXJuICdtZWRpdW1wJztcbiAgICAgIH0gZWxzZSBpZiAocmVxdWlyZWRTaXplIDw9IGhpZ2gucmFuZ2VNYXgpIHtcbiAgICAgICAgcmV0dXJuICdoaWdocCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSByZXF1aXJlZCBzaXplIGV4Y2VlZHMgdGhhdCBvZiB0aGUgYWJpbGl0eSBvZiB5b3VyIHN5c3RlbWApO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHRhY3RpYykge1xuICAgICAgY2FzZSAnc3BlZWQnOlxuICAgICAgICByZXR1cm4gJ2xvd3AnO1xuICAgICAgY2FzZSAnYmFsYW5jZWQnOlxuICAgICAgICByZXR1cm4gJ21lZGl1bXAnO1xuICAgICAgY2FzZSAncHJlY2lzaW9uJzpcbiAgICAgICAgcmV0dXJuICdoaWdocCc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdGFjdGljIFwiJHt0YWN0aWN9XCIgdXNlIFwic3BlZWRcIiwgXCJiYWxhbmNlZFwiLCBcInByZWNpc2lvblwiLCBvciBlbXB0eSBmb3IgYXV0b2ApO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVRleHR1cmVBcmd1bWVudFJlZnMoa2VybmVsVmFsdWUsIGFyZykge1xuICAgIGlmICghdGhpcy5pbW11dGFibGUpIHJldHVybjtcbiAgICBpZiAodGhpcy50ZXh0dXJlLnRleHR1cmUgPT09IGFyZy50ZXh0dXJlKSB7XG4gICAgICBjb25zdCB7IHByZXZBcmcgfSA9IGtlcm5lbFZhbHVlO1xuICAgICAgaWYgKHByZXZBcmcpIHtcbiAgICAgICAgaWYgKHByZXZBcmcudGV4dHVyZS5fcmVmcyA9PT0gMSkge1xuICAgICAgICAgIHRoaXMudGV4dHVyZS5kZWxldGUoKTtcbiAgICAgICAgICB0aGlzLnRleHR1cmUgPSBwcmV2QXJnLmNsb25lKCk7XG4gICAgICAgICAgdGhpcy5fdGV4dHVyZVN3aXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2QXJnLmRlbGV0ZSgpO1xuICAgICAgfVxuICAgICAga2VybmVsVmFsdWUucHJldkFyZyA9IGFyZy5jbG9uZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXBwZWRUZXh0dXJlcyAmJiB0aGlzLm1hcHBlZFRleHR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHsgbWFwcGVkVGV4dHVyZXMgfSA9IHRoaXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcHBlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlZFRleHR1cmUgPSBtYXBwZWRUZXh0dXJlc1tpXTtcbiAgICAgICAgaWYgKG1hcHBlZFRleHR1cmUudGV4dHVyZSA9PT0gYXJnLnRleHR1cmUpIHtcbiAgICAgICAgICBjb25zdCB7IHByZXZBcmcgfSA9IGtlcm5lbFZhbHVlO1xuICAgICAgICAgIGlmIChwcmV2QXJnKSB7XG4gICAgICAgICAgICBpZiAocHJldkFyZy50ZXh0dXJlLl9yZWZzID09PSAxKSB7XG4gICAgICAgICAgICAgIG1hcHBlZFRleHR1cmUuZGVsZXRlKCk7XG4gICAgICAgICAgICAgIG1hcHBlZFRleHR1cmVzW2ldID0gcHJldkFyZy5jbG9uZSgpO1xuICAgICAgICAgICAgICB0aGlzLl9tYXBwZWRUZXh0dXJlU3dpdGNoZWRbaV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkFyZy5kZWxldGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2VybmVsVmFsdWUucHJldkFyZyA9IGFyZy5jbG9uZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uQWN0aXZhdGUocHJldmlvdXNLZXJuZWwpIHtcbiAgICB0aGlzLl90ZXh0dXJlU3dpdGNoZWQgPSB0cnVlO1xuICAgIHRoaXMudGV4dHVyZSA9IHByZXZpb3VzS2VybmVsLnRleHR1cmU7XG4gICAgaWYgKHRoaXMubWFwcGVkVGV4dHVyZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXBwZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9tYXBwZWRUZXh0dXJlU3dpdGNoZWRbaV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5tYXBwZWRUZXh0dXJlcyA9IHByZXZpb3VzS2VybmVsLm1hcHBlZFRleHR1cmVzO1xuICAgIH1cbiAgfVxuXG4gIGluaXRDYW52YXMoKSB7fVxufVxuXG5jb25zdCB0eXBlTWFwID0ge1xuICBpbnQ6ICdJbnRlZ2VyJyxcbiAgZmxvYXQ6ICdOdW1iZXInLFxuICB2ZWMyOiAnQXJyYXkoMiknLFxuICB2ZWMzOiAnQXJyYXkoMyknLFxuICB2ZWM0OiAnQXJyYXkoNCknLFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMS2VybmVsXG59O1xufSx7XCIuLi8uLi91dGlsc1wiOjExNCxcIi4uL2tlcm5lbFwiOjM2LFwiLi90ZXh0dXJlL2FycmF5LTItZmxvYXRcIjoxNixcIi4vdGV4dHVyZS9hcnJheS0yLWZsb2F0LTJkXCI6MTQsXCIuL3RleHR1cmUvYXJyYXktMi1mbG9hdC0zZFwiOjE1LFwiLi90ZXh0dXJlL2FycmF5LTMtZmxvYXRcIjoxOSxcIi4vdGV4dHVyZS9hcnJheS0zLWZsb2F0LTJkXCI6MTcsXCIuL3RleHR1cmUvYXJyYXktMy1mbG9hdC0zZFwiOjE4LFwiLi90ZXh0dXJlL2FycmF5LTQtZmxvYXRcIjoyMixcIi4vdGV4dHVyZS9hcnJheS00LWZsb2F0LTJkXCI6MjAsXCIuL3RleHR1cmUvYXJyYXktNC1mbG9hdC0zZFwiOjIxLFwiLi90ZXh0dXJlL2Zsb2F0XCI6MjUsXCIuL3RleHR1cmUvZmxvYXQtMmRcIjoyMyxcIi4vdGV4dHVyZS9mbG9hdC0zZFwiOjI0LFwiLi90ZXh0dXJlL2dyYXBoaWNhbFwiOjI2LFwiLi90ZXh0dXJlL21lbW9yeS1vcHRpbWl6ZWRcIjozMCxcIi4vdGV4dHVyZS9tZW1vcnktb3B0aW1pemVkLTJkXCI6MjgsXCIuL3RleHR1cmUvbWVtb3J5LW9wdGltaXplZC0zZFwiOjI5LFwiLi90ZXh0dXJlL3Vuc2lnbmVkXCI6MzMsXCIuL3RleHR1cmUvdW5zaWduZWQtMmRcIjozMSxcIi4vdGV4dHVyZS91bnNpZ25lZC0zZFwiOjMyfV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlQXJyYXkyRmxvYXQyRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgyKSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QyREFycmF5Mih0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTJGbG9hdDJEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUFycmF5MkZsb2F0M0QgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoMiknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0M0RBcnJheTIodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdLCB0aGlzLm91dHB1dFsyXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUFycmF5MkZsb2F0M0Rcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlQXJyYXkyRmxvYXQgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoMiknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0QXJyYXkyKHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUFycmF5MkZsb2F0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUFycmF5M0Zsb2F0MkQgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoMyknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0MkRBcnJheTModGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXkzRmxvYXQyRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTNGbG9hdDNEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDMpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDNEQXJyYXkzKHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSwgdGhpcy5vdXRwdXRbMl0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTNGbG9hdDNEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUFycmF5M0Zsb2F0IGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDMpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdEFycmF5Myh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUFycmF5M0Zsb2F0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUFycmF5NEZsb2F0MkQgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoNCknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0MkRBcnJheTQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXk0RmxvYXQyRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTRGbG9hdDNEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDQpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDNEQXJyYXk0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSwgdGhpcy5vdXRwdXRbMl0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTRGbG9hdDNEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUFycmF5NEZsb2F0IGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDQpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdEFycmF5NCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUFycmF5NEZsb2F0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUZsb2F0MkQgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoMSknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0MkRGbG9hdCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVGbG9hdDJEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUZsb2F0M0QgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoMSknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0M0RGbG9hdCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0sIHRoaXMub3V0cHV0WzJdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlRmxvYXQzRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2xhc3MgR0xUZXh0dXJlRmxvYXQgZXh0ZW5kcyBHTFRleHR1cmUge1xuICBnZXQgdGV4dHVyZVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5GTE9BVDtcbiAgfVxuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDEpJztcbiAgfVxuICByZW5kZXJSYXdPdXRwdXQoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIoKSk7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgIHRoaXMudGV4dHVyZSxcbiAgICAgIDBcbiAgICApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZVswXSAqIHNpemVbMV0gKiA0KTtcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHNpemVbMF0sIHNpemVbMV0sIGdsLlJHQkEsIGdsLkZMT0FULCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVuZGVyVmFsdWVzKCkge1xuICAgIGlmICh0aGlzLl9kZWxldGVkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJSYXdPdXRwdXQoKTtcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdEZsb2F0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlRmxvYXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9pbmRleFwiOjI3fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBHTFRleHR1cmVVbnNpZ25lZCB9ID0gcmVxdWlyZSgnLi91bnNpZ25lZCcpO1xuXG5jbGFzcyBHTFRleHR1cmVHcmFwaGljYWwgZXh0ZW5kcyBHTFRleHR1cmVVbnNpZ25lZCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoNCknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVmFsdWVzKCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUdyYXBoaWNhbFxufTtcbn0se1wiLi91bnNpZ25lZFwiOjMzfV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBUZXh0dXJlIH0gPSByZXF1aXJlKCcuLi8uLi8uLi90ZXh0dXJlJyk7XG5cbmNsYXNzIEdMVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuICBnZXQgdGV4dHVyZVR5cGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInRleHR1cmVUeXBlXCIgbm90IGltcGxlbWVudGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gIH1cblxuICBiZWZvcmVNdXRhdGUoKSB7XG4gICAgaWYgKHRoaXMudGV4dHVyZS5fcmVmcyA+IDEpIHtcbiAgICAgIHRoaXMubmV3VGV4dHVyZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNsb25lVGV4dHVyZSgpIHtcbiAgICB0aGlzLnRleHR1cmUuX3JlZnMtLTtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsLCBzaXplLCB0ZXh0dXJlLCBrZXJuZWwgfSA9IHRoaXM7XG4gICAgaWYgKGtlcm5lbC5kZWJ1Zykge1xuICAgICAgY29uc29sZS53YXJuKCdjbG9uaW5nIGludGVybmFsIHRleHR1cmUnKTtcbiAgICB9XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKCkpO1xuICAgIHNlbGVjdFRleHR1cmUoZ2wsIHRleHR1cmUpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIHNlbGVjdFRleHR1cmUoZ2wsIHRhcmdldCk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLmludGVybmFsRm9ybWF0LCBzaXplWzBdLCBzaXplWzFdLCAwLCB0aGlzLnRleHR1cmVGb3JtYXQsIHRoaXMudGV4dHVyZVR5cGUsIG51bGwpO1xuICAgIGdsLmNvcHlUZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIDAsIDAsIHNpemVbMF0sIHNpemVbMV0pO1xuICAgIHRhcmdldC5fcmVmcyA9IDE7XG4gICAgdGhpcy50ZXh0dXJlID0gdGFyZ2V0O1xuICB9XG5cbiAgbmV3VGV4dHVyZSgpIHtcbiAgICB0aGlzLnRleHR1cmUuX3JlZnMtLTtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCBzaXplID0gdGhpcy5zaXplO1xuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVsO1xuICAgIGlmIChrZXJuZWwuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUud2FybignbmV3IGludGVybmFsIHRleHR1cmUnKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIHNlbGVjdFRleHR1cmUoZ2wsIHRhcmdldCk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLmludGVybmFsRm9ybWF0LCBzaXplWzBdLCBzaXplWzFdLCAwLCB0aGlzLnRleHR1cmVGb3JtYXQsIHRoaXMudGV4dHVyZVR5cGUsIG51bGwpO1xuICAgIHRhcmdldC5fcmVmcyA9IDE7XG4gICAgdGhpcy50ZXh0dXJlID0gdGFyZ2V0O1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgaWYgKHRoaXMudGV4dHVyZS5fcmVmcykge1xuICAgICAgdGhpcy50ZXh0dXJlLl9yZWZzLS07XG4gICAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIHNlbGVjdFRleHR1cmUoZ2wsIHRhcmdldCk7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5zaXplO1xuICAgICAgdGFyZ2V0Ll9yZWZzID0gMTtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5pbnRlcm5hbEZvcm1hdCwgc2l6ZVswXSwgc2l6ZVsxXSwgMCwgdGhpcy50ZXh0dXJlRm9ybWF0LCB0aGlzLnRleHR1cmVUeXBlLCBudWxsKTtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCwgdGV4dHVyZSB9ID0gdGhpcztcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIoKSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgc2VsZWN0VGV4dHVyZShnbCwgdGV4dHVyZSk7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgfVxuXG4gIGRlbGV0ZSgpIHtcbiAgICBpZiAodGhpcy5fZGVsZXRlZCkgcmV0dXJuO1xuICAgIHRoaXMuX2RlbGV0ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLnRleHR1cmUuX3JlZnMpIHtcbiAgICAgIHRoaXMudGV4dHVyZS5fcmVmcy0tO1xuICAgICAgaWYgKHRoaXMudGV4dHVyZS5fcmVmcykgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbnRleHQuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmUpO1xuICB9XG5cbiAgZnJhbWVidWZmZXIoKSB7XG4gICAgaWYgKCF0aGlzLl9mcmFtZWJ1ZmZlcikge1xuICAgICAgdGhpcy5fZnJhbWVidWZmZXIgPSB0aGlzLmtlcm5lbC5nZXRSYXdWYWx1ZUZyYW1lYnVmZmVyKHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZyYW1lYnVmZmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlbGVjdFRleHR1cmUoZ2wsIHRleHR1cmUpIHtcbiAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMTUpO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IEdMVGV4dHVyZSB9O1xufSx7XCIuLi8uLi8uLi90ZXh0dXJlXCI6MTEzfV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkMkQgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZDJERmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkMkRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkM0QgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZDNERmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdLCB0aGlzLm91dHB1dFsyXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDNEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0TWVtb3J5T3B0aW1pemVkRmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlVW5zaWduZWQgfSA9IHJlcXVpcmUoJy4vdW5zaWduZWQnKTtcblxuY2xhc3MgR0xUZXh0dXJlVW5zaWduZWQyRCBleHRlbmRzIEdMVGV4dHVyZVVuc2lnbmVkIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ051bWJlclRleHR1cmUnO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0MkRQYWNrZWRGbG9hdCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVVbnNpZ25lZDJEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vdW5zaWduZWRcIjozM31dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZVVuc2lnbmVkIH0gPSByZXF1aXJlKCcuL3Vuc2lnbmVkJyk7XG5cbmNsYXNzIEdMVGV4dHVyZVVuc2lnbmVkM0QgZXh0ZW5kcyBHTFRleHR1cmVVbnNpZ25lZCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdOdW1iZXJUZXh0dXJlJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDNEUGFja2VkRmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdLCB0aGlzLm91dHB1dFsyXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZVVuc2lnbmVkM0Rcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi91bnNpZ25lZFwiOjMzfV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZVVuc2lnbmVkIGV4dGVuZHMgR0xUZXh0dXJlIHtcbiAgZ2V0IHRleHR1cmVUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuVU5TSUdORURfQllURTtcbiAgfVxuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnTnVtYmVyVGV4dHVyZSc7XG4gIH1cbiAgcmVuZGVyUmF3T3V0cHV0KCkge1xuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKCkpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcbiAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICB0aGlzLnRleHR1cmUsXG4gICAgICAwXG4gICAgKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0aGlzLnNpemVbMF0gKiB0aGlzLnNpemVbMV0gKiA0KTtcbiAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHRoaXMuc2l6ZVswXSwgdGhpcy5zaXplWzFdLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVuZGVyVmFsdWVzKCkge1xuICAgIGlmICh0aGlzLl9kZWxldGVkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnJlbmRlclJhd091dHB1dCgpLmJ1ZmZlcik7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RQYWNrZWRGbG9hdCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZVVuc2lnbmVkXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaW5kZXhcIjoyN31dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IGdldENvbnRleHQgPSByZXF1aXJlKCdnbCcpO1xuY29uc3QgeyBXZWJHTEtlcm5lbCB9ID0gcmVxdWlyZSgnLi4vd2ViLWdsL2tlcm5lbCcpO1xuY29uc3QgeyBnbEtlcm5lbFN0cmluZyB9ID0gcmVxdWlyZSgnLi4vZ2wva2VybmVsLXN0cmluZycpO1xuXG5sZXQgaXNTdXBwb3J0ZWQgPSBudWxsO1xubGV0IHRlc3RDYW52YXMgPSBudWxsO1xubGV0IHRlc3RDb250ZXh0ID0gbnVsbDtcbmxldCB0ZXN0RXh0ZW5zaW9ucyA9IG51bGw7XG5sZXQgZmVhdHVyZXMgPSBudWxsO1xuXG5jbGFzcyBIZWFkbGVzc0dMS2VybmVsIGV4dGVuZHMgV2ViR0xLZXJuZWwge1xuICBzdGF0aWMgZ2V0IGlzU3VwcG9ydGVkKCkge1xuICAgIGlmIChpc1N1cHBvcnRlZCAhPT0gbnVsbCkgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgIHRoaXMuc2V0dXBGZWF0dXJlQ2hlY2tzKCk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0ZXN0Q29udGV4dCAhPT0gbnVsbDtcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgc2V0dXBGZWF0dXJlQ2hlY2tzKCkge1xuICAgIHRlc3RDYW52YXMgPSBudWxsO1xuICAgIHRlc3RFeHRlbnNpb25zID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGdldENvbnRleHQgIT09ICdmdW5jdGlvbicpIHJldHVybjtcbiAgICB0cnkgeyBcbiAgICAgIHRlc3RDb250ZXh0ID0gZ2V0Q29udGV4dCgyLCAyLCB7XG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIXRlc3RDb250ZXh0IHx8ICF0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24pIHJldHVybjtcbiAgICAgIHRlc3RFeHRlbnNpb25zID0ge1xuICAgICAgICBTVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ1NUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXInKSxcbiAgICAgICAgU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQnKSxcbiAgICAgICAgT0VTX3RleHR1cmVfZmxvYXQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcbiAgICAgICAgT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpLFxuICAgICAgICBPRVNfZWxlbWVudF9pbmRleF91aW50OiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSxcbiAgICAgICAgV0VCR0xfZHJhd19idWZmZXJzOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxuICAgICAgICBXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQ6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JyksXG4gICAgICB9O1xuICAgICAgZmVhdHVyZXMgPSB0aGlzLmdldEZlYXR1cmVzKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBpc0NvbnRleHRNYXRjaChjb250ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb250ZXh0LmdldFBhcmFtZXRlcihjb250ZXh0LlJFTkRFUkVSKSA9PT0gJ0FOR0xFJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldElzVGV4dHVyZUZsb2F0KCkge1xuICAgIHJldHVybiBCb29sZWFuKHRlc3RFeHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc0RyYXdCdWZmZXJzKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRlc3RFeHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0Q2hhbm5lbENvdW50KCkge1xuICAgIHJldHVybiB0ZXN0RXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMgP1xuICAgICAgdGVzdENvbnRleHQuZ2V0UGFyYW1ldGVyKHRlc3RFeHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycy5NQVhfRFJBV19CVUZGRVJTX1dFQkdMKSA6XG4gICAgICAxO1xuICB9XG5cbiAgc3RhdGljIGdldE1heFRleHR1cmVTaXplKCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dC5nZXRQYXJhbWV0ZXIodGVzdENvbnRleHQuTUFYX1RFWFRVUkVfU0laRSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDYW52YXMoKSB7XG4gICAgcmV0dXJuIHRlc3RDYW52YXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDb250ZXh0KCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgaW5pdENhbnZhcygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBpbml0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgyLCAyLCB7XG4gICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGluaXRFeHRlbnNpb25zKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHtcbiAgICAgIFNUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXI6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ1NUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXInKSxcbiAgICAgIFNUQUNLR0xfZGVzdHJveV9jb250ZXh0OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdTVEFDS0dMX2Rlc3Ryb3lfY29udGV4dCcpLFxuICAgICAgT0VTX3RleHR1cmVfZmxvYXQ6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JyksXG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXI6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpLFxuICAgICAgT0VTX2VsZW1lbnRfaW5kZXhfdWludDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpLFxuICAgICAgV0VCR0xfZHJhd19idWZmZXJzOiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKSxcbiAgICB9O1xuICB9XG5cbiAgYnVpbGQoKSB7XG4gICAgc3VwZXIuYnVpbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoIXRoaXMuZmFsbGJhY2tSZXF1ZXN0ZWQpIHtcbiAgICAgIHRoaXMuZXh0ZW5zaW9ucy5TVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyLnJlc2l6ZSh0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveUV4dGVuc2lvbnMoKSB7XG4gICAgdGhpcy5leHRlbnNpb25zLlNUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXIgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5TVEFDS0dMX2Rlc3Ryb3lfY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMuT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyID0gbnVsbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMuT0VTX2VsZW1lbnRfaW5kZXhfdWludCA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycyA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZGVzdHJveUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdTVEFDS0dMX2Rlc3Ryb3lfY29udGV4dCcpO1xuICAgIGlmIChleHRlbnNpb24gJiYgZXh0ZW5zaW9uLmRlc3Ryb3kpIHtcbiAgICAgIGV4dGVuc2lvbi5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qgc2V0dXBDb250ZXh0U3RyaW5nID0gYGNvbnN0IGdsID0gY29udGV4dCB8fCByZXF1aXJlKCdnbCcpKDEsIDEpO1xcbmA7XG4gICAgY29uc3QgZGVzdHJveUNvbnRleHRTdHJpbmcgPSBgICAgIGlmICghY29udGV4dCkgeyBnbC5nZXRFeHRlbnNpb24oJ1NUQUNLR0xfZGVzdHJveV9jb250ZXh0JykuZGVzdHJveSgpOyB9XFxuYDtcbiAgICByZXR1cm4gZ2xLZXJuZWxTdHJpbmcodGhpcy5jb25zdHJ1Y3RvciwgYXJndW1lbnRzLCB0aGlzLCBzZXR1cENvbnRleHRTdHJpbmcsIGRlc3Ryb3lDb250ZXh0U3RyaW5nKTtcbiAgfVxuXG4gIHNldE91dHB1dChvdXRwdXQpIHtcbiAgICBzdXBlci5zZXRPdXRwdXQob3V0cHV0KTtcbiAgICBpZiAodGhpcy5ncmFwaGljYWwgJiYgdGhpcy5leHRlbnNpb25zLlNUQUNLR0xfcmVzaXplX2RyYXdpbmdidWZmZXIpIHtcbiAgICAgIHRoaXMuZXh0ZW5zaW9ucy5TVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyLnJlc2l6ZSh0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBIZWFkbGVzc0dMS2VybmVsXG59O1xufSx7XCIuLi9nbC9rZXJuZWwtc3RyaW5nXCI6MTIsXCIuLi93ZWItZ2wva2VybmVsXCI6NzAsXCJnbFwiOjJ9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jbGFzcyBLZXJuZWxWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBrZXJuZWwsXG4gICAgICBjb250ZXh0LFxuICAgICAgY2hlY2tDb250ZXh0LFxuICAgICAgb25SZXF1ZXN0Q29udGV4dEhhbmRsZSxcbiAgICAgIG9uVXBkYXRlVmFsdWVNaXNtYXRjaCxcbiAgICAgIG9yaWdpbixcbiAgICAgIHN0cmljdEludGVnZXJzLFxuICAgICAgdHlwZSxcbiAgICAgIHRhY3RpYyxcbiAgICB9ID0gc2V0dGluZ3M7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgbm90IHNldCcpO1xuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBub3Qgc2V0Jyk7XG4gICAgfVxuICAgIGlmICghb3JpZ2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29yaWdpbiBub3Qgc2V0Jyk7XG4gICAgfVxuICAgIGlmIChvcmlnaW4gIT09ICd1c2VyJyAmJiBvcmlnaW4gIT09ICdjb25zdGFudHMnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG9yaWdpbiBtdXN0IGJlIFwidXNlclwiIG9yIFwiY29uc3RhbnRzXCIgdmFsdWUgaXMgXCIkeyBvcmlnaW4gfVwiYCk7XG4gICAgfVxuICAgIGlmICghb25SZXF1ZXN0Q29udGV4dEhhbmRsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvblJlcXVlc3RDb250ZXh0SGFuZGxlIGlzIG5vdCBzZXQnKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICB0aGlzLnRhY3RpYyA9IHRhY3RpYztcbiAgICB0aGlzLnZhck5hbWUgPSBvcmlnaW4gPT09ICdjb25zdGFudHMnID8gYGNvbnN0YW50cy4ke25hbWV9YCA6IG5hbWU7XG4gICAgdGhpcy5rZXJuZWwgPSBrZXJuZWw7XG4gICAgdGhpcy5zdHJpY3RJbnRlZ2VycyA9IHN0cmljdEludGVnZXJzO1xuICAgIHRoaXMudHlwZSA9IHZhbHVlLnR5cGUgfHwgdHlwZTtcbiAgICB0aGlzLnNpemUgPSB2YWx1ZS5zaXplIHx8IG51bGw7XG4gICAgdGhpcy5pbmRleCA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNoZWNrQ29udGV4dCA9IGNoZWNrQ29udGV4dCAhPT0gbnVsbCAmJiBjaGVja0NvbnRleHQgIT09IHVuZGVmaW5lZCA/IGNoZWNrQ29udGV4dCA6IHRydWU7XG4gICAgdGhpcy5jb250ZXh0SGFuZGxlID0gbnVsbDtcbiAgICB0aGlzLm9uUmVxdWVzdENvbnRleHRIYW5kbGUgPSBvblJlcXVlc3RDb250ZXh0SGFuZGxlO1xuICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoID0gb25VcGRhdGVWYWx1ZU1pc21hdGNoO1xuICAgIHRoaXMuZm9yY2VVcGxvYWRFYWNoUnVuID0gbnVsbDtcbiAgfVxuXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcmlnaW59XyR7bmFtZX1gO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJnZXRTb3VyY2VcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwidXBkYXRlVmFsdWVcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBLZXJuZWxWYWx1ZVxufTtcbn0se31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCB7IElucHV0IH0gPSByZXF1aXJlKCcuLi9pbnB1dCcpO1xuXG5jbGFzcyBLZXJuZWwge1xuICBzdGF0aWMgZ2V0IGlzU3VwcG9ydGVkKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJpc1N1cHBvcnRlZFwiIG5vdCBpbXBsZW1lbnRlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgc3RhdGljIGlzQ29udGV4dE1hdGNoKGNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiaXNDb250ZXh0TWF0Y2hcIiBub3QgaW1wbGVtZW50ZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRGZWF0dXJlcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZ2V0RmVhdHVyZXNcIiBub3QgaW1wbGVtZW50ZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBkZXN0cm95Q29udGV4dChjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImRlc3Ryb3lDb250ZXh0XCIgY2FsbGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgbmF0aXZlRnVuY3Rpb25Bcmd1bWVudHMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIm5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzXCIgY2FsbGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgbmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJuYXRpdmVGdW5jdGlvblJldHVyblR5cGVcIiBjYWxsZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBjb21iaW5lS2VybmVscygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiY29tYmluZUtlcm5lbHNcIiBjYWxsZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBub3QgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbHMuaXNGdW5jdGlvblN0cmluZyhzb3VyY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIG5vdCBhIGZ1bmN0aW9uIHN0cmluZycpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPSBmYWxzZTtcbiAgICB0aGlzLmZhbGxiYWNrUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5vblJlcXVlc3RGYWxsYmFjayA9IG51bGw7XG5cbiAgICB0aGlzLmFyZ3VtZW50TmFtZXMgPSB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IHV0aWxzLmdldEFyZ3VtZW50TmFtZXNGcm9tU3RyaW5nKHNvdXJjZSkgOiBudWxsO1xuICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IG51bGw7XG4gICAgdGhpcy5hcmd1bWVudFNpemVzID0gbnVsbDtcbiAgICB0aGlzLmFyZ3VtZW50Qml0UmF0aW9zID0gbnVsbDtcbiAgICB0aGlzLmtlcm5lbEFyZ3VtZW50cyA9IG51bGw7XG4gICAgdGhpcy5rZXJuZWxDb25zdGFudHMgPSBudWxsO1xuICAgIHRoaXMuZm9yY2VVcGxvYWRLZXJuZWxDb25zdGFudHMgPSBudWxsO1xuXG5cbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgIHRoaXMub3V0cHV0ID0gbnVsbDtcblxuICAgIHRoaXMuZGVidWcgPSBmYWxzZTtcblxuICAgIHRoaXMuZ3JhcGhpY2FsID0gZmFsc2U7XG5cbiAgICB0aGlzLmxvb3BNYXhJdGVyYXRpb25zID0gMDtcblxuICAgIHRoaXMuY29uc3RhbnRzID0gbnVsbDtcblxuICAgIHRoaXMuY29uc3RhbnRUeXBlcyA9IG51bGw7XG5cbiAgICB0aGlzLmNvbnN0YW50Qml0UmF0aW9zID0gbnVsbDtcblxuICAgIHRoaXMuZHluYW1pY0FyZ3VtZW50cyA9IGZhbHNlO1xuXG4gICAgdGhpcy5keW5hbWljT3V0cHV0ID0gZmFsc2U7XG5cbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuXG4gICAgdGhpcy5jaGVja0NvbnRleHQgPSBudWxsO1xuXG4gICAgdGhpcy5ncHUgPSBudWxsO1xuXG4gICAgdGhpcy5mdW5jdGlvbnMgPSBudWxsO1xuXG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMgPSBudWxsO1xuXG4gICAgdGhpcy5pbmplY3RlZE5hdGl2ZSA9IG51bGw7XG5cbiAgICB0aGlzLnN1Yktlcm5lbHMgPSBudWxsO1xuXG4gICAgdGhpcy52YWxpZGF0ZSA9IHRydWU7XG5cbiAgICB0aGlzLmltbXV0YWJsZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5waXBlbGluZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5wcmVjaXNpb24gPSBudWxsO1xuXG4gICAgdGhpcy50YWN0aWMgPSBudWxsO1xuXG4gICAgdGhpcy5wbHVnaW5zID0gbnVsbDtcblxuICAgIHRoaXMucmV0dXJuVHlwZSA9IG51bGw7XG4gICAgdGhpcy5sZWFkaW5nUmV0dXJuU3RhdGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmZvbGxvd2luZ1JldHVyblN0YXRlbWVudCA9IG51bGw7XG4gICAgdGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5ID0gbnVsbDtcbiAgICB0aGlzLnN0cmljdEludGVnZXJzID0gZmFsc2U7XG4gICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IG51bGw7XG4gICAgdGhpcy5idWlsdCA9IGZhbHNlO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gbnVsbDtcbiAgfVxuXG4gIG1lcmdlU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICBmb3IgKGxldCBwIGluIHNldHRpbmdzKSB7XG4gICAgICBpZiAoIXNldHRpbmdzLmhhc093blByb3BlcnR5KHApIHx8ICF0aGlzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgIHN3aXRjaCAocCkge1xuICAgICAgICBjYXNlICdvdXRwdXQnOlxuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzZXR0aW5ncy5vdXRwdXQpKSB7XG4gICAgICAgICAgICB0aGlzLnNldE91dHB1dChzZXR0aW5ncy5vdXRwdXQpOyBcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnVuY3Rpb25zJzpcbiAgICAgICAgICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0dGluZ3MuZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZ1bmN0aW9uKHNldHRpbmdzLmZ1bmN0aW9uc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlICdncmFwaGljYWwnOlxuICAgICAgICAgIGlmIChzZXR0aW5nc1twXSAmJiAhc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3ByZWNpc2lvbicpKSB7XG4gICAgICAgICAgICB0aGlzLnByZWNpc2lvbiA9ICd1bnNpZ25lZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXNbcF0gPSBzZXR0aW5nc1twXTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSAnbmF0aXZlRnVuY3Rpb25zJzpcbiAgICAgICAgICBpZiAoIXNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9ucykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcyA9IHNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgc291cmNlIH0gPSBzO1xuICAgICAgICAgICAgdGhpcy5hZGROYXRpdmVGdW5jdGlvbihuYW1lLCBzb3VyY2UsIHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXNbcF0gPSBzZXR0aW5nc1twXTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY2FudmFzKSB0aGlzLmNhbnZhcyA9IHRoaXMuaW5pdENhbnZhcygpO1xuICAgIGlmICghdGhpcy5jb250ZXh0KSB0aGlzLmNvbnRleHQgPSB0aGlzLmluaXRDb250ZXh0KCk7XG4gICAgaWYgKCF0aGlzLnBsdWdpbnMpIHRoaXMucGx1Z2lucyA9IHRoaXMuaW5pdFBsdWdpbnMoc2V0dGluZ3MpO1xuICB9XG4gIGJ1aWxkKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJidWlsZFwiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBydW4oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInJ1blwiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YClcbiAgfVxuXG4gIGluaXRDYW52YXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImluaXRDYW52YXNcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgaW5pdENvbnRleHQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImluaXRDb250ZXh0XCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIGluaXRQbHVnaW5zKHNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImluaXRQbHVnaW5zXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIGFkZEZ1bmN0aW9uKHNvdXJjZSwgc2V0dGluZ3MgPSB7fSkge1xuICAgIGlmIChzb3VyY2UubmFtZSAmJiBzb3VyY2Uuc291cmNlICYmIHNvdXJjZS5hcmd1bWVudFR5cGVzICYmICdyZXR1cm5UeXBlJyBpbiBzb3VyY2UpIHtcbiAgICAgIHRoaXMuZnVuY3Rpb25zLnB1c2goc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKCdzZXR0aW5ncycgaW4gc291cmNlICYmICdzb3VyY2UnIGluIHNvdXJjZSkge1xuICAgICAgdGhpcy5mdW5jdGlvbnMucHVzaCh0aGlzLmZ1bmN0aW9uVG9JR1BVRnVuY3Rpb24oc291cmNlLnNvdXJjZSwgc291cmNlLnNldHRpbmdzKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKHRoaXMuZnVuY3Rpb25Ub0lHUFVGdW5jdGlvbihzb3VyY2UsIHNldHRpbmdzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZnVuY3Rpb24gbm90IHByb3Blcmx5IGRlZmluZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGROYXRpdmVGdW5jdGlvbihuYW1lLCBzb3VyY2UsIHNldHRpbmdzID0ge30pIHtcbiAgICBjb25zdCB7IGFyZ3VtZW50VHlwZXMsIGFyZ3VtZW50TmFtZXMgfSA9IHNldHRpbmdzLmFyZ3VtZW50VHlwZXMgP1xuICAgICAgc3BsaXRBcmd1bWVudFR5cGVzKHNldHRpbmdzLmFyZ3VtZW50VHlwZXMpIDpcbiAgICAgIHRoaXMuY29uc3RydWN0b3IubmF0aXZlRnVuY3Rpb25Bcmd1bWVudHMoc291cmNlKSB8fCB7fTtcbiAgICB0aGlzLm5hdGl2ZUZ1bmN0aW9ucy5wdXNoKHtcbiAgICAgIG5hbWUsXG4gICAgICBzb3VyY2UsXG4gICAgICBzZXR0aW5ncyxcbiAgICAgIGFyZ3VtZW50VHlwZXMsXG4gICAgICBhcmd1bWVudE5hbWVzLFxuICAgICAgcmV0dXJuVHlwZTogc2V0dGluZ3MucmV0dXJuVHlwZSB8fCB0aGlzLmNvbnN0cnVjdG9yLm5hdGl2ZUZ1bmN0aW9uUmV0dXJuVHlwZShzb3VyY2UpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXR1cEFyZ3VtZW50cyhhcmdzKSB7XG4gICAgdGhpcy5rZXJuZWxBcmd1bWVudHMgPSBbXTtcbiAgICBpZiAoIXRoaXMuYXJndW1lbnRUeXBlcykge1xuICAgICAgaWYgKCF0aGlzLmFyZ3VtZW50VHlwZXMpIHtcbiAgICAgICAgdGhpcy5hcmd1bWVudFR5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGFyZ1R5cGUgPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUoYXJnc1tpXSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IGFyZ1R5cGUgPT09ICdJbnRlZ2VyJyA/ICdOdW1iZXInIDogYXJnVHlwZTtcbiAgICAgICAgICB0aGlzLmFyZ3VtZW50VHlwZXMucHVzaCh0eXBlKTtcbiAgICAgICAgICB0aGlzLmtlcm5lbEFyZ3VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJndW1lbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmtlcm5lbEFyZ3VtZW50cy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0aGlzLmFyZ3VtZW50VHlwZXNbaV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hcmd1bWVudFNpemVzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICB0aGlzLmFyZ3VtZW50Qml0UmF0aW9zID0gbmV3IEludDMyQXJyYXkoYXJncy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgICAgdGhpcy5hcmd1bWVudFNpemVzW2ldID0gYXJnLmNvbnN0cnVjdG9yID09PSBJbnB1dCA/IGFyZy5zaXplIDogbnVsbDtcbiAgICAgIHRoaXMuYXJndW1lbnRCaXRSYXRpb3NbaV0gPSB0aGlzLmdldEJpdFJhdGlvKGFyZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyZ3VtZW50cyBhcmUgbWlzcy1hbGlnbmVkYCk7XG4gICAgfVxuICB9XG5cbiAgc2V0dXBDb25zdGFudHMoKSB7XG4gICAgdGhpcy5rZXJuZWxDb25zdGFudHMgPSBbXTtcbiAgICBsZXQgbmVlZHNDb25zdGFudFR5cGVzID0gdGhpcy5jb25zdGFudFR5cGVzID09PSBudWxsO1xuICAgIGlmIChuZWVkc0NvbnN0YW50VHlwZXMpIHtcbiAgICAgIHRoaXMuY29uc3RhbnRUeXBlcyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmNvbnN0YW50Qml0UmF0aW9zID0ge307XG4gICAgaWYgKHRoaXMuY29uc3RhbnRzKSB7XG4gICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuY29uc3RhbnRzKSB7XG4gICAgICAgIGlmIChuZWVkc0NvbnN0YW50VHlwZXMpIHtcbiAgICAgICAgICBjb25zdCB0eXBlID0gdXRpbHMuZ2V0VmFyaWFibGVUeXBlKHRoaXMuY29uc3RhbnRzW25hbWVdLCB0aGlzLnN0cmljdEludGVnZXJzKTtcbiAgICAgICAgICB0aGlzLmNvbnN0YW50VHlwZXNbbmFtZV0gPSB0eXBlO1xuICAgICAgICAgIHRoaXMua2VybmVsQ29uc3RhbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmtlcm5lbENvbnN0YW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmNvbnN0YW50VHlwZXNbbmFtZV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnN0YW50Qml0UmF0aW9zW25hbWVdID0gdGhpcy5nZXRCaXRSYXRpbyh0aGlzLmNvbnN0YW50c1tuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0T3B0aW1pemVGbG9hdE1lbW9yeShmbGFnKSB7XG4gICAgdGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5ID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRvS2VybmVsT3V0cHV0KG91dHB1dCkge1xuICAgIGlmIChvdXRwdXQuaGFzT3duUHJvcGVydHkoJ3gnKSkge1xuICAgICAgaWYgKG91dHB1dC5oYXNPd25Qcm9wZXJ0eSgneScpKSB7XG4gICAgICAgIGlmIChvdXRwdXQuaGFzT3duUHJvcGVydHkoJ3onKSkge1xuICAgICAgICAgIHJldHVybiBbb3V0cHV0LngsIG91dHB1dC55LCBvdXRwdXQuel07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtvdXRwdXQueCwgb3V0cHV0LnldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW291dHB1dC54XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gIH1cblxuICBzZXRPdXRwdXQob3V0cHV0KSB7XG4gICAgdGhpcy5vdXRwdXQgPSB0aGlzLnRvS2VybmVsT3V0cHV0KG91dHB1dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXREZWJ1ZyhmbGFnKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRHcmFwaGljYWwoZmxhZykge1xuICAgIHRoaXMuZ3JhcGhpY2FsID0gZmxhZztcbiAgICB0aGlzLnByZWNpc2lvbiA9ICd1bnNpZ25lZCc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRMb29wTWF4SXRlcmF0aW9ucyhtYXgpIHtcbiAgICB0aGlzLmxvb3BNYXhJdGVyYXRpb25zID0gbWF4O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0Q29uc3RhbnRzKGNvbnN0YW50cykge1xuICAgIHRoaXMuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0Q29uc3RhbnRUeXBlcyhjb25zdGFudFR5cGVzKSB7XG4gICAgdGhpcy5jb25zdGFudFR5cGVzID0gY29uc3RhbnRUeXBlcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEZ1bmN0aW9ucyhmdW5jdGlvbnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hZGRGdW5jdGlvbihmdW5jdGlvbnNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldE5hdGl2ZUZ1bmN0aW9ucyhuYXRpdmVGdW5jdGlvbnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hdGl2ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSBuYXRpdmVGdW5jdGlvbnNbaV07XG4gICAgICBjb25zdCB7IG5hbWUsIHNvdXJjZSB9ID0gc2V0dGluZ3M7XG4gICAgICB0aGlzLmFkZE5hdGl2ZUZ1bmN0aW9uKG5hbWUsIHNvdXJjZSwgc2V0dGluZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEluamVjdGVkTmF0aXZlKGluamVjdGVkTmF0aXZlKSB7XG4gICAgdGhpcy5pbmplY3RlZE5hdGl2ZSA9IGluamVjdGVkTmF0aXZlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0UGlwZWxpbmUoZmxhZykge1xuICAgIHRoaXMucGlwZWxpbmUgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0UHJlY2lzaW9uKGZsYWcpIHtcbiAgICB0aGlzLnByZWNpc2lvbiA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXREaW1lbnNpb25zKGZsYWcpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnbWV0aG9kJywgJ3NldERpbWVuc2lvbnMnLCAnc2V0T3V0cHV0Jyk7XG4gICAgdGhpcy5vdXRwdXQgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0T3V0cHV0VG9UZXh0dXJlKGZsYWcpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnbWV0aG9kJywgJ3NldE91dHB1dFRvVGV4dHVyZScsICdzZXRQaXBlbGluZScpO1xuICAgIHRoaXMucGlwZWxpbmUgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0SW1tdXRhYmxlKGZsYWcpIHtcbiAgICB0aGlzLmltbXV0YWJsZSA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRDYW52YXMoY2FudmFzKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRTdHJpY3RJbnRlZ2VycyhmbGFnKSB7XG4gICAgdGhpcy5zdHJpY3RJbnRlZ2VycyA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXREeW5hbWljT3V0cHV0KGZsYWcpIHtcbiAgICB0aGlzLmR5bmFtaWNPdXRwdXQgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0SGFyZGNvZGVDb25zdGFudHMoZmxhZykge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdtZXRob2QnLCAnc2V0SGFyZGNvZGVDb25zdGFudHMnKTtcbiAgICB0aGlzLnNldER5bmFtaWNPdXRwdXQoZmxhZyk7XG4gICAgdGhpcy5zZXREeW5hbWljQXJndW1lbnRzKGZsYWcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RHluYW1pY0FyZ3VtZW50cyhmbGFnKSB7XG4gICAgdGhpcy5keW5hbWljQXJndW1lbnRzID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFVzZUxlZ2FjeUVuY29kZXIoZmxhZykge1xuICAgIHRoaXMudXNlTGVnYWN5RW5jb2RlciA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRXYXJuVmFyVXNhZ2UoZmxhZykge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdtZXRob2QnLCAnc2V0V2FyblZhclVzYWdlJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRDYW52YXMoKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdnZXRDYW52YXMnKTtcbiAgICByZXR1cm4gdGhpcy5jYW52YXM7XG4gIH1cblxuICBnZXRXZWJHbCgpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnbWV0aG9kJywgJ2dldFdlYkdsJyk7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dDtcbiAgfVxuXG4gIHNldENvbnRleHQoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRBcmd1bWVudFR5cGVzKGFyZ3VtZW50VHlwZXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudFR5cGVzKSkge1xuICAgICAgdGhpcy5hcmd1bWVudFR5cGVzID0gYXJndW1lbnRUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcmd1bWVudFR5cGVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHAgaW4gYXJndW1lbnRUeXBlcykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50VHlwZXMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBhcmd1bWVudEluZGV4ID0gdGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YocCk7XG4gICAgICAgIGlmIChhcmd1bWVudEluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKGB1bmFibGUgdG8gZmluZCBhcmd1bWVudCAkeyBwIH1gKTtcbiAgICAgICAgdGhpcy5hcmd1bWVudFR5cGVzW2FyZ3VtZW50SW5kZXhdID0gYXJndW1lbnRUeXBlc1twXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRUYWN0aWModGFjdGljKSB7XG4gICAgdGhpcy50YWN0aWMgPSB0YWN0aWM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXF1ZXN0RmFsbGJhY2soYXJncykge1xuICAgIGlmICghdGhpcy5vblJlcXVlc3RGYWxsYmFjaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIm9uUmVxdWVzdEZhbGxiYWNrXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgICB9XG4gICAgdGhpcy5mYWxsYmFja1JlcXVlc3RlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMub25SZXF1ZXN0RmFsbGJhY2soYXJncyk7XG4gIH1cblxuICB2YWxpZGF0ZVNldHRpbmdzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJ2YWxpZGF0ZVNldHRpbmdzXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIGFkZFN1Yktlcm5lbChzdWJLZXJuZWwpIHtcbiAgICBpZiAodGhpcy5zdWJLZXJuZWxzID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN1Yktlcm5lbHMgPSBbXTtcbiAgICB9XG4gICAgaWYgKCFzdWJLZXJuZWwuc291cmNlKSB0aHJvdyBuZXcgRXJyb3IoJ3N1Yktlcm5lbCBtaXNzaW5nIFwic291cmNlXCIgcHJvcGVydHknKTtcbiAgICBpZiAoIXN1Yktlcm5lbC5wcm9wZXJ0eSAmJiBpc05hTihzdWJLZXJuZWwucHJvcGVydHkpKSB0aHJvdyBuZXcgRXJyb3IoJ3N1Yktlcm5lbCBtaXNzaW5nIFwicHJvcGVydHlcIiBwcm9wZXJ0eScpO1xuICAgIGlmICghc3ViS2VybmVsLm5hbWUpIHRocm93IG5ldyBFcnJvcignc3ViS2VybmVsIG1pc3NpbmcgXCJuYW1lXCIgcHJvcGVydHknKTtcbiAgICB0aGlzLnN1Yktlcm5lbHMucHVzaChzdWJLZXJuZWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGVzdHJveShyZW1vdmVDYW52YXNSZWZlcmVuY2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImRlc3Ryb3lcIiBjYWxsZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIGdldEJpdFJhdGlvKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgcmV0dXJuIDQ7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qml0UmF0aW8odmFsdWVbMF0pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IElucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCaXRSYXRpbyh2YWx1ZS52YWx1ZSk7XG4gICAgfVxuICAgIHN3aXRjaCAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgVWludDhDbGFtcGVkQXJyYXk6XG4gICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICBjYXNlIEludDhBcnJheTpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgICByZXR1cm4gMjtcbiAgICAgIGNhc2UgRmxvYXQzMkFycmF5OlxuICAgICAgY2FzZSBJbnQzMkFycmF5OlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0UGl4ZWxzKGZsaXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZ2V0UGl4ZWxzXCIgY2FsbGVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBjaGVja091dHB1dCgpIHtcbiAgICBpZiAoIXRoaXMub3V0cHV0IHx8ICF1dGlscy5pc0FycmF5KHRoaXMub3V0cHV0KSkgdGhyb3cgbmV3IEVycm9yKCdrZXJuZWwub3V0cHV0IG5vdCBhbiBhcnJheScpO1xuICAgIGlmICh0aGlzLm91dHB1dC5sZW5ndGggPCAxKSB0aHJvdyBuZXcgRXJyb3IoJ2tlcm5lbC5vdXRwdXQgaXMgZW1wdHksIG5lZWRzIGF0IGxlYXN0IDEgdmFsdWUnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3V0cHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXNOYU4odGhpcy5vdXRwdXRbaV0pIHx8IHRoaXMub3V0cHV0W2ldIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9Lm91dHB1dFskeyBpIH1dIGluY29ycmVjdGx5IGRlZmluZWQgYXMgXFxgJHsgdGhpcy5vdXRwdXRbaV0gfVxcYCwgbmVlZHMgdG8gYmUgbnVtZXJpYywgYW5kIGdyZWF0ZXIgdGhhbiAwYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJlcGVuZFN0cmluZyh2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJwcmVwZW5kU3RyaW5nXCIgY2FsbGVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBoYXNQcmVwZW5kU3RyaW5nKHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImhhc1ByZXBlbmRTdHJpbmdcIiBjYWxsZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgICAgcGlwZWxpbmU6IHRoaXMucGlwZWxpbmUsXG4gICAgICAgIGFyZ3VtZW50TmFtZXM6IHRoaXMuYXJndW1lbnROYW1lcyxcbiAgICAgICAgYXJndW1lbnRzVHlwZXM6IHRoaXMuYXJndW1lbnRUeXBlcyxcbiAgICAgICAgY29uc3RhbnRzOiB0aGlzLmNvbnN0YW50cyxcbiAgICAgICAgcGx1Z2luTmFtZXM6IHRoaXMucGx1Z2lucyA/IHRoaXMucGx1Z2lucy5tYXAocGx1Z2luID0+IHBsdWdpbi5uYW1lKSA6IG51bGwsXG4gICAgICAgIHJldHVyblR5cGU6IHRoaXMucmV0dXJuVHlwZSxcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgYnVpbGRTaWduYXR1cmUoYXJncykge1xuICAgIGNvbnN0IENvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IENvbnN0cnVjdG9yLmdldFNpZ25hdHVyZSh0aGlzLCBDb25zdHJ1Y3Rvci5nZXRBcmd1bWVudFR5cGVzKHRoaXMsIGFyZ3MpKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRBcmd1bWVudFR5cGVzKGtlcm5lbCwgYXJncykge1xuICAgIGNvbnN0IGFyZ3VtZW50VHlwZXMgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXJnID0gYXJnc1tpXTtcbiAgICAgIGNvbnN0IHR5cGUgPSBrZXJuZWwuYXJndW1lbnRUeXBlc1tpXTtcbiAgICAgIGlmIChhcmcudHlwZSkge1xuICAgICAgICBhcmd1bWVudFR5cGVzW2ldID0gYXJnLnR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMSknOlxuICAgICAgICAgICAgYXJndW1lbnRUeXBlc1tpXSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZShhcmcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGFyZ3VtZW50VHlwZXNbaV0gPSB0eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmd1bWVudFR5cGVzO1xuICB9XG5cbiAgc3RhdGljIGdldFNpZ25hdHVyZShrZXJuZWwsIGFyZ3VtZW50VHlwZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZ2V0U2lnbmF0dXJlXCIgbm90IGltcGxlbWVudGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBmdW5jdGlvblRvSUdQVUZ1bmN0aW9uKHNvdXJjZSwgc2V0dGluZ3MgPSB7fSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc291cmNlICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBub3QgYSBzdHJpbmcgb3IgZnVuY3Rpb24nKTtcbiAgICBjb25zdCBzb3VyY2VTdHJpbmcgPSB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IHNvdXJjZSA6IHNvdXJjZS50b1N0cmluZygpO1xuICAgIGxldCBhcmd1bWVudFR5cGVzID0gW107XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZXR0aW5ncy5hcmd1bWVudFR5cGVzKSkge1xuICAgICAgYXJndW1lbnRUeXBlcyA9IHNldHRpbmdzLmFyZ3VtZW50VHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0dGluZ3MuYXJndW1lbnRUeXBlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGFyZ3VtZW50VHlwZXMgPSB1dGlscy5nZXRBcmd1bWVudE5hbWVzRnJvbVN0cmluZyhzb3VyY2VTdHJpbmcpXG4gICAgICAgIC5tYXAobmFtZSA9PiBzZXR0aW5ncy5hcmd1bWVudFR5cGVzW25hbWVdKSB8fCBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJndW1lbnRUeXBlcyA9IHNldHRpbmdzLmFyZ3VtZW50VHlwZXMgfHwgW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHV0aWxzLmdldEZ1bmN0aW9uTmFtZUZyb21TdHJpbmcoc291cmNlU3RyaW5nKSB8fCBudWxsLFxuICAgICAgc291cmNlOiBzb3VyY2VTdHJpbmcsXG4gICAgICBhcmd1bWVudFR5cGVzLFxuICAgICAgcmV0dXJuVHlwZTogc2V0dGluZ3MucmV0dXJuVHlwZSB8fCBudWxsLFxuICAgIH07XG4gIH1cblxuICBvbkFjdGl2YXRlKHByZXZpb3VzS2VybmVsKSB7fVxufVxuXG5mdW5jdGlvbiBzcGxpdEFyZ3VtZW50VHlwZXMoYXJndW1lbnRUeXBlc09iamVjdCkge1xuICBjb25zdCBhcmd1bWVudE5hbWVzID0gT2JqZWN0LmtleXMoYXJndW1lbnRUeXBlc09iamVjdCk7XG4gIGNvbnN0IGFyZ3VtZW50VHlwZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJndW1lbnROYW1lID0gYXJndW1lbnROYW1lc1tpXTtcbiAgICBhcmd1bWVudFR5cGVzLnB1c2goYXJndW1lbnRUeXBlc09iamVjdFthcmd1bWVudE5hbWVdKTtcbiAgfVxuICByZXR1cm4geyBhcmd1bWVudFR5cGVzLCBhcmd1bWVudE5hbWVzIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBLZXJuZWxcbn07XG59LHtcIi4uL2lucHV0XCI6MTEwLFwiLi4vdXRpbHNcIjoxMTR9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBmcmFnbWVudFNoYWRlciA9IGBfX0hFQURFUl9fO1xuX19GTE9BVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fSU5UX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuX19TQU1QTEVSXzJEX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuXG5jb25zdCBpbnQgTE9PUF9NQVggPSBfX0xPT1BfTUFYX187XG5cbl9fUExVR0lOU19fO1xuX19DT05TVEFOVFNfXztcblxudmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcblxuZmxvYXQgYWNvc2goZmxvYXQgeCkge1xuICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4IC0gMS4wKSk7XG59XG5cbmZsb2F0IHNpbmgoZmxvYXQgeCkge1xuICByZXR1cm4gKHBvdygke01hdGguRX0sIHgpIC0gcG93KCR7TWF0aC5FfSwgLXgpKSAvIDIuMDtcbn1cblxuZmxvYXQgYXNpbmgoZmxvYXQgeCkge1xuICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4ICsgMS4wKSk7XG59XG5cbmZsb2F0IGF0YW4yKGZsb2F0IHYxLCBmbG9hdCB2Mikge1xuICBpZiAodjEgPT0gMC4wIHx8IHYyID09IDAuMCkgcmV0dXJuIDAuMDtcbiAgcmV0dXJuIGF0YW4odjEgLyB2Mik7XG59XG5cbmZsb2F0IGF0YW5oKGZsb2F0IHgpIHtcbiAgeCA9ICh4ICsgMS4wKSAvICh4IC0gMS4wKTtcbiAgaWYgKHggPCAwLjApIHtcbiAgICByZXR1cm4gMC41ICogbG9nKC14KTtcbiAgfVxuICByZXR1cm4gMC41ICogbG9nKHgpO1xufVxuXG5mbG9hdCBjYnJ0KGZsb2F0IHgpIHtcbiAgaWYgKHggPj0gMC4wKSB7XG4gICAgcmV0dXJuIHBvdyh4LCAxLjAgLyAzLjApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAtcG93KHgsIDEuMCAvIDMuMCk7XG4gIH1cbn1cblxuZmxvYXQgY29zaChmbG9hdCB4KSB7XG4gIHJldHVybiAocG93KCR7TWF0aC5FfSwgeCkgKyBwb3coJHtNYXRoLkV9LCAteCkpIC8gMi4wOyBcbn1cblxuZmxvYXQgZXhwbTEoZmxvYXQgeCkge1xuICByZXR1cm4gcG93KCR7TWF0aC5FfSwgeCkgLSAxLjA7IFxufVxuXG5mbG9hdCBmcm91bmQoaGlnaHAgZmxvYXQgeCkge1xuICByZXR1cm4geDtcbn1cblxuZmxvYXQgaW11bChmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgcmV0dXJuIGZsb2F0KGludCh2MSkgKiBpbnQodjIpKTtcbn1cblxuZmxvYXQgbG9nMTAoZmxvYXQgeCkge1xuICByZXR1cm4gbG9nMih4KSAqICgxLjAgLyBsb2cyKDEwLjApKTtcbn1cblxuZmxvYXQgbG9nMXAoZmxvYXQgeCkge1xuICByZXR1cm4gbG9nKDEuMCArIHgpO1xufVxuXG5mbG9hdCBfcG93KGZsb2F0IHYxLCBmbG9hdCB2Mikge1xuICBpZiAodjIgPT0gMC4wKSByZXR1cm4gMS4wO1xuICByZXR1cm4gcG93KHYxLCB2Mik7XG59XG5cbmZsb2F0IHRhbmgoZmxvYXQgeCkge1xuICBmbG9hdCBlID0gZXhwKDIuMCAqIHgpO1xuICByZXR1cm4gKGUgLSAxLjApIC8gKGUgKyAxLjApO1xufVxuXG5mbG9hdCB0cnVuYyhmbG9hdCB4KSB7XG4gIGlmICh4ID49IDAuMCkge1xuICAgIHJldHVybiBmbG9vcih4KTsgXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNlaWwoeCk7XG4gIH1cbn1cblxudmVjNCBfcm91bmQodmVjNCB4KSB7XG4gIHJldHVybiBmbG9vcih4ICsgMC41KTtcbn1cblxuZmxvYXQgX3JvdW5kKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGZsb29yKHggKyAwLjUpO1xufVxuXG5jb25zdCBpbnQgQklUX0NPVU5UID0gMzI7XG5pbnQgbW9kaShpbnQgeCwgaW50IHkpIHtcbiAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcbn1cblxuaW50IGJpdHdpc2VPcihpbnQgYSwgaW50IGIpIHtcbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBuID0gMTtcbiAgXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoKG1vZGkoYSwgMikgPT0gMSkgfHwgKG1vZGkoYiwgMikgPT0gMSkpIHtcbiAgICAgIHJlc3VsdCArPSBuO1xuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgYiA9IGIgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgICBpZighKGEgPiAwIHx8IGIgPiAwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZVhPUihpbnQgYSwgaW50IGIpIHtcbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBuID0gMTtcbiAgXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoKG1vZGkoYSwgMikgPT0gMSkgIT0gKG1vZGkoYiwgMikgPT0gMSkpIHtcbiAgICAgIHJlc3VsdCArPSBuO1xuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgYiA9IGIgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgICBpZighKGEgPiAwIHx8IGIgPiAwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZUFuZChpbnQgYSwgaW50IGIpIHtcbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBuID0gMTtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmICgobW9kaShhLCAyKSA9PSAxKSAmJiAobW9kaShiLCAyKSA9PSAxKSkge1xuICAgICAgcmVzdWx0ICs9IG47XG4gICAgfVxuICAgIGEgPSBhIC8gMjtcbiAgICBiID0gYiAvIDI7XG4gICAgbiA9IG4gKiAyO1xuICAgIGlmKCEoYSA+IDAgJiYgYiA+IDApKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmludCBiaXR3aXNlTm90KGludCBhKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKG1vZGkoYSwgMikgPT0gMCkge1xuICAgICAgcmVzdWx0ICs9IG47ICAgIFxuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgbiA9IG4gKiAyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZVplcm9GaWxsTGVmdFNoaWZ0KGludCBuLCBpbnQgc2hpZnQpIHtcbiAgaW50IG1heEJ5dGVzID0gQklUX0NPVU5UO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKG1heEJ5dGVzID49IG4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXhCeXRlcyAqPSAyO1xuICB9XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoaSA+PSBzaGlmdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG4gKj0gMjtcbiAgfVxuXG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgYnl0ZVZhbCA9IDE7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoaSA+PSBtYXhCeXRlcykgYnJlYWs7XG4gICAgaWYgKG1vZGkobiwgMikgPiAwKSB7IHJlc3VsdCArPSBieXRlVmFsOyB9XG4gICAgbiA9IGludChuIC8gMik7XG4gICAgYnl0ZVZhbCAqPSAyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmludCBiaXR3aXNlU2lnbmVkUmlnaHRTaGlmdChpbnQgbnVtLCBpbnQgc2hpZnRzKSB7XG4gIHJldHVybiBpbnQoZmxvb3IoZmxvYXQobnVtKSAvIHBvdygyLjAsIGZsb2F0KHNoaWZ0cykpKSk7XG59XG5cbmludCBiaXR3aXNlWmVyb0ZpbGxSaWdodFNoaWZ0KGludCBuLCBpbnQgc2hpZnQpIHtcbiAgaW50IG1heEJ5dGVzID0gQklUX0NPVU5UO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKG1heEJ5dGVzID49IG4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXhCeXRlcyAqPSAyO1xuICB9XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoaSA+PSBzaGlmdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG4gLz0gMjtcbiAgfVxuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IGJ5dGVWYWwgPSAxO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gbWF4Qnl0ZXMpIGJyZWFrO1xuICAgIGlmIChtb2RpKG4sIDIpID4gMCkgeyByZXN1bHQgKz0gYnl0ZVZhbDsgfVxuICAgIG4gPSBpbnQobiAvIDIpO1xuICAgIGJ5dGVWYWwgKj0gMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52ZWMyIGludGVnZXJNb2QodmVjMiB4LCBmbG9hdCB5KSB7XG4gIHZlYzIgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG52ZWMzIGludGVnZXJNb2QodmVjMyB4LCBmbG9hdCB5KSB7XG4gIHZlYzMgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG52ZWM0IGludGVnZXJNb2QodmVjNCB4LCB2ZWM0IHkpIHtcbiAgdmVjNCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogc3RlcCgxLjAgLSBmbG9vcih5KSwgLXJlcyk7XG59XG5cbmZsb2F0IGludGVnZXJNb2QoZmxvYXQgeCwgZmxvYXQgeSkge1xuICBmbG9hdCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogKHJlcyA+IGZsb29yKHkpIC0gMS4wID8gMC4wIDogMS4wKTtcbn1cblxuaW50IGludGVnZXJNb2QoaW50IHgsIGludCB5KSB7XG4gIHJldHVybiB4IC0gKHkgKiBpbnQoeCAvIHkpKTtcbn1cblxuX19ESVZJREVfV0lUSF9JTlRFR0VSX0NIRUNLX187XG5cbi8vIEhlcmUgYmUgZHJhZ29ucyFcbi8vIERPIE5PVCBPUFRJTUlaRSBUSElTIENPREVcbi8vIFlPVSBXSUxMIEJSRUFLIFNPTUVUSElORyBPTiBTT01FQk9EWVxcJ1MgTUFDSElORVxuLy8gTEVBVkUgSVQgQVMgSVQgSVMsIExFU1QgWU9VIFdBU1RFIFlPVVIgT1dOIFRJTUVcbmNvbnN0IHZlYzIgTUFHSUNfVkVDID0gdmVjMigxLjAsIC0yNTYuMCk7XG5jb25zdCB2ZWM0IFNDQUxFX0ZBQ1RPUiA9IHZlYzQoMS4wLCAyNTYuMCwgNjU1MzYuMCwgMC4wKTtcbmNvbnN0IHZlYzQgU0NBTEVfRkFDVE9SX0lOViA9IHZlYzQoMS4wLCAwLjAwMzkwNjI1LCAwLjAwMDAxNTI1ODc4OTA2MjUsIDAuMCk7IC8vIDEsIDEvMjU2LCAxLzY1NTM2XG5mbG9hdCBkZWNvZGUzMih2ZWM0IHRleGVsKSB7XG4gIF9fREVDT0RFMzJfRU5ESUFOTkVTU19fO1xuICB0ZXhlbCAqPSAyNTUuMDtcbiAgdmVjMiBndGUxMjg7XG4gIGd0ZTEyOC54ID0gdGV4ZWwuYiA+PSAxMjguMCA/IDEuMCA6IDAuMDtcbiAgZ3RlMTI4LnkgPSB0ZXhlbC5hID49IDEyOC4wID8gMS4wIDogMC4wO1xuICBmbG9hdCBleHBvbmVudCA9IDIuMCAqIHRleGVsLmEgLSAxMjcuMCArIGRvdChndGUxMjgsIE1BR0lDX1ZFQyk7XG4gIGZsb2F0IHJlcyA9IGV4cDIoX3JvdW5kKGV4cG9uZW50KSk7XG4gIHRleGVsLmIgPSB0ZXhlbC5iIC0gMTI4LjAgKiBndGUxMjgueDtcbiAgcmVzID0gZG90KHRleGVsLCBTQ0FMRV9GQUNUT1IpICogZXhwMihfcm91bmQoZXhwb25lbnQtMjMuMCkpICsgcmVzO1xuICByZXMgKj0gZ3RlMTI4LnkgKiAtMi4wICsgMS4wO1xuICByZXR1cm4gcmVzO1xufVxuXG5mbG9hdCBkZWNvZGUxNih2ZWM0IHRleGVsLCBpbnQgaW5kZXgpIHtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCAyKTtcbiAgaWYgKGNoYW5uZWwgPT0gMCkgcmV0dXJuIHRleGVsLnIgKiAyNTUuMCArIHRleGVsLmcgKiA2NTI4MC4wO1xuICBpZiAoY2hhbm5lbCA9PSAxKSByZXR1cm4gdGV4ZWwuYiAqIDI1NS4wICsgdGV4ZWwuYSAqIDY1MjgwLjA7XG4gIHJldHVybiAwLjA7XG59XG5cbmZsb2F0IGRlY29kZTgodmVjNCB0ZXhlbCwgaW50IGluZGV4KSB7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgNCk7XG4gIGlmIChjaGFubmVsID09IDApIHJldHVybiB0ZXhlbC5yICogMjU1LjA7XG4gIGlmIChjaGFubmVsID09IDEpIHJldHVybiB0ZXhlbC5nICogMjU1LjA7XG4gIGlmIChjaGFubmVsID09IDIpIHJldHVybiB0ZXhlbC5iICogMjU1LjA7XG4gIGlmIChjaGFubmVsID09IDMpIHJldHVybiB0ZXhlbC5hICogMjU1LjA7XG4gIHJldHVybiAwLjA7XG59XG5cbnZlYzQgbGVnYWN5RW5jb2RlMzIoZmxvYXQgZikge1xuICBmbG9hdCBGID0gYWJzKGYpO1xuICBmbG9hdCBzaWduID0gZiA8IDAuMCA/IDEuMCA6IDAuMDtcbiAgZmxvYXQgZXhwb25lbnQgPSBmbG9vcihsb2cyKEYpKTtcbiAgZmxvYXQgbWFudGlzc2EgPSAoZXhwMigtZXhwb25lbnQpICogRik7XG4gIC8vIGV4cG9uZW50ICs9IGZsb29yKGxvZzIobWFudGlzc2EpKTtcbiAgdmVjNCB0ZXhlbCA9IHZlYzQoRiAqIGV4cDIoMjMuMC1leHBvbmVudCkpICogU0NBTEVfRkFDVE9SX0lOVjtcbiAgdGV4ZWwucmcgPSBpbnRlZ2VyTW9kKHRleGVsLnJnLCAyNTYuMCk7XG4gIHRleGVsLmIgPSBpbnRlZ2VyTW9kKHRleGVsLmIsIDEyOC4wKTtcbiAgdGV4ZWwuYSA9IGV4cG9uZW50KjAuNSArIDYzLjU7XG4gIHRleGVsLmJhICs9IHZlYzIoaW50ZWdlck1vZChleHBvbmVudCsxMjcuMCwgMi4wKSwgc2lnbikgKiAxMjguMDtcbiAgdGV4ZWwgPSBmbG9vcih0ZXhlbCk7XG4gIHRleGVsICo9IDAuMDAzOTIxNTY5OyAvLyAxLzI1NVxuICBfX0VOQ09ERTMyX0VORElBTk5FU1NfXztcbiAgcmV0dXJuIHRleGVsO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ3B1anMvZ3B1LmpzL3dpa2kvRW5jb2Rlci1kZXRhaWxzXG52ZWM0IGVuY29kZTMyKGZsb2F0IHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSAwLjApIHJldHVybiB2ZWM0KDAsIDAsIDAsIDApO1xuXG4gIGZsb2F0IGV4cG9uZW50O1xuICBmbG9hdCBtYW50aXNzYTtcbiAgdmVjNCAgcmVzdWx0O1xuICBmbG9hdCBzZ247XG5cbiAgc2duID0gc3RlcCgwLjAsIC12YWx1ZSk7XG4gIHZhbHVlID0gYWJzKHZhbHVlKTtcblxuICBleHBvbmVudCA9IGZsb29yKGxvZzIodmFsdWUpKTtcblxuICBtYW50aXNzYSA9IHZhbHVlKnBvdygyLjAsIC1leHBvbmVudCktMS4wO1xuICBleHBvbmVudCA9IGV4cG9uZW50KzEyNy4wO1xuICByZXN1bHQgICA9IHZlYzQoMCwwLDAsMCk7XG5cbiAgcmVzdWx0LmEgPSBmbG9vcihleHBvbmVudC8yLjApO1xuICBleHBvbmVudCA9IGV4cG9uZW50IC0gcmVzdWx0LmEqMi4wO1xuICByZXN1bHQuYSA9IHJlc3VsdC5hICsgMTI4LjAqc2duO1xuXG4gIHJlc3VsdC5iID0gZmxvb3IobWFudGlzc2EgKiAxMjguMCk7XG4gIG1hbnRpc3NhID0gbWFudGlzc2EgLSByZXN1bHQuYiAvIDEyOC4wO1xuICByZXN1bHQuYiA9IHJlc3VsdC5iICsgZXhwb25lbnQqMTI4LjA7XG5cbiAgcmVzdWx0LmcgPSBmbG9vcihtYW50aXNzYSozMjc2OC4wKTtcbiAgbWFudGlzc2EgPSBtYW50aXNzYSAtIHJlc3VsdC5nLzMyNzY4LjA7XG5cbiAgcmVzdWx0LnIgPSBmbG9vcihtYW50aXNzYSo4Mzg4NjA4LjApO1xuICByZXR1cm4gcmVzdWx0LzI1NS4wO1xufVxuLy8gRHJhZ29ucyBlbmQgaGVyZVxuXG5pbnQgaW5kZXg7XG5pdmVjMyB0aHJlYWRJZDtcblxuaXZlYzMgaW5kZXhUbzNEKGludCBpZHgsIGl2ZWMzIHRleERpbSkge1xuICBpbnQgeiA9IGludChpZHggLyAodGV4RGltLnggKiB0ZXhEaW0ueSkpO1xuICBpZHggLT0geiAqIGludCh0ZXhEaW0ueCAqIHRleERpbS55KTtcbiAgaW50IHkgPSBpbnQoaWR4IC8gdGV4RGltLngpO1xuICBpbnQgeCA9IGludChpbnRlZ2VyTW9kKGlkeCwgdGV4RGltLngpKTtcbiAgcmV0dXJuIGl2ZWMzKHgsIHksIHopO1xufVxuXG5mbG9hdCBnZXQzMihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIHJldHVybiBkZWNvZGUzMih0ZXhlbCk7XG59XG5cbmZsb2F0IGdldDE2KHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCB3ID0gdGV4U2l6ZS54ICogMjtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplLnggKiAyLCB0ZXhTaXplLnkpKTtcbiAgcmV0dXJuIGRlY29kZTE2KHRleGVsLCBpbmRleCk7XG59XG5cbmZsb2F0IGdldDgoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IHcgPSB0ZXhTaXplLnggKiA0O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHRleCwgc3QgLyB2ZWMyKHRleFNpemUueCAqIDQsIHRleFNpemUueSkpO1xuICByZXR1cm4gZGVjb2RlOCh0ZXhlbCwgaW5kZXgpO1xufVxuXG5mbG9hdCBnZXRNZW1vcnlPcHRpbWl6ZWQzMihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDQpO1xuICBpbmRleCA9IGluZGV4IC8gNDtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodGV4LCBzdCAvIHZlYzIodGV4U2l6ZSkpO1xuICBpZiAoY2hhbm5lbCA9PSAwKSByZXR1cm4gdGV4ZWwucjtcbiAgaWYgKGNoYW5uZWwgPT0gMSkgcmV0dXJuIHRleGVsLmc7XG4gIGlmIChjaGFubmVsID09IDIpIHJldHVybiB0ZXhlbC5iO1xuICBpZiAoY2hhbm5lbCA9PSAzKSByZXR1cm4gdGV4ZWwuYTtcbiAgcmV0dXJuIDAuMDtcbn1cblxudmVjNCBnZXRJbWFnZTJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICByZXR1cm4gdGV4dHVyZTJEKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbn1cblxuZmxvYXQgZ2V0RmxvYXRGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gcmVzdWx0WzBdO1xufVxuXG52ZWMyIGdldFZlYzJGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gdmVjMihyZXN1bHRbMF0sIHJlc3VsdFsxXSk7XG59XG5cbnZlYzIgZ2V0TWVtb3J5T3B0aW1pemVkVmVjMihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArICh0ZXhEaW0ueCAqICh5ICsgKHRleERpbS55ICogeikpKTtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCAyKTtcbiAgaW5kZXggPSBpbmRleCAvIDI7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgaWYgKGNoYW5uZWwgPT0gMCkgcmV0dXJuIHZlYzIodGV4ZWwuciwgdGV4ZWwuZyk7XG4gIGlmIChjaGFubmVsID09IDEpIHJldHVybiB2ZWMyKHRleGVsLmIsIHRleGVsLmEpO1xuICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG59XG5cbnZlYzMgZ2V0VmVjM0Zyb21TYW1wbGVyMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIHZlYzQgcmVzdWx0ID0gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgeiwgeSwgeCk7XG4gIHJldHVybiB2ZWMzKHJlc3VsdFswXSwgcmVzdWx0WzFdLCByZXN1bHRbMl0pO1xufVxuXG52ZWMzIGdldE1lbW9yeU9wdGltaXplZFZlYzMoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBmaWVsZEluZGV4ID0gMyAqICh4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeikpO1xuICBpbnQgdmVjdG9ySW5kZXggPSBmaWVsZEluZGV4IC8gNDtcbiAgaW50IHZlY3Rvck9mZnNldCA9IGZpZWxkSW5kZXggLSB2ZWN0b3JJbmRleCAqIDQ7XG4gIGludCByZWFkWSA9IHZlY3RvckluZGV4IC8gdGV4U2l6ZS54O1xuICBpbnQgcmVhZFggPSB2ZWN0b3JJbmRleCAtIHJlYWRZICogdGV4U2l6ZS54O1xuICB2ZWM0IHRleDEgPSB0ZXh0dXJlMkQodGV4LCAodmVjMihyZWFkWCwgcmVhZFkpICsgMC41KSAvIHZlYzIodGV4U2l6ZSkpO1xuICBcbiAgaWYgKHZlY3Rvck9mZnNldCA9PSAwKSB7XG4gICAgcmV0dXJuIHRleDEueHl6O1xuICB9IGVsc2UgaWYgKHZlY3Rvck9mZnNldCA9PSAxKSB7XG4gICAgcmV0dXJuIHRleDEueXp3O1xuICB9IGVsc2Uge1xuICAgIHJlYWRYKys7XG4gICAgaWYgKHJlYWRYID49IHRleFNpemUueCkge1xuICAgICAgcmVhZFggPSAwO1xuICAgICAgcmVhZFkrKztcbiAgICB9XG4gICAgdmVjNCB0ZXgyID0gdGV4dHVyZTJEKHRleCwgdmVjMihyZWFkWCwgcmVhZFkpIC8gdmVjMih0ZXhTaXplKSk7XG4gICAgaWYgKHZlY3Rvck9mZnNldCA9PSAyKSB7XG4gICAgICByZXR1cm4gdmVjMyh0ZXgxLnosIHRleDEudywgdGV4Mi54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZlYzModGV4MS53LCB0ZXgyLngsIHRleDIueSk7XG4gICAgfVxuICB9XG59XG5cbnZlYzQgZ2V0VmVjNEZyb21TYW1wbGVyMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIHJldHVybiBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbn1cblxudmVjNCBnZXRNZW1vcnlPcHRpbWl6ZWRWZWM0KHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgMik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgcmV0dXJuIHZlYzQodGV4ZWwuciwgdGV4ZWwuZywgdGV4ZWwuYiwgdGV4ZWwuYSk7XG59XG5cbnZlYzQgYWN0dWFsQ29sb3I7XG52b2lkIGNvbG9yKGZsb2F0IHIsIGZsb2F0IGcsIGZsb2F0IGIsIGZsb2F0IGEpIHtcbiAgYWN0dWFsQ29sb3IgPSB2ZWM0KHIsZyxiLGEpO1xufVxuXG52b2lkIGNvbG9yKGZsb2F0IHIsIGZsb2F0IGcsIGZsb2F0IGIpIHtcbiAgY29sb3IocixnLGIsMS4wKTtcbn1cblxudm9pZCBjb2xvcihzYW1wbGVyMkQgaW1hZ2UpIHtcbiAgYWN0dWFsQ29sb3IgPSB0ZXh0dXJlMkQoaW1hZ2UsIHZUZXhDb29yZCk7XG59XG5cbmZsb2F0IG1vZHVsbyhmbG9hdCBudW1iZXIsIGZsb2F0IGRpdmlzb3IpIHtcbiAgaWYgKG51bWJlciA8IDAuMCkge1xuICAgIG51bWJlciA9IGFicyhudW1iZXIpO1xuICAgIGlmIChkaXZpc29yIDwgMC4wKSB7XG4gICAgICBkaXZpc29yID0gYWJzKGRpdmlzb3IpO1xuICAgIH1cbiAgICByZXR1cm4gLW1vZChudW1iZXIsIGRpdmlzb3IpO1xuICB9XG4gIGlmIChkaXZpc29yIDwgMC4wKSB7XG4gICAgZGl2aXNvciA9IGFicyhkaXZpc29yKTtcbiAgfVxuICByZXR1cm4gbW9kKG51bWJlciwgZGl2aXNvcik7XG59XG5cbl9fSU5KRUNURURfTkFUSVZFX187XG5fX01BSU5fQ09OU1RBTlRTX187XG5fX01BSU5fQVJHVU1FTlRTX187XG5fX0tFUk5FTF9fO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBpbmRleCA9IGludCh2VGV4Q29vcmQucyAqIGZsb2F0KHVUZXhTaXplLngpKSArIGludCh2VGV4Q29vcmQudCAqIGZsb2F0KHVUZXhTaXplLnkpKSAqIHVUZXhTaXplLng7XG4gIF9fTUFJTl9SRVNVTFRfXztcbn1gO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZnJhZ21lbnRTaGFkZXJcbn07XG59LHt9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgeyBGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uLW5vZGUnKTtcblxuY2xhc3MgV2ViR0xGdW5jdGlvbk5vZGUgZXh0ZW5kcyBGdW5jdGlvbk5vZGUge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc291cmNlLCBzZXR0aW5ncyk7XG4gICAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzLmhhc093blByb3BlcnR5KCdmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeScpKSB7XG4gICAgICB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gc2V0dGluZ3MuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3k7XG4gICAgfVxuICB9XG5cbiAgYXN0Q29uZGl0aW9uYWxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnTm90IGEgY29uZGl0aW9uYWwgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnNlcXVlbnRUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5jb25zZXF1ZW50KTtcbiAgICBjb25zdCBhbHRlcm5hdGVUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5hbHRlcm5hdGUpO1xuICAgIGlmIChjb25zZXF1ZW50VHlwZSA9PT0gbnVsbCAmJiBhbHRlcm5hdGVUeXBlID09PSBudWxsKSB7XG4gICAgICByZXRBcnIucHVzaCgnaWYgKCcpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC50ZXN0LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJykgeycpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJzsnKTtcbiAgICAgIHJldEFyci5wdXNoKCd9IGVsc2UgeycpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnOycpO1xuICAgICAgcmV0QXJyLnB1c2goJ30nKTtcbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCc/Jyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCc6Jyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0RnVuY3Rpb24oYXN0LCByZXRBcnIpIHtcbiAgICBpZiAodGhpcy5pc1Jvb3RLZXJuZWwpIHtcbiAgICAgIHJldEFyci5wdXNoKCd2b2lkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgIGNvbnN0IGxhc3RSZXR1cm4gPSB0aGlzLmZpbmRMYXN0UmV0dXJuKCk7XG4gICAgICAgIGlmIChsYXN0UmV0dXJuKSB7XG4gICAgICAgICAgdGhpcy5yZXR1cm5UeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5ib2R5KTtcbiAgICAgICAgICBpZiAodGhpcy5yZXR1cm5UeXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG4gICAgICAgICAgICB0aGlzLnJldHVyblR5cGUgPSAnTnVtYmVyJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyByZXR1cm5UeXBlIH0gPSB0aGlzO1xuICAgICAgaWYgKCFyZXR1cm5UeXBlKSB7XG4gICAgICAgIHJldEFyci5wdXNoKCd2b2lkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZU1hcFtyZXR1cm5UeXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGUgJHtyZXR1cm5UeXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldEFyci5wdXNoKHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXRBcnIucHVzaCgnICcpO1xuICAgIHJldEFyci5wdXNoKHRoaXMubmFtZSk7XG4gICAgcmV0QXJyLnB1c2goJygnKTtcblxuICAgIGlmICghdGhpcy5pc1Jvb3RLZXJuZWwpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50TmFtZSA9IHRoaXMuYXJndW1lbnROYW1lc1tpXTtcblxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnLCAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXJndW1lbnRUeXBlID0gdGhpcy5hcmd1bWVudFR5cGVzW3RoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKGFyZ3VtZW50TmFtZSldO1xuICAgICAgICBpZiAoIWFyZ3VtZW50VHlwZSkge1xuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVua25vd24gYXJndW1lbnQgJHthcmd1bWVudE5hbWV9IHR5cGVgLCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudFR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicpIHtcbiAgICAgICAgICB0aGlzLmFyZ3VtZW50VHlwZXNbaV0gPSBhcmd1bWVudFR5cGUgPSAnTnVtYmVyJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gdHlwZU1hcFthcmd1bWVudFR5cGVdO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB1dGlscy5zYW5pdGl6ZU5hbWUoYXJndW1lbnROYW1lKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzYW1wbGVyMkQnIHx8IHR5cGUgPT09ICdzYW1wbGVyMkRBcnJheScpIHtcbiAgICAgICAgICByZXRBcnIucHVzaChgJHt0eXBlfSB1c2VyXyR7bmFtZX0saXZlYzIgdXNlcl8ke25hbWV9U2l6ZSxpdmVjMyB1c2VyXyR7bmFtZX1EaW1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRBcnIucHVzaChgJHt0eXBlfSB1c2VyXyR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldEFyci5wdXNoKCcpIHtcXG4nKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LmJvZHkuYm9keS5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5ib2R5LmJvZHlbaV0sIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnXFxuJyk7XG4gICAgfVxuXG4gICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0UmV0dXJuU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKCFhc3QuYXJndW1lbnQpIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgcmV0dXJuIHN0YXRlbWVudCcsIGFzdCk7XG4gICAgdGhpcy5wdXNoU3RhdGUoJ3NraXAtbGl0ZXJhbC1jb3JyZWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpO1xuICAgIHRoaXMucG9wU3RhdGUoJ3NraXAtbGl0ZXJhbC1jb3JyZWN0aW9uJyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgIGlmICghdGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJyB8fCB0eXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgdGhpcy5yZXR1cm5UeXBlID0gJ051bWJlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJldHVyblR5cGUgPSB0eXBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdmbG9hdCgnKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRUeXBlKGFzdCkgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgICAgICByZXN1bHQudW5zaGlmdCgnZmxvYXQoJyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hcmd1bWVudCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICAgIHRoaXMuY2FzdFZhbHVlVG9JbnRlZ2VyKGFzdC5hcmd1bWVudCwgcmVzdWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0ludGVnZXIoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICBjYXNlICdNYXRyaXgoMiknOlxuICAgICAgY2FzZSAnTWF0cml4KDMpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCg0KSc6XG4gICAgICBjYXNlICdJbnB1dCc6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJlc3VsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgdW5oYW5kbGVkIHJldHVybiB0eXBlICR7dGhpcy5yZXR1cm5UeXBlfWAsIGFzdCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNSb290S2VybmVsKSB7XG4gICAgICByZXRBcnIucHVzaChga2VybmVsUmVzdWx0ID0gJHsgcmVzdWx0LmpvaW4oJycpIH07YCk7XG4gICAgICByZXRBcnIucHVzaCgncmV0dXJuOycpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1N1Yktlcm5lbCkge1xuICAgICAgcmV0QXJyLnB1c2goYHN1Yktlcm5lbFJlc3VsdF8keyB0aGlzLm5hbWUgfSA9ICR7IHJlc3VsdC5qb2luKCcnKSB9O2ApO1xuICAgICAgcmV0QXJyLnB1c2goYHJldHVybiBzdWJLZXJuZWxSZXN1bHRfJHsgdGhpcy5uYW1lIH07YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKGByZXR1cm4gJHsgcmVzdWx0LmpvaW4oJycpIH07YCk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RMaXRlcmFsKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKGlzTmFOKGFzdC52YWx1ZSkpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG4gICAgICAgICdOb24tbnVtZXJpYyBsaXRlcmFsIG5vdCBzdXBwb3J0ZWQgOiAnICsgYXN0LnZhbHVlLFxuICAgICAgICBhc3RcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gdGhpcy5hc3RLZXkoYXN0KTtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihhc3QudmFsdWUpKSB7XG4gICAgICBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKSB8fCB0aGlzLmlzU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKSkge1xuICAgICAgICB0aGlzLmxpdGVyYWxUeXBlc1trZXldID0gJ0ludGVnZXInO1xuICAgICAgICByZXRBcnIucHVzaChgJHthc3QudmFsdWV9YCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpIHx8IHRoaXMuaXNTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKSkge1xuICAgICAgICB0aGlzLmxpdGVyYWxUeXBlc1trZXldID0gJ051bWJlcic7XG4gICAgICAgIHJldEFyci5wdXNoKGAke2FzdC52YWx1ZX0uMGApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5saXRlcmFsVHlwZXNba2V5XSA9ICdOdW1iZXInO1xuICAgICAgICByZXRBcnIucHVzaChgJHthc3QudmFsdWV9LjBgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykgfHwgdGhpcy5pc1N0YXRlKCdidWlsZGluZy1pbnRlZ2VyJykpIHtcbiAgICAgIHRoaXMubGl0ZXJhbFR5cGVzW2tleV0gPSAnSW50ZWdlcic7XG4gICAgICByZXRBcnIucHVzaChNYXRoLnJvdW5kKGFzdC52YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxpdGVyYWxUeXBlc1trZXldID0gJ051bWJlcic7XG4gICAgICByZXRBcnIucHVzaChgJHthc3QudmFsdWV9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RCaW5hcnlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKHRoaXMuY2hlY2tBbmRVcGNvbnZlcnRPcGVyYXRvcihhc3QsIHJldEFycikpIHtcbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgJiYgYXN0Lm9wZXJhdG9yID09PSAnLycpIHtcbiAgICAgIHJldEFyci5wdXNoKCdkaXZXaXRoSW50Q2hlY2soJyk7XG4gICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgIHN3aXRjaCAodGhpcy5nZXRUeXBlKGFzdC5sZWZ0KSkge1xuICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvRmxvYXQoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICB9XG4gICAgICByZXRBcnIucHVzaCgnLCAnKTtcbiAgICAgIHN3aXRjaCAodGhpcy5nZXRUeXBlKGFzdC5yaWdodCkpIHtcbiAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cblxuICAgIHJldEFyci5wdXNoKCcoJyk7XG4gICAgY29uc3QgbGVmdFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LmxlZnQpIHx8ICdOdW1iZXInO1xuICAgIGNvbnN0IHJpZ2h0VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QucmlnaHQpIHx8ICdOdW1iZXInO1xuICAgIGlmICghbGVmdFR5cGUgfHwgIXJpZ2h0VHlwZSkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIGJpbmFyeSBleHByZXNzaW9uYCwgYXN0KTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gbGVmdFR5cGUgKyAnICYgJyArIHJpZ2h0VHlwZTtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSAnSW50ZWdlciAmIEludGVnZXInOlxuICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ051bWJlciAmIEZsb2F0JzpcbiAgICAgIGNhc2UgJ0Zsb2F0ICYgTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0ICYgRmxvYXQnOlxuICAgICAgY2FzZSAnTnVtYmVyICYgTnVtYmVyJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyICYgTGl0ZXJhbEludGVnZXInOlxuICAgICAgICBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKSB8fCB0aGlzLmlzU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKSkge1xuICAgICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0ludGVnZXIgJiBGbG9hdCc6XG4gICAgICBjYXNlICdJbnRlZ2VyICYgTnVtYmVyJzpcbiAgICAgICAgaWYgKGFzdC5vcGVyYXRvciA9PT0gJz4nIHx8IGFzdC5vcGVyYXRvciA9PT0gJzwnICYmIGFzdC5yaWdodC50eXBlID09PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXN0LnJpZ2h0LnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvRmxvYXQoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuICAgICAgICBpZiAoYXN0LnJpZ2h0LnR5cGUgPT09ICdMaXRlcmFsJykge1xuICAgICAgICAgIGNvbnN0IGxpdGVyYWxSZXN1bHQgPSBbXTtcbiAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCBsaXRlcmFsUmVzdWx0KTtcbiAgICAgICAgICBjb25zdCBsaXRlcmFsVHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QucmlnaHQpO1xuICAgICAgICAgIGlmIChsaXRlcmFsVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaChsaXRlcmFsUmVzdWx0LmpvaW4oJycpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIGJpbmFyeSBleHByZXNzaW9uIHdpdGggbGl0ZXJhbGAsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldEFyci5wdXNoKCdpbnQoJyk7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSW50ZWdlciAmIExpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0ludGVnZXIoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdOdW1iZXIgJiBJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvRmxvYXQoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Zsb2F0ICYgTGl0ZXJhbEludGVnZXInOlxuICAgICAgY2FzZSAnTnVtYmVyICYgTGl0ZXJhbEludGVnZXInOlxuICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlciAmIEZsb2F0JzpcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyICYgTnVtYmVyJzpcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykpIHtcbiAgICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0ludGVnZXIoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICAgIHRoaXMuY2FzdFZhbHVlVG9JbnRlZ2VyKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgdGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlciAmIEludGVnZXInOlxuICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0Jvb2xlYW4gJiBCb29sZWFuJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWJvb2xlYW4nKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWJvb2xlYW4nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0Zsb2F0ICYgSW50ZWdlcic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBiaW5hcnkgZXhwcmVzc2lvbiBiZXR3ZWVuICR7a2V5fWAsIGFzdCk7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcpJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgY2hlY2tBbmRVcGNvbnZlcnRPcGVyYXRvcihhc3QsIHJldEFycikge1xuICAgIGNvbnN0IGJpdHdpc2VSZXN1bHQgPSB0aGlzLmNoZWNrQW5kVXBjb252ZXJ0Qml0d2lzZU9wZXJhdG9ycyhhc3QsIHJldEFycik7XG4gICAgaWYgKGJpdHdpc2VSZXN1bHQpIHtcbiAgICAgIHJldHVybiBiaXR3aXNlUmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCB1cGNvbnZlcnRhYmxlT3BlcmF0b3JzID0ge1xuICAgICAgJyUnOiB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID8gJ2ludGVnZXJDb3JyZWN0aW9uTW9kdWxvJyA6ICdtb2R1bG8nLFxuICAgICAgJyoqJzogJ3BvdycsXG4gICAgfTtcbiAgICBjb25zdCBmb3VuZE9wZXJhdG9yID0gdXBjb252ZXJ0YWJsZU9wZXJhdG9yc1thc3Qub3BlcmF0b3JdO1xuICAgIGlmICghZm91bmRPcGVyYXRvcikgcmV0dXJuIG51bGw7XG4gICAgcmV0QXJyLnB1c2goZm91bmRPcGVyYXRvcik7XG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICBzd2l0Y2ggKHRoaXMuZ2V0VHlwZShhc3QubGVmdCkpIHtcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvRmxvYXQoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcsJyk7XG4gICAgc3dpdGNoICh0aGlzLmdldFR5cGUoYXN0LnJpZ2h0KSkge1xuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgY2hlY2tBbmRVcGNvbnZlcnRCaXR3aXNlT3BlcmF0b3JzKGFzdCwgcmV0QXJyKSB7XG4gICAgY29uc3QgdXBjb252ZXJ0YWJsZU9wZXJhdG9ycyA9IHtcbiAgICAgICcmJzogJ2JpdHdpc2VBbmQnLFxuICAgICAgJ3wnOiAnYml0d2lzZU9yJyxcbiAgICAgICdeJzogJ2JpdHdpc2VYT1InLFxuICAgICAgJzw8JzogJ2JpdHdpc2VaZXJvRmlsbExlZnRTaGlmdCcsXG4gICAgICAnPj4nOiAnYml0d2lzZVNpZ25lZFJpZ2h0U2hpZnQnLFxuICAgICAgJz4+Pic6ICdiaXR3aXNlWmVyb0ZpbGxSaWdodFNoaWZ0JyxcbiAgICB9O1xuICAgIGNvbnN0IGZvdW5kT3BlcmF0b3IgPSB1cGNvbnZlcnRhYmxlT3BlcmF0b3JzW2FzdC5vcGVyYXRvcl07XG4gICAgaWYgKCFmb3VuZE9wZXJhdG9yKSByZXR1cm4gbnVsbDtcbiAgICByZXRBcnIucHVzaChmb3VuZE9wZXJhdG9yKTtcbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIGNvbnN0IGxlZnRUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5sZWZ0KTtcbiAgICBzd2l0Y2ggKGxlZnRUeXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvSW50ZWdlcihhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0ludGVnZXIoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnLCcpO1xuICAgIGNvbnN0IHJpZ2h0VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QucmlnaHQpO1xuICAgIHN3aXRjaCAocmlnaHRUeXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvSW50ZWdlcihhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjaGVja0FuZFVwY29udmVydEJpdHdpc2VVbmFyeShhc3QsIHJldEFycikge1xuICAgIGNvbnN0IHVwY29udmVydGFibGVPcGVyYXRvcnMgPSB7XG4gICAgICAnfic6ICdiaXR3aXNlTm90JyxcbiAgICB9O1xuICAgIGNvbnN0IGZvdW5kT3BlcmF0b3IgPSB1cGNvbnZlcnRhYmxlT3BlcmF0b3JzW2FzdC5vcGVyYXRvcl07XG4gICAgaWYgKCFmb3VuZE9wZXJhdG9yKSByZXR1cm4gbnVsbDtcbiAgICByZXRBcnIucHVzaChmb3VuZE9wZXJhdG9yKTtcbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIHN3aXRjaCAodGhpcy5nZXRUeXBlKGFzdC5hcmd1bWVudCkpIHtcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIHRoaXMuY2FzdFZhbHVlVG9JbnRlZ2VyKGFzdC5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0ludGVnZXIoYXN0LmFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJldEFycik7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdCwgcmV0QXJyKSB7XG4gICAgdGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QsIHJldEFycik7XG4gICAgdGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNhc3RMaXRlcmFsVG9GbG9hdChhc3QsIHJldEFycikge1xuICAgIHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdCwgcmV0QXJyKTtcbiAgICB0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNhc3RWYWx1ZVRvSW50ZWdlcihhc3QsIHJldEFycikge1xuICAgIHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcbiAgICByZXRBcnIucHVzaCgnaW50KCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICB0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgY2FzdFZhbHVlVG9GbG9hdChhc3QsIHJldEFycikge1xuICAgIHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG4gICAgcmV0QXJyLnB1c2goJ2Zsb2F0KCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICB0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWZsb2F0Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdElkZW50aWZpZXJFeHByZXNzaW9uKGlkdE5vZGUsIHJldEFycikge1xuICAgIGlmIChpZHROb2RlLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnSWRlbnRpZmllckV4cHJlc3Npb24gLSBub3QgYW4gSWRlbnRpZmllcicsIGlkdE5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoaWR0Tm9kZSk7XG5cbiAgICBjb25zdCBuYW1lID0gdXRpbHMuc2FuaXRpemVOYW1lKGlkdE5vZGUubmFtZSk7XG4gICAgaWYgKGlkdE5vZGUubmFtZSA9PT0gJ0luZmluaXR5Jykge1xuICAgICAgcmV0QXJyLnB1c2goJzMuNDAyODIzNDY2ZSszOCcpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0Jvb2xlYW4nKSB7XG4gICAgICBpZiAodGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICByZXRBcnIucHVzaChgYm9vbCh1c2VyXyR7bmFtZX0pYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRBcnIucHVzaChgdXNlcl8ke25hbWV9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7bmFtZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0Rm9yU3RhdGVtZW50KGZvck5vZGUsIHJldEFycikge1xuICAgIGlmIChmb3JOb2RlLnR5cGUgIT09ICdGb3JTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIGZvciBzdGF0ZW1lbnQnLCBmb3JOb2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0QXJyID0gW107XG4gICAgY29uc3QgdGVzdEFyciA9IFtdO1xuICAgIGNvbnN0IHVwZGF0ZUFyciA9IFtdO1xuICAgIGNvbnN0IGJvZHlBcnIgPSBbXTtcbiAgICBsZXQgaXNTYWZlID0gbnVsbDtcblxuICAgIGlmIChmb3JOb2RlLmluaXQpIHtcbiAgICAgIGNvbnN0IHsgZGVjbGFyYXRpb25zIH0gPSBmb3JOb2RlLmluaXQ7XG4gICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS5pbml0LCBpbml0QXJyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkZWNsYXJhdGlvbnNbaV0uaW5pdCAmJiBkZWNsYXJhdGlvbnNbaV0uaW5pdC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZm9yTm9kZS50ZXN0KSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS50ZXN0LCB0ZXN0QXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZvck5vZGUudXBkYXRlKSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS51cGRhdGUsIHVwZGF0ZUFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmb3JOb2RlLmJvZHkpIHtcbiAgICAgIHRoaXMucHVzaFN0YXRlKCdsb29wLWJvZHknKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLmJvZHksIGJvZHlBcnIpO1xuICAgICAgdGhpcy5wb3BTdGF0ZSgnbG9vcC1ib2R5Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzU2FmZSA9PT0gbnVsbCkge1xuICAgICAgaXNTYWZlID0gdGhpcy5pc1NhZmUoZm9yTm9kZS5pbml0KSAmJiB0aGlzLmlzU2FmZShmb3JOb2RlLnRlc3QpO1xuICAgIH1cblxuICAgIGlmIChpc1NhZmUpIHtcbiAgICAgIGNvbnN0IGluaXRTdHJpbmcgPSBpbml0QXJyLmpvaW4oJycpO1xuICAgICAgY29uc3QgaW5pdE5lZWRzU2VtaUNvbG9uID0gaW5pdFN0cmluZ1tpbml0U3RyaW5nLmxlbmd0aCAtIDFdICE9PSAnOyc7XG4gICAgICByZXRBcnIucHVzaChgZm9yICgke2luaXRTdHJpbmd9JHtpbml0TmVlZHNTZW1pQ29sb24gPyAnOycgOiAnJ30ke3Rlc3RBcnIuam9pbignJyl9OyR7dXBkYXRlQXJyLmpvaW4oJycpfSl7XFxuYCk7XG4gICAgICByZXRBcnIucHVzaChib2R5QXJyLmpvaW4oJycpKTtcbiAgICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlWYXJpYWJsZU5hbWUgPSB0aGlzLmdldEludGVybmFsVmFyaWFibGVOYW1lKCdzYWZlSScpO1xuICAgICAgaWYgKGluaXRBcnIubGVuZ3RoID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaChpbml0QXJyLmpvaW4oJycpLCAnXFxuJyk7XG4gICAgICB9XG4gICAgICByZXRBcnIucHVzaChgZm9yIChpbnQgJHtpVmFyaWFibGVOYW1lfT0wOyR7aVZhcmlhYmxlTmFtZX08TE9PUF9NQVg7JHtpVmFyaWFibGVOYW1lfSsrKXtcXG5gKTtcbiAgICAgIGlmICh0ZXN0QXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0QXJyLnB1c2goYGlmICghJHt0ZXN0QXJyLmpvaW4oJycpfSkgYnJlYWs7XFxuYCk7XG4gICAgICB9XG4gICAgICByZXRBcnIucHVzaChib2R5QXJyLmpvaW4oJycpKTtcbiAgICAgIHJldEFyci5wdXNoKGBcXG4ke3VwZGF0ZUFyci5qb2luKCcnKX07YCk7XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0V2hpbGVTdGF0ZW1lbnQod2hpbGVOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAod2hpbGVOb2RlLnR5cGUgIT09ICdXaGlsZVN0YXRlbWVudCcpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgd2hpbGUgc3RhdGVtZW50Jywgd2hpbGVOb2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpVmFyaWFibGVOYW1lID0gdGhpcy5nZXRJbnRlcm5hbFZhcmlhYmxlTmFtZSgnc2FmZUknKTtcbiAgICByZXRBcnIucHVzaChgZm9yIChpbnQgJHtpVmFyaWFibGVOYW1lfT0wOyR7aVZhcmlhYmxlTmFtZX08TE9PUF9NQVg7JHtpVmFyaWFibGVOYW1lfSsrKXtcXG5gKTtcbiAgICByZXRBcnIucHVzaCgnaWYgKCEnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMod2hpbGVOb2RlLnRlc3QsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJykgYnJlYWs7XFxuJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKHdoaWxlTm9kZS5ib2R5LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0RG9XaGlsZVN0YXRlbWVudChkb1doaWxlTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKGRvV2hpbGVOb2RlLnR5cGUgIT09ICdEb1doaWxlU3RhdGVtZW50Jykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnSW52YWxpZCB3aGlsZSBzdGF0ZW1lbnQnLCBkb1doaWxlTm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaVZhcmlhYmxlTmFtZSA9IHRoaXMuZ2V0SW50ZXJuYWxWYXJpYWJsZU5hbWUoJ3NhZmVJJyk7XG4gICAgcmV0QXJyLnB1c2goYGZvciAoaW50ICR7aVZhcmlhYmxlTmFtZX09MDske2lWYXJpYWJsZU5hbWV9PExPT1BfTUFYOyR7aVZhcmlhYmxlTmFtZX0rKyl7XFxuYCk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGRvV2hpbGVOb2RlLmJvZHksIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJ2lmICghJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGRvV2hpbGVOb2RlLnRlc3QsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJykgYnJlYWs7XFxuJyk7XG4gICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuXG4gIGFzdEFzc2lnbm1lbnRFeHByZXNzaW9uKGFzc05vZGUsIHJldEFycikge1xuICAgIGlmIChhc3NOb2RlLm9wZXJhdG9yID09PSAnJT0nKSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5sZWZ0LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJz0nKTtcbiAgICAgIHJldEFyci5wdXNoKCdtb2QoJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5sZWZ0LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJywnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLnJpZ2h0LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICB9IGVsc2UgaWYgKGFzc05vZGUub3BlcmF0b3IgPT09ICcqKj0nKSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5sZWZ0LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJz0nKTtcbiAgICAgIHJldEFyci5wdXNoKCdwb3coJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5sZWZ0LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJywnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLnJpZ2h0LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVmdFR5cGUgPSB0aGlzLmdldFR5cGUoYXNzTm9kZS5sZWZ0KTtcbiAgICAgIGNvbnN0IHJpZ2h0VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3NOb2RlLnJpZ2h0KTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLmxlZnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaChhc3NOb2RlLm9wZXJhdG9yKTtcbiAgICAgIGlmIChsZWZ0VHlwZSAhPT0gJ0ludGVnZXInICYmIHJpZ2h0VHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUucmlnaHQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfVxuICB9XG5cbiAgYXN0QmxvY2tTdGF0ZW1lbnQoYk5vZGUsIHJldEFycikge1xuICAgIGlmICh0aGlzLmlzU3RhdGUoJ2xvb3AtYm9keScpKSB7XG4gICAgICB0aGlzLnB1c2hTdGF0ZSgnYmxvY2stYm9keScpOyBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYk5vZGUuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYk5vZGUuYm9keVtpXSwgcmV0QXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9wU3RhdGUoJ2Jsb2NrLWJvZHknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goJ3tcXG4nKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYk5vZGUuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYk5vZGUuYm9keVtpXSwgcmV0QXJyKTtcbiAgICAgIH1cbiAgICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RWYXJpYWJsZURlY2xhcmF0aW9uKHZhckRlY05vZGUsIHJldEFycikge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IHZhckRlY05vZGUuZGVjbGFyYXRpb25zO1xuICAgIGlmICghZGVjbGFyYXRpb25zIHx8ICFkZWNsYXJhdGlvbnNbMF0gfHwgIWRlY2xhcmF0aW9uc1swXS5pbml0KSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCB2YXJEZWNOb2RlKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGxhc3RUeXBlID0gbnVsbDtcbiAgICBjb25zdCBkZWNsYXJhdGlvblNldHMgPSBbXTtcbiAgICBsZXQgZGVjbGFyYXRpb25TZXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbnNbaV07XG4gICAgICBjb25zdCBpbml0ID0gZGVjbGFyYXRpb24uaW5pdDtcbiAgICAgIGNvbnN0IGluZm8gPSB0aGlzLmdldERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLmlkKTtcbiAgICAgIGNvbnN0IGFjdHVhbFR5cGUgPSB0aGlzLmdldFR5cGUoZGVjbGFyYXRpb24uaW5pdCk7XG4gICAgICBsZXQgdHlwZSA9IGFjdHVhbFR5cGU7XG4gICAgICBpZiAodHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuICAgICAgICBpZiAoaW5mby5zdWdnZXN0ZWRUeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICB0eXBlID0gJ0ludGVnZXInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSAnTnVtYmVyJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbWFya3VwVHlwZSA9IHR5cGVNYXBbdHlwZV07XG4gICAgICBpZiAoIW1hcmt1cFR5cGUpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgTWFya3VwIHR5cGUgJHsgdHlwZSB9IG5vdCBoYW5kbGVkYCwgdmFyRGVjTm9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWNsYXJhdGlvblJlc3VsdCA9IFtdO1xuICAgICAgaWYgKGFjdHVhbFR5cGUgPT09ICdJbnRlZ2VyJyAmJiB0eXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgaW5mby52YWx1ZVR5cGUgPSAnTnVtYmVyJztcbiAgICAgICAgaWYgKGkgPT09IDAgfHwgbGFzdFR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKCdmbG9hdCAnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSBsYXN0VHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5oYW5kbGVkIGRlY2xhcmF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFR5cGUgPSB0eXBlO1xuICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKGB1c2VyXyR7dXRpbHMuc2FuaXRpemVOYW1lKGRlY2xhcmF0aW9uLmlkLm5hbWUpfT1gKTtcbiAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaCgnZmxvYXQoJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhpbml0LCBkZWNsYXJhdGlvblJlc3VsdCk7XG4gICAgICAgIGRlY2xhcmF0aW9uUmVzdWx0LnB1c2goJyknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8udmFsdWVUeXBlID0gdHlwZTtcbiAgICAgICAgaWYgKGkgPT09IDAgfHwgbGFzdFR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKGAke21hcmt1cFR5cGV9IGApO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IGxhc3RUeXBlKSB7XG4gICAgICAgICAgZGVjbGFyYXRpb25TZXRzLnB1c2goZGVjbGFyYXRpb25TZXQuam9pbignLCcpKTtcbiAgICAgICAgICBkZWNsYXJhdGlvblNldCA9IFtdO1xuICAgICAgICAgIGRlY2xhcmF0aW9uUmVzdWx0LnB1c2goYCR7bWFya3VwVHlwZX0gYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFR5cGUgPSB0eXBlO1xuICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKGB1c2VyXyR7dXRpbHMuc2FuaXRpemVOYW1lKGRlY2xhcmF0aW9uLmlkLm5hbWUpfT1gKTtcbiAgICAgICAgaWYgKGFjdHVhbFR5cGUgPT09ICdOdW1iZXInICYmIHR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgIGlmIChpbml0LmxlZnQgJiYgaW5pdC5sZWZ0LnR5cGUgPT09ICdMaXRlcmFsJykge1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGluaXQsIGRlY2xhcmF0aW9uUmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaCgnaW50KCcpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGluaXQsIGRlY2xhcmF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uUmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0dWFsVHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJyAmJiB0eXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGluaXQsIGRlY2xhcmF0aW9uUmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoaW5pdCwgZGVjbGFyYXRpb25SZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWNsYXJhdGlvblNldC5wdXNoKGRlY2xhcmF0aW9uUmVzdWx0LmpvaW4oJycpKTtcbiAgICB9XG5cbiAgICBpZiAoZGVjbGFyYXRpb25TZXQubGVuZ3RoID4gMCkge1xuICAgICAgZGVjbGFyYXRpb25TZXRzLnB1c2goZGVjbGFyYXRpb25TZXQuam9pbignLCcpKTtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChkZWNsYXJhdGlvblNldHMuam9pbignOycpKTtcblxuICAgIHJldEFyci5wdXNoKHJlc3VsdC5qb2luKCcnKSk7XG4gICAgcmV0QXJyLnB1c2goJzsnKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0SWZTdGF0ZW1lbnQoaWZOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnaWYgKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUudGVzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIGlmIChpZk5vZGUuY29uc2VxdWVudC50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCcge1xcbicpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJ1xcbn1cXG4nKTtcbiAgICB9XG5cbiAgICBpZiAoaWZOb2RlLmFsdGVybmF0ZSkge1xuICAgICAgcmV0QXJyLnB1c2goJ2Vsc2UgJyk7XG4gICAgICBpZiAoaWZOb2RlLmFsdGVybmF0ZS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnIHx8IGlmTm9kZS5hbHRlcm5hdGUudHlwZSA9PT0gJ0lmU3RhdGVtZW50Jykge1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmFsdGVybmF0ZSwgcmV0QXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldEFyci5wdXNoKCcge1xcbicpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmFsdGVybmF0ZSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ1xcbn1cXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFN3aXRjaFN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ1N3aXRjaFN0YXRlbWVudCcpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgc3dpdGNoIHN0YXRlbWVudCcsIGFzdCk7XG4gICAgfVxuICAgIGNvbnN0IHsgZGlzY3JpbWluYW50LCBjYXNlcyB9ID0gYXN0O1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoZGlzY3JpbWluYW50KTtcbiAgICBjb25zdCB2YXJOYW1lID0gYHN3aXRjaERpc2NyaW1pbmFudCR7dGhpcy5hc3RLZXkoYXN0LCAnXycpfWA7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICByZXRBcnIucHVzaChgZmxvYXQgJHt2YXJOYW1lfSA9IGApO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoZGlzY3JpbWluYW50LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnO1xcbicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICByZXRBcnIucHVzaChgaW50ICR7dmFyTmFtZX0gPSBgKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGRpc2NyaW1pbmFudCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJztcXG4nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChjYXNlcy5sZW5ndGggPT09IDEgJiYgIWNhc2VzWzBdLnRlc3QpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhjYXNlc1swXS5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9XG5cbiAgICBsZXQgZmFsbGluZ1Rocm91Z2ggPSBmYWxzZTtcbiAgICBsZXQgZGVmYXVsdFJlc3VsdCA9IFtdO1xuICAgIGxldCBtb3ZpbmdEZWZhdWx0VG9FbmQgPSBmYWxzZTtcbiAgICBsZXQgcGFzdEZpcnN0SWYgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWNhc2VzW2ldLnRlc3QpIHtcbiAgICAgICAgaWYgKGNhc2VzLmxlbmd0aCA+IGkgKyAxKSB7XG4gICAgICAgICAgbW92aW5nRGVmYXVsdFRvRW5kID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoY2FzZXNbaV0uY29uc2VxdWVudCwgZGVmYXVsdFJlc3VsdCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJyBlbHNlIHtcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGkgPT09IDAgfHwgIXBhc3RGaXJzdElmKSB7XG4gICAgICAgICAgcGFzdEZpcnN0SWYgPSB0cnVlO1xuICAgICAgICAgIHJldEFyci5wdXNoKGBpZiAoJHt2YXJOYW1lfSA9PSBgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZmFsbGluZ1Rocm91Z2gpIHtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGAke3Zhck5hbWV9ID09IGApO1xuICAgICAgICAgICAgZmFsbGluZ1Rocm91Z2ggPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goYCBlbHNlIGlmICgke3Zhck5hbWV9ID09IGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgY29uc3QgdGVzdFR5cGUgPSB0aGlzLmdldFR5cGUoY2FzZXNbaV0udGVzdCk7XG4gICAgICAgICAgc3dpdGNoICh0ZXN0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0ludGVnZXIoY2FzZXNbaV0udGVzdCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0ludGVnZXIoY2FzZXNbaV0udGVzdCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdGbG9hdCcpIHtcbiAgICAgICAgICBjb25zdCB0ZXN0VHlwZSA9IHRoaXMuZ2V0VHlwZShjYXNlc1tpXS50ZXN0KTtcbiAgICAgICAgICBzd2l0Y2ggKHRlc3RUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGNhc2VzW2ldLnRlc3QsIHJldEFycik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChjYXNlc1tpXS50ZXN0LCByZXRBcnIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmhhbmxkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhc2VzW2ldLmNvbnNlcXVlbnQgfHwgY2FzZXNbaV0uY29uc2VxdWVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBmYWxsaW5nVGhyb3VnaCA9IHRydWU7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJyB8fCAnKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXRBcnIucHVzaChgKSB7XFxuYCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoY2FzZXNbaV0uY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCdcXG59Jyk7XG4gICAgfVxuICAgIGlmIChtb3ZpbmdEZWZhdWx0VG9FbmQpIHtcbiAgICAgIHJldEFyci5wdXNoKCcgZWxzZSB7Jyk7XG4gICAgICByZXRBcnIucHVzaChkZWZhdWx0UmVzdWx0LmpvaW4oJycpKTtcbiAgICAgIHJldEFyci5wdXNoKCd9Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RUaGlzRXhwcmVzc2lvbih0Tm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJ3RoaXMnKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0TWVtYmVyRXhwcmVzc2lvbihtTm9kZSwgcmV0QXJyKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJvcGVydHksXG4gICAgICBuYW1lLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgb3JpZ2luLFxuICAgICAgdHlwZSxcbiAgICAgIHhQcm9wZXJ0eSxcbiAgICAgIHlQcm9wZXJ0eSxcbiAgICAgIHpQcm9wZXJ0eVxuICAgIH0gPSB0aGlzLmdldE1lbWJlckV4cHJlc3Npb25EZXRhaWxzKG1Ob2RlKTtcbiAgICBzd2l0Y2ggKHNpZ25hdHVyZSkge1xuICAgICAgY2FzZSAndmFsdWUudGhyZWFkLnZhbHVlJzpcbiAgICAgIGNhc2UgJ3RoaXMudGhyZWFkLnZhbHVlJzpcbiAgICAgICAgaWYgKG5hbWUgIT09ICd4JyAmJiBuYW1lICE9PSAneScgJiYgbmFtZSAhPT0gJ3onKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uLCBleHBlY3RlZCBgdGhpcy50aHJlYWQueGAsIGB0aGlzLnRocmVhZC55YCwgb3IgYHRoaXMudGhyZWFkLnpgJywgbU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldEFyci5wdXNoKGB0aHJlYWRJZC4ke25hbWV9YCk7XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICBjYXNlICd0aGlzLm91dHB1dC52YWx1ZSc6XG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNPdXRwdXQpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWZsb2F0JykpIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCgnZmxvYXQodU91dHB1dERpbS54KScpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKCd1T3V0cHV0RGltLngnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWZsb2F0JykpIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCgnZmxvYXQodU91dHB1dERpbS55KScpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKCd1T3V0cHV0RGltLnknKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWZsb2F0JykpIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCgnZmxvYXQodU91dHB1dERpbS56KScpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKCd1T3V0cHV0RGltLnonKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIG1Ob2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykpIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm91dHB1dFswXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMF0sICcuMCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMV0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMub3V0cHV0WzFdLCAnLjAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKSkge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMub3V0cHV0WzJdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm91dHB1dFsyXSwgJy4wJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBtTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIG1Ob2RlKTtcbiAgICAgIGNhc2UgJ3ZhbHVlW10nOlxuICAgICAgY2FzZSAndmFsdWVbXVtdJzpcbiAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdJzpcbiAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdW10nOlxuICAgICAgY2FzZSAndmFsdWUudmFsdWUnOlxuICAgICAgICBpZiAob3JpZ2luID09PSAnTWF0aCcpIHtcbiAgICAgICAgICByZXRBcnIucHVzaChNYXRoW25hbWVdKTtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsZWFuTmFtZSA9IHV0aWxzLnNhbml0aXplTmFtZShuYW1lKTtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHsgY2xlYW5OYW1lIH0ucmApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IGNsZWFuTmFtZSB9LmdgKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBjbGVhbk5hbWUgfS5iYCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHsgY2xlYW5OYW1lIH0uYWApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlJzpcbiAgICAgICAgaWYgKHR5cGVvZiB4UHJvcGVydHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICAgICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKGBjb25zdGFudHNfJHsgdXRpbHMuc2FuaXRpemVOYW1lKG5hbWUpIH1gKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXSc6XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXSc6XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdJzpcbiAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW11bXSc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZuKClbXSc6XG4gICAgICAgICAgdGhpcy5hc3RDYWxsRXhwcmVzc2lvbihtTm9kZS5vYmplY3QsIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cChwcm9wZXJ0eSkpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgY2FzZSAnZm4oKVtdW10nOlxuICAgICAgICAgIHRoaXMuYXN0Q2FsbEV4cHJlc3Npb24obU5vZGUub2JqZWN0Lm9iamVjdCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKG1Ob2RlLm9iamVjdC5wcm9wZXJ0eSkpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cChtTm9kZS5wcm9wZXJ0eSkpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgY2FzZSAnW11bXSc6XG4gICAgICAgICAgdGhpcy5hc3RBcnJheUV4cHJlc3Npb24obU5vZGUub2JqZWN0LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAocHJvcGVydHkpKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuICAgIH1cblxuICAgIGlmIChtTm9kZS5jb21wdXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgICAgICByZXRBcnIucHVzaChgJHtvcmlnaW59XyR7dXRpbHMuc2FuaXRpemVOYW1lKG5hbWUpfWApO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWFya3VwTmFtZSA9IGAke29yaWdpbn1fJHt1dGlscy5zYW5pdGl6ZU5hbWUobmFtZSl9YDtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cCh4UHJvcGVydHkpKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRJbWFnZTNEKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldEZsb2F0RnJvbVNhbXBsZXIyRCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5MUQoMiknOlxuICAgICAgY2FzZSAnQXJyYXkyRCgyKSc6XG4gICAgICBjYXNlICdBcnJheTNEKDIpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldE1lbW9yeU9wdGltaXplZFZlYzIoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoMiknOlxuICAgICAgICByZXRBcnIucHVzaChgZ2V0VmVjMkZyb21TYW1wbGVyMkQoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheTFEKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5MkQoMyknOlxuICAgICAgY2FzZSAnQXJyYXkzRCgzKSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRNZW1vcnlPcHRpbWl6ZWRWZWMzKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldFZlYzNGcm9tU2FtcGxlcjJEKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkxRCg0KSc6XG4gICAgICBjYXNlICdBcnJheTJEKDQpJzpcbiAgICAgIGNhc2UgJ0FycmF5M0QoNCknOlxuICAgICAgICByZXRBcnIucHVzaChgZ2V0TWVtb3J5T3B0aW1pemVkVmVjNCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICBjYXNlICdIVE1MQ2FudmFzJzpcbiAgICAgIGNhc2UgJ09mZnNjcmVlbkNhbnZhcyc6XG4gICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgY2FzZSAnSW1hZ2VCaXRtYXAnOlxuICAgICAgY2FzZSAnSW1hZ2VEYXRhJzpcbiAgICAgIGNhc2UgJ0hUTUxWaWRlbyc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRWZWM0RnJvbVNhbXBsZXIyRCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ051bWJlclRleHR1cmUnOlxuICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgY2FzZSAnQXJyYXkyRCc6XG4gICAgICBjYXNlICdBcnJheTNEJzpcbiAgICAgIGNhc2UgJ0FycmF5NEQnOlxuICAgICAgY2FzZSAnSW5wdXQnOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goYGdldE1lbW9yeU9wdGltaXplZDMyKCR7bWFya3VwTmFtZX0sICR7bWFya3VwTmFtZX1TaXplLCAke21hcmt1cE5hbWV9RGltLCBgKTtcbiAgICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJpdFJhdGlvID0gKG9yaWdpbiA9PT0gJ3VzZXInID9cbiAgICAgICAgICAgIHRoaXMubG9va3VwRnVuY3Rpb25Bcmd1bWVudEJpdFJhdGlvKHRoaXMubmFtZSwgbmFtZSkgOlxuICAgICAgICAgICAgdGhpcy5jb25zdGFudEJpdFJhdGlvc1tuYW1lXVxuICAgICAgICAgICk7XG4gICAgICAgICAgc3dpdGNoIChiaXRSYXRpbykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICByZXRBcnIucHVzaChgZ2V0OCgke21hcmt1cE5hbWV9LCAke21hcmt1cE5hbWV9U2l6ZSwgJHttYXJrdXBOYW1lfURpbSwgYCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByZXRBcnIucHVzaChgZ2V0MTYoJHttYXJrdXBOYW1lfSwgJHttYXJrdXBOYW1lfVNpemUsICR7bWFya3VwTmFtZX1EaW0sIGApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goYGdldDMyKCR7bWFya3VwTmFtZX0sICR7bWFya3VwTmFtZX1TaXplLCAke21hcmt1cE5hbWV9RGltLCBgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBiaXQgcmF0aW8gb2YgJHtiaXRSYXRpb31gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOlxuICAgICAgICByZXRBcnIucHVzaChgZ2V0TWVtb3J5T3B0aW1pemVkMzIoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNYXRyaXgoMiknOlxuICAgICAgY2FzZSAnTWF0cml4KDMpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCg0KSc6XG4gICAgICAgIHJldEFyci5wdXNoKGAke21hcmt1cE5hbWV9WyR7dGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAoeVByb3BlcnR5KX1dYCk7XG4gICAgICAgIGlmICh5UHJvcGVydHkpIHtcbiAgICAgICAgICByZXRBcnIucHVzaChgWyR7dGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAoeFByb3BlcnR5KX1dYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBtZW1iZXIgZXhwcmVzc2lvbiBcIiR7IHR5cGUgfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RDYWxsRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIGlmICghYXN0LmNhbGxlZSkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5rbm93biBDYWxsRXhwcmVzc2lvbicsIGFzdCk7XG4gICAgfVxuXG4gICAgbGV0IGZ1bmN0aW9uTmFtZSA9IG51bGw7XG4gICAgY29uc3QgaXNNYXRoRnVuY3Rpb24gPSB0aGlzLmlzQXN0TWF0aEZ1bmN0aW9uKGFzdCk7XG5cbiAgICBpZiAoaXNNYXRoRnVuY3Rpb24gfHwgKGFzdC5jYWxsZWUub2JqZWN0ICYmIGFzdC5jYWxsZWUub2JqZWN0LnR5cGUgPT09ICdUaGlzRXhwcmVzc2lvbicpKSB7XG4gICAgICBmdW5jdGlvbk5hbWUgPSBhc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5jYWxsZWUudHlwZSA9PT0gJ1NlcXVlbmNlRXhwcmVzc2lvbicgJiYgYXN0LmNhbGxlZS5leHByZXNzaW9uc1swXS50eXBlID09PSAnTGl0ZXJhbCcgJiYgIWlzTmFOKGFzdC5jYWxsZWUuZXhwcmVzc2lvbnNbMF0ucmF3KSkge1xuICAgICAgZnVuY3Rpb25OYW1lID0gYXN0LmNhbGxlZS5leHByZXNzaW9uc1sxXS5wcm9wZXJ0eS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdW5jdGlvbk5hbWUgPSBhc3QuY2FsbGVlLm5hbWU7XG4gICAgfVxuXG4gICAgaWYgKCFmdW5jdGlvbk5hbWUpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBmdW5jdGlvbiwgY291bGRuJ3QgZmluZCBuYW1lYCwgYXN0KTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgY2FzZSAncG93JzpcbiAgICAgICAgZnVuY3Rpb25OYW1lID0gJ19wb3cnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JvdW5kJzpcbiAgICAgICAgZnVuY3Rpb25OYW1lID0gJ19yb3VuZCc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNhbGxlZEZ1bmN0aW9ucy5pbmRleE9mKGZ1bmN0aW9uTmFtZSkgPCAwKSB7XG4gICAgICB0aGlzLmNhbGxlZEZ1bmN0aW9ucy5wdXNoKGZ1bmN0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ3JhbmRvbScgJiYgdGhpcy5wbHVnaW5zICYmIHRoaXMucGx1Z2lucy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnBsdWdpbnNbaV07XG4gICAgICAgIGlmIChwbHVnaW4uZnVuY3Rpb25NYXRjaCA9PT0gJ01hdGgucmFuZG9tKCknICYmIHBsdWdpbi5mdW5jdGlvblJlcGxhY2UpIHtcbiAgICAgICAgICByZXRBcnIucHVzaChwbHVnaW4uZnVuY3Rpb25SZXBsYWNlKTtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub25GdW5jdGlvbkNhbGwpIHtcbiAgICAgIHRoaXMub25GdW5jdGlvbkNhbGwodGhpcy5uYW1lLCBmdW5jdGlvbk5hbWUsIGFzdC5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldEFyci5wdXNoKGZ1bmN0aW9uTmFtZSk7XG5cbiAgICByZXRBcnIucHVzaCgnKCcpO1xuXG4gICAgaWYgKGlzTWF0aEZ1bmN0aW9uKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5hcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgYXJndW1lbnQgPSBhc3QuYXJndW1lbnRzW2ldO1xuICAgICAgICBjb25zdCBhcmd1bWVudFR5cGUgPSB0aGlzLmdldFR5cGUoYXJndW1lbnQpO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnLCAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRUeXBlKSB7XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvRmxvYXQoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0VHlwZXMgPSB0aGlzLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyhmdW5jdGlvbk5hbWUpIHx8IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QuYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50ID0gYXN0LmFyZ3VtZW50c1tpXTtcbiAgICAgICAgbGV0IHRhcmdldFR5cGUgPSB0YXJnZXRUeXBlc1tpXTtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJywgJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJndW1lbnRUeXBlID0gdGhpcy5nZXRUeXBlKGFyZ3VtZW50KTtcbiAgICAgICAgaWYgKCF0YXJnZXRUeXBlKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VySW1wbHlBcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpLCBhcmd1bWVudFR5cGUsIHRoaXMpO1xuICAgICAgICAgIHRhcmdldFR5cGUgPSBhcmd1bWVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhcmd1bWVudFR5cGUpIHtcbiAgICAgICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgICAgaWYgKHRhcmdldFR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgICAgICByZXRBcnIucHVzaCgnaW50KCcpO1xuICAgICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRUeXBlID09PSAnTnVtYmVyJyB8fCB0YXJnZXRUeXBlID09PSAnRmxvYXQnKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gJ051bWJlcicgfHwgdGFyZ2V0VHlwZSA9PT0gJ0Zsb2F0Jykge1xuICAgICAgICAgICAgICByZXRBcnIucHVzaCgnZmxvYXQoJyk7XG4gICAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgICAgaWYgKHRhcmdldFR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gJ051bWJlcicgfHwgdGFyZ2V0VHlwZSA9PT0gJ0Zsb2F0Jykge1xuICAgICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgICAgaWYgKHRhcmdldFR5cGUgPT09IGFyZ3VtZW50VHlwZSkge1xuICAgICAgICAgICAgICBpZiAoYXJndW1lbnQudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHt1dGlscy5zYW5pdGl6ZU5hbWUoYXJndW1lbnQubmFtZSl9YCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnQudHlwZSA9PT0gJ0FycmF5RXhwcmVzc2lvbicgfHwgYXJndW1lbnQudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nIHx8IGFyZ3VtZW50LnR5cGUgPT09ICdDYWxsRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIGFyZ3VtZW50IHR5cGUgJHsgYXJndW1lbnQudHlwZSB9YCwgYXN0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0hUTUxDYW52YXMnOlxuICAgICAgICAgIGNhc2UgJ09mZnNjcmVlbkNhbnZhcyc6XG4gICAgICAgICAgY2FzZSAnSFRNTEltYWdlJzpcbiAgICAgICAgICBjYXNlICdJbWFnZUJpdG1hcCc6XG4gICAgICAgICAgY2FzZSAnSW1hZ2VEYXRhJzpcbiAgICAgICAgICBjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG4gICAgICAgICAgY2FzZSAnSFRNTFZpZGVvJzpcbiAgICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMSknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG4gICAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoNCknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICBjYXNlICdJbnB1dCc6XG4gICAgICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gYXJndW1lbnRUeXBlKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudC50eXBlICE9PSAnSWRlbnRpZmllcicpIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBhcmd1bWVudCB0eXBlICR7IGFyZ3VtZW50LnR5cGUgfWAsIGFzdCk7XG4gICAgICAgICAgICAgIHRoaXMudHJpZ2dlckltcGx5QXJndW1lbnRCaXRSYXRpbyh0aGlzLm5hbWUsIGFyZ3VtZW50Lm5hbWUsIGZ1bmN0aW9uTmFtZSwgaSk7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB1dGlscy5zYW5pdGl6ZU5hbWUoYXJndW1lbnQubmFtZSk7XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7bmFtZX0sdXNlcl8ke25hbWV9U2l6ZSx1c2VyXyR7bmFtZX1EaW1gKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgYXJndW1lbnQgY29tYmluYXRpb24gb2YgJHsgYXJndW1lbnRUeXBlIH0gYW5kICR7IHRhcmdldFR5cGUgfSBmb3IgYXJndW1lbnQgbmFtZWQgXCIkeyBhcmd1bWVudC5uYW1lIH1cImAsIGFzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcpJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0QXJyYXlFeHByZXNzaW9uKGFyck5vZGUsIHJldEFycikge1xuICAgIGNvbnN0IHJldHVyblR5cGUgPSB0aGlzLmdldFR5cGUoYXJyTm9kZSk7XG5cbiAgICBjb25zdCBhcnJMZW4gPSBhcnJOb2RlLmVsZW1lbnRzLmxlbmd0aDtcblxuICAgIHN3aXRjaCAocmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTWF0cml4KDIpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgzKSc6XG4gICAgICBjYXNlICdNYXRyaXgoNCknOlxuICAgICAgICByZXRBcnIucHVzaChgbWF0JHthcnJMZW59KGApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldEFyci5wdXNoKGB2ZWMke2Fyckxlbn0oYCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyTGVuOyArK2kpIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaCgnLCAnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1Yk5vZGUgPSBhcnJOb2RlLmVsZW1lbnRzW2ldO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKHN1Yk5vZGUsIHJldEFycilcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyknKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBtZW1iZXJFeHByZXNzaW9uWFlaKHgsIHksIHosIHJldEFycikge1xuICAgIGlmICh6KSB7XG4gICAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cCh6KSwgJywgJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCcwLCAnKTtcbiAgICB9XG4gICAgaWYgKHkpIHtcbiAgICAgIHJldEFyci5wdXNoKHRoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHkpLCAnLCAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goJzAsICcpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cCh4KSk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIG1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cChwcm9wZXJ0eSkge1xuICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgbm90IHNldCcpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKHByb3BlcnR5KTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIHRoaXMuY2FzdFZhbHVlVG9JbnRlZ2VyKHByb3BlcnR5LCByZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihwcm9wZXJ0eSwgcmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMocHJvcGVydHksIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gIH1cbn1cblxuY29uc3QgdHlwZU1hcCA9IHtcbiAgJ0FycmF5JzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheSgyKSc6ICd2ZWMyJyxcbiAgJ0FycmF5KDMpJzogJ3ZlYzMnLFxuICAnQXJyYXkoNCknOiAndmVjNCcsXG4gICdNYXRyaXgoMiknOiAnbWF0MicsXG4gICdNYXRyaXgoMyknOiAnbWF0MycsXG4gICdNYXRyaXgoNCknOiAnbWF0NCcsXG4gICdBcnJheTJEJzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheTNEJzogJ3NhbXBsZXIyRCcsXG4gICdCb29sZWFuJzogJ2Jvb2wnLFxuICAnRmxvYXQnOiAnZmxvYXQnLFxuICAnSW5wdXQnOiAnc2FtcGxlcjJEJyxcbiAgJ0ludGVnZXInOiAnaW50JyxcbiAgJ051bWJlcic6ICdmbG9hdCcsXG4gICdMaXRlcmFsSW50ZWdlcic6ICdmbG9hdCcsXG4gICdOdW1iZXJUZXh0dXJlJzogJ3NhbXBsZXIyRCcsXG4gICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheVRleHR1cmUoMSknOiAnc2FtcGxlcjJEJyxcbiAgJ0FycmF5VGV4dHVyZSgyKSc6ICdzYW1wbGVyMkQnLFxuICAnQXJyYXlUZXh0dXJlKDMpJzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheVRleHR1cmUoNCknOiAnc2FtcGxlcjJEJyxcbiAgJ0hUTUxWaWRlbyc6ICdzYW1wbGVyMkQnLFxuICAnSFRNTENhbnZhcyc6ICdzYW1wbGVyMkQnLFxuICAnT2Zmc2NyZWVuQ2FudmFzJzogJ3NhbXBsZXIyRCcsXG4gICdIVE1MSW1hZ2UnOiAnc2FtcGxlcjJEJyxcbiAgJ0ltYWdlQml0bWFwJzogJ3NhbXBsZXIyRCcsXG4gICdJbWFnZURhdGEnOiAnc2FtcGxlcjJEJyxcbiAgJ0hUTUxJbWFnZUFycmF5JzogJ3NhbXBsZXIyREFycmF5Jyxcbn07XG5cbmNvbnN0IG9wZXJhdG9yTWFwID0ge1xuICAnPT09JzogJz09JyxcbiAgJyE9PSc6ICchPSdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEZ1bmN0aW9uTm9kZVxufTtcbn0se1wiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi9mdW5jdGlvbi1ub2RlXCI6MTB9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVCb29sZWFuIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9ib29sZWFuJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVGbG9hdCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZmxvYXQnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUludGVnZXIgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2ludGVnZXInKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2UnKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSFRNTFZpZGVvIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9odG1sLXZpZGVvJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtdmlkZW8nKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dCcpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUlucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1pbnB1dCcpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1pbnB1dCcpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtaW5wdXQnKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZScpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9udW1iZXItdGV4dHVyZScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtbnVtYmVyLXRleHR1cmUnKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheScpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MWQtaScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTFkLWknKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWknKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkyZC1pJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzZC1pJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5M2QtaScpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVBcnJheTIgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2FycmF5MicpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlQXJyYXkzIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9hcnJheTMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUFycmF5NCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvYXJyYXk0Jyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3Vuc2lnbmVkLWFycmF5Jyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1hcnJheScpO1xuXG5jb25zdCBrZXJuZWxWYWx1ZU1hcHMgPSB7XG4gIHVuc2lnbmVkOiB7XG4gICAgZHluYW1pYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbixcbiAgICAgICdJbnRlZ2VyJzogV2ViR0xLZXJuZWxWYWx1ZUludGVnZXIsXG4gICAgICAnRmxvYXQnOiBXZWJHTEtlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnQXJyYXknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXksXG4gICAgICAnQXJyYXkoMiknOiBXZWJHTEtlcm5lbFZhbHVlQXJyYXkyLFxuICAgICAgJ0FycmF5KDMpJzogV2ViR0xLZXJuZWxWYWx1ZUFycmF5MyxcbiAgICAgICdBcnJheSg0KSc6IFdlYkdMS2VybmVsVmFsdWVBcnJheTQsXG4gICAgICAnQXJyYXkxRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDQpJzogZmFsc2UsXG4gICAgICAnSW5wdXQnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXQsXG4gICAgICAnTnVtYmVyVGV4dHVyZSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMSknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgzKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoNCknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSxcbiAgICAgICdIVE1MQ2FudmFzJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnT2Zmc2NyZWVuQ2FudmFzJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSW1hZ2VCaXRtYXAnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdJbWFnZURhdGEnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IGZhbHNlLFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvLFxuICAgIH0sXG4gICAgc3RhdGljOiB7XG4gICAgICAnQm9vbGVhbic6IFdlYkdMS2VybmVsVmFsdWVCb29sZWFuLFxuICAgICAgJ0Zsb2F0JzogV2ViR0xLZXJuZWxWYWx1ZUZsb2F0LFxuICAgICAgJ0ludGVnZXInOiBXZWJHTEtlcm5lbFZhbHVlSW50ZWdlcixcbiAgICAgICdBcnJheSc6IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0xLZXJuZWxWYWx1ZUFycmF5MixcbiAgICAgICdBcnJheSgzKSc6IFdlYkdMS2VybmVsVmFsdWVBcnJheTMsXG4gICAgICAnQXJyYXkoNCknOiBXZWJHTEtlcm5lbFZhbHVlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCg0KSc6IGZhbHNlLFxuICAgICAgJ0lucHV0JzogV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXQsXG4gICAgICAnTnVtYmVyVGV4dHVyZSc6IFdlYkdMS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgxKSc6IFdlYkdMS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgyKSc6IFdlYkdMS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgzKSc6IFdlYkdMS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSg0KSc6IFdlYkdMS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOiBXZWJHTEtlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSxcbiAgICAgICdIVE1MQ2FudmFzJzogV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdPZmZzY3JlZW5DYW52YXMnOiBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSW1hZ2VCaXRtYXAnOiBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0ltYWdlRGF0YSc6IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBmYWxzZSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTEtlcm5lbFZhbHVlSFRNTFZpZGVvLFxuICAgIH1cbiAgfSxcbiAgc2luZ2xlOiB7XG4gICAgZHluYW1pYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbixcbiAgICAgICdJbnRlZ2VyJzogV2ViR0xLZXJuZWxWYWx1ZUludGVnZXIsXG4gICAgICAnRmxvYXQnOiBXZWJHTEtlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnQXJyYXknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0xLZXJuZWxWYWx1ZUFycmF5MixcbiAgICAgICdBcnJheSgzKSc6IFdlYkdMS2VybmVsVmFsdWVBcnJheTMsXG4gICAgICAnQXJyYXkoNCknOiBXZWJHTEtlcm5lbFZhbHVlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoMyknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoNCknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MkQoMiknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoMyknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoNCknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5M0QoMiknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoMyknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoNCknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0lucHV0JzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgxKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMiknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSg0KSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdPZmZzY3JlZW5DYW52YXMnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdJbWFnZUJpdG1hcCc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0ltYWdlRGF0YSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZUFycmF5JzogZmFsc2UsXG4gICAgICAnSFRNTFZpZGVvJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8sXG4gICAgfSxcbiAgICBzdGF0aWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnRmxvYXQnOiBXZWJHTEtlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnSW50ZWdlcic6IFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0FycmF5JzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0xLZXJuZWxWYWx1ZUFycmF5MixcbiAgICAgICdBcnJheSgzKSc6IFdlYkdMS2VybmVsVmFsdWVBcnJheTMsXG4gICAgICAnQXJyYXkoNCknOiBXZWJHTEtlcm5lbFZhbHVlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREksXG4gICAgICAnQXJyYXkxRCgzKSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTFEKDQpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MkQoMiknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREksXG4gICAgICAnQXJyYXkyRCgzKSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTJEKDQpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5M0QoMiknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREksXG4gICAgICAnQXJyYXkzRCgzKSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSxcbiAgICAgICdBcnJheTNEKDQpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0lucHV0JzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUlucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMSknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMiknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoNCknOiBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnT2Zmc2NyZWVuQ2FudmFzJzogV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0ltYWdlQml0bWFwJzogV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdJbWFnZURhdGEnOiBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZUFycmF5JzogZmFsc2UsXG4gICAgICAnSFRNTFZpZGVvJzogV2ViR0xLZXJuZWxWYWx1ZUhUTUxWaWRlbyxcbiAgICB9XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBsb29rdXBLZXJuZWxWYWx1ZVR5cGUodHlwZSwgZHluYW1pYywgcHJlY2lzaW9uLCB2YWx1ZSkge1xuICBpZiAoIXR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUgbWlzc2luZycpO1xuICB9XG4gIGlmICghZHluYW1pYykge1xuICAgIHRocm93IG5ldyBFcnJvcignZHluYW1pYyBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKCFwcmVjaXNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWNpc2lvbiBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKHZhbHVlLnR5cGUpIHtcbiAgICB0eXBlID0gdmFsdWUudHlwZTtcbiAgfVxuICBjb25zdCB0eXBlcyA9IGtlcm5lbFZhbHVlTWFwc1twcmVjaXNpb25dW2R5bmFtaWNdO1xuICBpZiAodHlwZXNbdHlwZV0gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZXNbdHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBLZXJuZWxWYWx1ZSBmb3IgJHsgdHlwZSB9YCk7XG4gIH1cbiAgcmV0dXJuIHR5cGVzW3R5cGVdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbG9va3VwS2VybmVsVmFsdWVUeXBlLFxuICBrZXJuZWxWYWx1ZU1hcHMsXG59O1xufSx7XCIuL2tlcm5lbC12YWx1ZS9hcnJheTJcIjo0MSxcIi4va2VybmVsLXZhbHVlL2FycmF5M1wiOjQyLFwiLi9rZXJuZWwtdmFsdWUvYXJyYXk0XCI6NDMsXCIuL2tlcm5lbC12YWx1ZS9ib29sZWFuXCI6NDQsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2VcIjo0NSxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtaHRtbC12aWRlb1wiOjQ2LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlXCI6NDcsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLW51bWJlci10ZXh0dXJlXCI6NDgsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheVwiOjQ5LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkxZC1pXCI6NTAsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTJkLWlcIjo1MSxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5M2QtaVwiOjUyLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtaW5wdXRcIjo1MyxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtYXJyYXlcIjo1NCxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtaW5wdXRcIjo1NSxcIi4va2VybmVsLXZhbHVlL2Zsb2F0XCI6NTYsXCIuL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlXCI6NTcsXCIuL2tlcm5lbC12YWx1ZS9odG1sLXZpZGVvXCI6NTgsXCIuL2tlcm5lbC12YWx1ZS9pbnRlZ2VyXCI6NjAsXCIuL2tlcm5lbC12YWx1ZS9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlXCI6NjEsXCIuL2tlcm5lbC12YWx1ZS9udW1iZXItdGV4dHVyZVwiOjYyLFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5XCI6NjMsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkxZC1pXCI6NjQsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyZC1pXCI6NjUsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzZC1pXCI6NjYsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtaW5wdXRcIjo2NyxcIi4va2VybmVsLXZhbHVlL3Vuc2lnbmVkLWFycmF5XCI6NjgsXCIuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1pbnB1dFwiOjY5fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5jb25zdCB7IElucHV0IH0gPSByZXF1aXJlKCcuLi8uLi8uLi9pbnB1dCcpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbEFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZSB7XG4gIGNoZWNrU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCF0aGlzLmtlcm5lbC52YWxpZGF0ZSkgcmV0dXJuO1xuICAgIGNvbnN0IHsgbWF4VGV4dHVyZVNpemUgfSA9IHRoaXMua2VybmVsLmNvbnN0cnVjdG9yLmZlYXR1cmVzO1xuICAgIGlmICh3aWR0aCA+IG1heFRleHR1cmVTaXplIHx8IGhlaWdodCA+IG1heFRleHR1cmVTaXplKSB7XG4gICAgICBpZiAod2lkdGggPiBoZWlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCB0ZXh0dXJlIHdpZHRoIG9mICR7d2lkdGh9IGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZSBvZiAke21heFRleHR1cmVTaXplfSBmb3IgeW91ciBHUFVgKTtcbiAgICAgIH0gZWxzZSBpZiAod2lkdGggPCBoZWlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCB0ZXh0dXJlIGhlaWdodCBvZiAke2hlaWdodH0gbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplIG9mICR7bWF4VGV4dHVyZVNpemV9IGZvciB5b3VyIEdQVWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCB0ZXh0dXJlIGhlaWdodCBhbmQgd2lkdGggb2YgJHtoZWlnaHR9IGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZSBvZiAke21heFRleHR1cmVTaXplfSBmb3IgeW91ciBHUFVgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXR1cCgpIHtcbiAgICB0aGlzLnJlcXVlc3RUZXh0dXJlKCk7XG4gICAgdGhpcy5zZXR1cFRleHR1cmUoKTtcbiAgICB0aGlzLmRlZmluZVRleHR1cmUoKTtcbiAgfVxuXG4gIHJlcXVlc3RUZXh0dXJlKCkge1xuICAgIHRoaXMudGV4dHVyZSA9IHRoaXMub25SZXF1ZXN0VGV4dHVyZSgpO1xuICB9XG5cbiAgZGVmaW5lVGV4dHVyZSgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gIH1cblxuICBzZXR1cFRleHR1cmUoKSB7XG4gICAgdGhpcy5jb250ZXh0SGFuZGxlID0gdGhpcy5vblJlcXVlc3RDb250ZXh0SGFuZGxlKCk7XG4gICAgdGhpcy5pbmRleCA9IHRoaXMub25SZXF1ZXN0SW5kZXgoKTtcbiAgICB0aGlzLmRpbWVuc2lvbnNJZCA9IHRoaXMuaWQgKyAnRGltJztcbiAgICB0aGlzLnNpemVJZCA9IHRoaXMuaWQgKyAnU2l6ZSc7XG4gIH1cblxuICBnZXRCaXRSYXRpbyh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qml0UmF0aW8odmFsdWVbMF0pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IElucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCaXRSYXRpbyh2YWx1ZS52YWx1ZSk7XG4gICAgfVxuICAgIHN3aXRjaCAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgVWludDhDbGFtcGVkQXJyYXk6XG4gICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICBjYXNlIEludDhBcnJheTpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgICByZXR1cm4gMjtcbiAgICAgIGNhc2UgRmxvYXQzMkFycmF5OlxuICAgICAgY2FzZSBJbnQzMkFycmF5OlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5wcmV2QXJnKSB7XG4gICAgICB0aGlzLnByZXZBcmcuZGVsZXRlKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL2lucHV0XCI6MTEwLFwiLi9pbmRleFwiOjU5fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVBcnJheTIgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgcmV0dXJuIGBjb25zdCB2ZWMyICR7dGhpcy5pZH0gPSB2ZWMyKCR7dmFsdWVbMF19LCR7dmFsdWVbMV19KTtcXG5gO1xuICAgIH1cbiAgICByZXR1cm4gYHVuaWZvcm0gdmVjMiAke3RoaXMuaWR9O1xcbmA7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuICcnO1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybjtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMmZ2KHRoaXMuaWQsIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVBcnJheTJcbn07XG59LHtcIi4vaW5kZXhcIjo1OX1dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlQXJyYXkzIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGdldFNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgIHJldHVybiBgY29uc3QgdmVjMyAke3RoaXMuaWR9ID0gdmVjMygke3ZhbHVlWzBdfSwke3ZhbHVlWzFdfSwke3ZhbHVlWzJdfSk7XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGB1bmlmb3JtIHZlYzMgJHt0aGlzLmlkfTtcXG5gO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybiAnJztcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfTtcXG5gO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm47XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNmdih0aGlzLmlkLCB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlQXJyYXkzXG59O1xufSx7XCIuL2luZGV4XCI6NTl9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUFycmF5NCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBnZXRTb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSB7XG4gICAgICByZXR1cm4gYGNvbnN0IHZlYzQgJHt0aGlzLmlkfSA9IHZlYzQoJHt2YWx1ZVswXX0sJHt2YWx1ZVsxXX0sJHt2YWx1ZVsyXX0sJHt2YWx1ZVszXX0pO1xcbmA7XG4gICAgfVxuICAgIHJldHVybiBgdW5pZm9ybSB2ZWM0ICR7dGhpcy5pZH07XFxuYDtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm00ZnYodGhpcy5pZCwgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUFycmF5NFxufTtcbn0se1wiLi9pbmRleFwiOjU5fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbiBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBnZXRTb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSB7XG4gICAgICByZXR1cm4gYGNvbnN0IGJvb2wgJHt0aGlzLmlkfSA9ICR7dmFsdWV9O1xcbmA7XG4gICAgfVxuICAgIHJldHVybiBgdW5pZm9ybSBib29sICR7dGhpcy5pZH07XFxuYDtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfTtcXG5gO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm47XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVCb29sZWFuXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaW5kZXhcIjo1OX1dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4vaHRtbC1pbWFnZScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2Uge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHZhbHVlO1xuICAgIHRoaXMuY2hlY2tTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IFt3aWR0aCwgaGVpZ2h0LCAxXTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gW3dpZHRoLCBoZWlnaHRdO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2h0bWwtaW1hZ2VcIjo1N31dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4vZHluYW1pYy1odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2Uge31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvXG59O1xufSx7XCIuL2R5bmFtaWMtaHRtbC1pbWFnZVwiOjQ1fV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4vbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbnB1dFRleHR1cmUpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBpbnB1dFRleHR1cmUuZGltZW5zaW9ucztcbiAgICB0aGlzLmNoZWNrU2l6ZShpbnB1dFRleHR1cmUuc2l6ZVswXSwgaW5wdXRUZXh0dXJlLnNpemVbMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSBpbnB1dFRleHR1cmUuc2l6ZTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKGlucHV0VGV4dHVyZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo2MX1dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL251bWJlci10ZXh0dXJlJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gdmFsdWUuZGltZW5zaW9ucztcbiAgICB0aGlzLmNoZWNrU2l6ZSh2YWx1ZS5zaXplWzBdLCB2YWx1ZS5zaXplWzFdKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vbnVtYmVyLXRleHR1cmVcIjo2Mn1dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheSB9ID0gcmVxdWlyZSgnLi9zaW5nbGUtYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IHV0aWxzLmdldERpbWVuc2lvbnModmFsdWUsIHRydWUpO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3NpbmdsZS1hcnJheVwiOjYzfV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJIH0gPSByZXF1aXJlKCcuL3NpbmdsZS1hcnJheTFkLWknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vc2luZ2xlLWFycmF5MWQtaVwiOjY0fV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIH0gPSByZXF1aXJlKCcuL3NpbmdsZS1hcnJheTJkLWknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vc2luZ2xlLWFycmF5MmQtaVwiOjY1fV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJIH0gPSByZXF1aXJlKCcuL3NpbmdsZS1hcnJheTNkLWknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vc2luZ2xlLWFycmF5M2QtaVwiOjY2fV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUlucHV0IH0gPSByZXF1aXJlKCcuL3NpbmdsZS1pbnB1dCcpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUlucHV0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUlucHV0IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgbGV0IFt3LCBoLCBkXSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IEludDMyQXJyYXkoW3cgfHwgMSwgaCB8fCAxLCBkIHx8IDFdKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlSW5wdXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9zaW5nbGUtaW5wdXRcIjo2N31dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuL3Vuc2lnbmVkLWFycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZFBhY2tlZFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogKDQgLyB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICBjb25zdCBUeXBlID0gdGhpcy5nZXRUcmFuc2ZlckFycmF5VHlwZSh2YWx1ZSk7XG4gICAgdGhpcy5wcmVVcGxvYWRWYWx1ZSA9IG5ldyBUeXBlKHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgVWludDhBcnJheSh0aGlzLnByZVVwbG9hZFZhbHVlLmJ1ZmZlcik7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3Vuc2lnbmVkLWFycmF5XCI6Njh9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCB9ID0gcmVxdWlyZSgnLi91bnNpZ25lZC1pbnB1dCcpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXQgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGxldCBbdywgaCwgZF0gPSB2YWx1ZS5zaXplO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBJbnQzMkFycmF5KFt3IHx8IDEsIGggfHwgMSwgZCB8fCAxXSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZFBhY2tlZFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogKDQgLyB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICBjb25zdCBUeXBlID0gdGhpcy5nZXRUcmFuc2ZlckFycmF5VHlwZSh2YWx1ZS52YWx1ZSk7XG4gICAgdGhpcy5wcmVVcGxvYWRWYWx1ZSA9IG5ldyBUeXBlKHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgVWludDhBcnJheSh0aGlzLnByZVVwbG9hZFZhbHVlLmJ1ZmZlcik7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3Vuc2lnbmVkLWlucHV0XCI6Njl9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVGbG9hdCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuICBnZXRTb3VyY2UodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSB7XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGBjb25zdCBmbG9hdCAke3RoaXMuaWR9ID0gJHt2YWx1ZX0uMDtcXG5gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBjb25zdCBmbG9hdCAke3RoaXMuaWR9ID0gJHt2YWx1ZX07XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGB1bmlmb3JtIGZsb2F0ICR7dGhpcy5pZH07XFxuYDtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xZih0aGlzLmlkLCB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRmxvYXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9pbmRleFwiOjU5fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB2YWx1ZTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBbd2lkdGgsIGhlaWdodCwgMV07XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbnB1dEltYWdlKSB7XG4gICAgaWYgKGlucHV0SW1hZ2UuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKGlucHV0SW1hZ2UuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy51cGxvYWRWYWx1ZSA9IGlucHV0SW1hZ2UpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw1ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4vaHRtbC1pbWFnZScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlSFRNTFZpZGVvIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUhUTUxWaWRlb1xufTtcbn0se1wiLi9odG1sLWltYWdlXCI6NTd9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBLZXJuZWxWYWx1ZSB9ID0gcmVxdWlyZSgnLi4vLi4va2VybmVsLXZhbHVlJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWUgZXh0ZW5kcyBLZXJuZWxWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5kaW1lbnNpb25zSWQgPSBudWxsO1xuICAgIHRoaXMuc2l6ZUlkID0gbnVsbDtcbiAgICB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yID0gdmFsdWUuY29uc3RydWN0b3I7XG4gICAgdGhpcy5vblJlcXVlc3RUZXh0dXJlID0gc2V0dGluZ3Mub25SZXF1ZXN0VGV4dHVyZTtcbiAgICB0aGlzLm9uUmVxdWVzdEluZGV4ID0gc2V0dGluZ3Mub25SZXF1ZXN0SW5kZXg7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IG51bGw7XG4gICAgdGhpcy5iaXRSYXRpbyA9IG51bGw7XG4gICAgdGhpcy5wcmV2QXJnID0gbnVsbDtcbiAgfVxuXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcmlnaW59XyR7dXRpbHMuc2FuaXRpemVOYW1lKHRoaXMubmFtZSl9YDtcbiAgfVxuXG4gIHNldHVwKCkge31cblxuICBnZXRUcmFuc2ZlckFycmF5VHlwZSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNmZXJBcnJheVR5cGUodmFsdWVbMF0pO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIEFycmF5OlxuICAgICAgY2FzZSBJbnQzMkFycmF5OlxuICAgICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiBGbG9hdDMyQXJyYXk7XG4gICAgICBjYXNlIFVpbnQ4Q2xhbXBlZEFycmF5OlxuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgIGNhc2UgRmxvYXQ2NEFycmF5OlxuICAgICAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIGNvbnNvbGUud2FybignVW5mYW1pbGlhciBjb25zdHJ1Y3RvciB0eXBlLiAgV2lsbCBnbyBhaGVhZCBhbmQgdXNlLCBidXQgbGlrbGV5IHRoaXMgbWF5IHJlc3VsdCBpbiBhIHRyYW5zZmVyIG9mIHplcm9zJyk7XG4gICAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJnZXRTdHJpbmdWYWx1ZUhhbmRsZXJcIiBub3QgaW1wbGVtZW50ZWQgb24gJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIH1cblxuICBnZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5rZXJuZWwuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcodGhpcy50ZXh0dXJlU2l6ZSB8fCB1bmRlZmluZWQsIHRoaXMudGFjdGljIHx8IHVuZGVmaW5lZCk7XG4gIH1cblxuICBkZXN0cm95KCkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4va2VybmVsLXZhbHVlXCI6MzV9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfTtcXG5gO1xuICB9XG4gIGdldFNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgIHJldHVybiBgY29uc3QgaW50ICR7dGhpcy5pZH0gPSAkeyBwYXJzZUludCh2YWx1ZSkgfTtcXG5gO1xuICAgIH1cbiAgICByZXR1cm4gYHVuaWZvcm0gaW50ICR7dGhpcy5pZH07XFxuYDtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlSW50ZWdlclxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2luZGV4XCI6NTl9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5cbmNvbnN0IHNhbWVFcnJvciA9IGBTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIHRleHR1cmVzIGFyZSB0aGUgc2FtZS4gIFVzZSBpbW11dGFibGUgPSB0cnVlIGFuZCBtYW51YWxseSBjbGVhbnVwIGtlcm5lbCBvdXRwdXQgdGV4dHVyZSBtZW1vcnkgd2l0aCB0ZXh0dXJlLmRlbGV0ZSgpYDtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB2YWx1ZS5zaXplO1xuICAgIHRoaXMuY2hlY2tTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IHZhbHVlLmRpbWVuc2lvbnM7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlLnRleHR1cmU7XG4gICAgdGhpcy5mb3JjZVVwbG9hZEVhY2hSdW4gPSB0cnVlO1xuICB9XG5cbiAgc2V0dXAoKSB7XG4gICAgdGhpcy5zZXR1cFRleHR1cmUoKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfS50ZXh0dXJlO1xcbmA7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXRUZXh0dXJlKSB7XG4gICAgaWYgKGlucHV0VGV4dHVyZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2goaW5wdXRUZXh0dXJlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hlY2tDb250ZXh0ICYmIGlucHV0VGV4dHVyZS5jb250ZXh0ICE9PSB0aGlzLmNvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgJHt0aGlzLm5hbWV9ICgke3RoaXMudHlwZX0pIG11c3QgYmUgZnJvbSBzYW1lIGNvbnRleHRgKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGtlcm5lbCwgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgaWYgKGtlcm5lbC5waXBlbGluZSkge1xuICAgICAgaWYgKGtlcm5lbC5pbW11dGFibGUpIHtcbiAgICAgICAga2VybmVsLnVwZGF0ZVRleHR1cmVBcmd1bWVudFJlZnModGhpcywgaW5wdXRUZXh0dXJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXJuZWwudGV4dHVyZSAmJiBrZXJuZWwudGV4dHVyZS50ZXh0dXJlID09PSBpbnB1dFRleHR1cmUudGV4dHVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzYW1lRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGtlcm5lbC5tYXBwZWRUZXh0dXJlcykge1xuICAgICAgICAgIGNvbnN0IHsgbWFwcGVkVGV4dHVyZXMgfSA9IGtlcm5lbDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcHBlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWFwcGVkVGV4dHVyZXNbaV0udGV4dHVyZSA9PT0gaW5wdXRUZXh0dXJlLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNhbWVFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudXBsb2FkVmFsdWUgPSBpbnB1dFRleHR1cmUudGV4dHVyZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSxcbiAgc2FtZUVycm9yXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcbmNvbnN0IHsgc2FtZUVycm9yIH0gPSByZXF1aXJlKCcuL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB2YWx1ZS5zaXplO1xuICAgIHRoaXMuY2hlY2tTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHsgc2l6ZTogdGV4dHVyZVNpemUsIGRpbWVuc2lvbnMgfSA9IHZhbHVlO1xuICAgIHRoaXMuYml0UmF0aW8gPSB0aGlzLmdldEJpdFJhdGlvKHZhbHVlKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB0ZXh0dXJlU2l6ZTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUudGV4dHVyZTtcbiAgICB0aGlzLmZvcmNlVXBsb2FkRWFjaFJ1biA9IHRydWU7XG4gIH1cblxuICBzZXR1cCgpIHtcbiAgICB0aGlzLnNldHVwVGV4dHVyZSgpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9LnRleHR1cmU7XFxuYDtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbnB1dFRleHR1cmUpIHtcbiAgICBpZiAoaW5wdXRUZXh0dXJlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaChpbnB1dFRleHR1cmUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGVja0NvbnRleHQgJiYgaW5wdXRUZXh0dXJlLmNvbnRleHQgIT09IHRoaXMuY29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSAke3RoaXMubmFtZX0gKCR7dGhpcy50eXBlfSkgbXVzdCBiZSBmcm9tIHNhbWUgY29udGV4dGApO1xuICAgIH1cblxuICAgIGNvbnN0IHsga2VybmVsLCBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBpZiAoa2VybmVsLnBpcGVsaW5lKSB7XG4gICAgICBpZiAoa2VybmVsLmltbXV0YWJsZSkge1xuICAgICAgICBrZXJuZWwudXBkYXRlVGV4dHVyZUFyZ3VtZW50UmVmcyh0aGlzLCBpbnB1dFRleHR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGtlcm5lbC50ZXh0dXJlICYmIGtlcm5lbC50ZXh0dXJlLnRleHR1cmUgPT09IGlucHV0VGV4dHVyZS50ZXh0dXJlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNhbWVFcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoa2VybmVsLm1hcHBlZFRleHR1cmVzKSB7XG4gICAgICAgICAgY29uc3QgeyBtYXBwZWRUZXh0dXJlcyB9ID0ga2VybmVsO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcGVkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChtYXBwZWRUZXh0dXJlc1tpXS50ZXh0dXJlID09PSBpbnB1dFRleHR1cmUudGV4dHVyZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2FtZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy51cGxvYWRWYWx1ZSA9IGlucHV0VGV4dHVyZS50ZXh0dXJlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MCxcIi4vbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZVwiOjYxfV0sNjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmJpdFJhdGlvID0gNDtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyBGbG9hdDMyQXJyYXkoJHt0aGlzLnVwbG9hZEFycmF5TGVuZ3RofSlgLFxuICAgICAgYGZsYXR0ZW5Ubygke3RoaXMudmFyTmFtZX0sIHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmJpdFJhdGlvID0gNDtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgfVxuXG4gIHNldFNoYXBlKHZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVEaW1lbnNpb25zID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodmFsdWVEaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdmFsdWVEaW1lbnNpb25zWzFdLCAxLCAxXSk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3IEZsb2F0MzJBcnJheSgke3RoaXMudXBsb2FkQXJyYXlMZW5ndGh9KWAsXG4gICAgICBgZmxhdHRlblRvKCR7dGhpcy52YXJOYW1lfSwgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9KWAsXG4gICAgXSk7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuMmRBcnJheVRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmJpdFJhdGlvID0gNDtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgfVxuXG4gIHNldFNoYXBlKHZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVEaW1lbnNpb25zID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodmFsdWVEaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdmFsdWVEaW1lbnNpb25zWzFdLCB2YWx1ZURpbWVuc2lvbnNbMl0sIDFdKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiB0aGlzLmJpdFJhdGlvO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgRmxvYXQzMkFycmF5KCR7dGhpcy51cGxvYWRBcnJheUxlbmd0aH0pYCxcbiAgICAgIGBmbGF0dGVuVG8oJHt0aGlzLnZhck5hbWV9LCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW4zZEFycmF5VG8odmFsdWUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw2NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuYml0UmF0aW8gPSA0O1xuICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICB9XG5cbiAgc2V0U2hhcGUodmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZURpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh2YWx1ZURpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBJbnQzMkFycmF5KFt2YWx1ZURpbWVuc2lvbnNbMV0sIHZhbHVlRGltZW5zaW9uc1syXSwgdmFsdWVEaW1lbnNpb25zWzNdXSk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3IEZsb2F0MzJBcnJheSgke3RoaXMudXBsb2FkQXJyYXlMZW5ndGh9KWAsXG4gICAgICBgZmxhdHRlblRvKCR7dGhpcy52YXJOYW1lfSwgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9KWAsXG4gICAgXSk7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuNGRBcnJheVRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXQgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmJpdFJhdGlvID0gNDtcbiAgICBsZXQgW3csIGgsIGRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdyB8fCAxLCBoIHx8IDEsIGQgfHwgMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3IEZsb2F0MzJBcnJheSgke3RoaXMudXBsb2FkQXJyYXlMZW5ndGh9KWAsXG4gICAgICBgZmxhdHRlblRvKCR7dGhpcy52YXJOYW1lfS52YWx1ZSwgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9KWAsXG4gICAgXSk7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKGlucHV0LmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuVG8oaW5wdXQudmFsdWUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw2ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5iaXRSYXRpbyA9IHRoaXMuZ2V0Qml0UmF0aW8odmFsdWUpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IHV0aWxzLmdldERpbWVuc2lvbnModmFsdWUsIHRydWUpO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRQYWNrZWRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqICg0IC8gdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy5UcmFuc2VyQXJyYXlUeXBlID0gdGhpcy5nZXRUcmFuc2ZlckFycmF5VHlwZSh2YWx1ZSk7XG4gICAgdGhpcy5wcmVVcGxvYWRWYWx1ZSA9IG5ldyB0aGlzLlRyYW5zZXJBcnJheVR5cGUodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMucHJlVXBsb2FkVmFsdWUuYnVmZmVyKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgcHJlVXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3ICR7dGhpcy5UcmFuc2VyQXJyYXlUeXBlLm5hbWV9KCR7dGhpcy51cGxvYWRBcnJheUxlbmd0aH0pYCxcbiAgICAgIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgVWludDhBcnJheShwcmVVcGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0uYnVmZmVyKWAsXG4gICAgICBgZmxhdHRlblRvKCR7dGhpcy52YXJOYW1lfSwgcHJlVXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9KWAsXG4gICAgXSk7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuVG8odmFsdWUsIHRoaXMucHJlVXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuYml0UmF0aW8gPSB0aGlzLmdldEJpdFJhdGlvKHZhbHVlKTtcbiAgICBjb25zdCBbdywgaCwgZF0gPSB2YWx1ZS5zaXplO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBJbnQzMkFycmF5KFt3IHx8IDEsIGggfHwgMSwgZCB8fCAxXSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZFBhY2tlZFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogKDQgLyB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLlRyYW5zZXJBcnJheVR5cGUgPSB0aGlzLmdldFRyYW5zZmVyQXJyYXlUeXBlKHZhbHVlLnZhbHVlKTtcbiAgICB0aGlzLnByZVVwbG9hZFZhbHVlID0gbmV3IHRoaXMuVHJhbnNlckFycmF5VHlwZSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5wcmVVcGxvYWRWYWx1ZS5idWZmZXIpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGBjb25zdCBwcmVVcGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgJHt0aGlzLlRyYW5zZXJBcnJheVR5cGUubmFtZX0oJHt0aGlzLnVwbG9hZEFycmF5TGVuZ3RofSlgLFxuICAgICAgYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyBVaW50OEFycmF5KHByZVVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfS5idWZmZXIpYCxcbiAgICAgIGBmbGF0dGVuVG8oJHt0aGlzLnZhck5hbWV9LnZhbHVlLCBwcmVVcGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbnB1dCkge1xuICAgIGlmIChpbnB1dC5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5UbyhpbnB1dC52YWx1ZSwgdGhpcy5wcmVVcGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw3MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IEdMS2VybmVsIH0gPSByZXF1aXJlKCcuLi9nbC9rZXJuZWwnKTtcbmNvbnN0IHsgRnVuY3Rpb25CdWlsZGVyIH0gPSByZXF1aXJlKCcuLi9mdW5jdGlvbi1idWlsZGVyJyk7XG5jb25zdCB7IFdlYkdMRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCBtcnVkID0gcmVxdWlyZSgnLi4vLi4vcGx1Z2lucy9tYXRoLXJhbmRvbS11bmlmb3JtbHktZGlzdHJpYnV0ZWQnKTtcbmNvbnN0IHsgZnJhZ21lbnRTaGFkZXIgfSA9IHJlcXVpcmUoJy4vZnJhZ21lbnQtc2hhZGVyJyk7XG5jb25zdCB7IHZlcnRleFNoYWRlciB9ID0gcmVxdWlyZSgnLi92ZXJ0ZXgtc2hhZGVyJyk7XG5jb25zdCB7IGdsS2VybmVsU3RyaW5nIH0gPSByZXF1aXJlKCcuLi9nbC9rZXJuZWwtc3RyaW5nJyk7XG5jb25zdCB7IGxvb2t1cEtlcm5lbFZhbHVlVHlwZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUtbWFwcycpO1xuXG5sZXQgaXNTdXBwb3J0ZWQgPSBudWxsO1xubGV0IHRlc3RDYW52YXMgPSBudWxsO1xubGV0IHRlc3RDb250ZXh0ID0gbnVsbDtcbmxldCB0ZXN0RXh0ZW5zaW9ucyA9IG51bGw7XG5sZXQgZmVhdHVyZXMgPSBudWxsO1xuXG5jb25zdCBwbHVnaW5zID0gW21ydWRdO1xuY29uc3QgY2FudmFzZXMgPSBbXTtcbmNvbnN0IG1heFRleFNpemVzID0ge307XG5cblxuY2xhc3MgV2ViR0xLZXJuZWwgZXh0ZW5kcyBHTEtlcm5lbCB7XG4gIHN0YXRpYyBnZXQgaXNTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gICAgfVxuICAgIHRoaXMuc2V0dXBGZWF0dXJlQ2hlY2tzKCk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0aGlzLmlzQ29udGV4dE1hdGNoKHRlc3RDb250ZXh0KTtcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgc2V0dXBGZWF0dXJlQ2hlY2tzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0ZXN0Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGVzdENhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMCwgMCk7XG4gICAgfVxuICAgIGlmICghdGVzdENhbnZhcykgcmV0dXJuO1xuICAgIHRlc3RDb250ZXh0ID0gdGVzdENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8IHRlc3RDYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJyk7XG4gICAgaWYgKCF0ZXN0Q29udGV4dCB8fCAhdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKSByZXR1cm47XG4gICAgdGVzdEV4dGVuc2lvbnMgPSB7XG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdDogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpLFxuICAgICAgT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpLFxuICAgICAgT0VTX2VsZW1lbnRfaW5kZXhfdWludDogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JyksXG4gICAgICBXRUJHTF9kcmF3X2J1ZmZlcnM6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyksXG4gICAgfTtcbiAgICBmZWF0dXJlcyA9IHRoaXMuZ2V0RmVhdHVyZXMoKTtcbiAgfVxuXG4gIHN0YXRpYyBpc0NvbnRleHRNYXRjaChjb250ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gY29udGV4dCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGdldElzVGV4dHVyZUZsb2F0KCkge1xuICAgIHJldHVybiBCb29sZWFuKHRlc3RFeHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc0RyYXdCdWZmZXJzKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRlc3RFeHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0Q2hhbm5lbENvdW50KCkge1xuICAgIHJldHVybiB0ZXN0RXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMgP1xuICAgICAgdGVzdENvbnRleHQuZ2V0UGFyYW1ldGVyKHRlc3RFeHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycy5NQVhfRFJBV19CVUZGRVJTX1dFQkdMKSA6XG4gICAgICAxO1xuICB9XG5cbiAgc3RhdGljIGdldE1heFRleHR1cmVTaXplKCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dC5nZXRQYXJhbWV0ZXIodGVzdENvbnRleHQuTUFYX1RFWFRVUkVfU0laRSk7XG4gIH1cblxuICBzdGF0aWMgbG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIGR5bmFtaWMsIHByZWNpc2lvbiwgdmFsdWUpIHtcbiAgICByZXR1cm4gbG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIGR5bmFtaWMsIHByZWNpc2lvbiwgdmFsdWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q2FudmFzKCkge1xuICAgIHJldHVybiB0ZXN0Q2FudmFzO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGVzdENvbnRleHQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGZlYXR1cmVzKCkge1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZnJhZ21lbnRTaGFkZXIoKSB7XG4gICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICB9XG5cbiAgc3RhdGljIGdldCB2ZXJ0ZXhTaGFkZXIoKSB7XG4gICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzb3VyY2UsIHNldHRpbmdzKTtcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgIHRoaXMucGlwZWxpbmUgPSBzZXR0aW5ncy5waXBlbGluZTtcbiAgICB0aGlzLmVuZGlhbm5lc3MgPSB1dGlscy5zeXN0ZW1FbmRpYW5uZXNzKCk7XG4gICAgdGhpcy5leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5hcmd1bWVudFRleHR1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5jb25zdGFudFRleHR1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5mcmFnU2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLnZlcnRTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuZHJhd0J1ZmZlcnNNYXAgPSBudWxsO1xuXG4gICAgdGhpcy5tYXhUZXhTaXplID0gbnVsbDtcbiAgICB0aGlzLm9uUmVxdWVzdFN3aXRjaEtlcm5lbCA9IG51bGw7XG5cbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMubWFwcGVkVGV4dHVyZXMgPSBudWxsO1xuICAgIHRoaXMubWVyZ2VTZXR0aW5ncyhzb3VyY2Uuc2V0dGluZ3MgfHwgc2V0dGluZ3MpO1xuXG4gICAgdGhpcy50aHJlYWREaW0gPSBudWxsO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBudWxsO1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcblxuICAgIHRoaXMudGV4dHVyZUNhY2hlID0gW107XG4gICAgdGhpcy5wcm9ncmFtVW5pZm9ybUxvY2F0aW9uQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm0xZkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtMWlDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTJmQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm0yZnZDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTJpdkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtM2Z2Q2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm0zaXZDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTRmdkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtNGl2Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIGluaXRDYW52YXMoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLndpZHRoID0gMjtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSAyO1xuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygwLCAwKTtcbiAgICB9XG4gIH1cblxuICBpbml0Q29udGV4dCgpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgIGRlcHRoOiBmYWxzZSxcbiAgICAgIGFudGlhbGlhczogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIHNldHRpbmdzKSB8fCB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBzZXR0aW5ncyk7XG4gIH1cblxuICBpbml0UGx1Z2lucyhzZXR0aW5ncykge1xuICAgIGNvbnN0IHBsdWdpbnNUb1VzZSA9IFtdO1xuICAgIGNvbnN0IHsgc291cmNlIH0gPSB0aGlzO1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICAgIGlmIChzb3VyY2UubWF0Y2gocGx1Z2luLmZ1bmN0aW9uTWF0Y2gpKSB7XG4gICAgICAgICAgcGx1Z2luc1RvVXNlLnB1c2gocGx1Z2luKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChzZXR0aW5ncy5wbHVnaW5OYW1lcykgeyBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgICAgICBjb25zdCB1c2VQbHVnaW4gPSBzZXR0aW5ncy5wbHVnaW5OYW1lcy5zb21lKHBsdWdpbk5hbWUgPT4gcGx1Z2luTmFtZSA9PT0gcGx1Z2luLm5hbWUpO1xuICAgICAgICAgIGlmICh1c2VQbHVnaW4pIHtcbiAgICAgICAgICAgIHBsdWdpbnNUb1VzZS5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW5zVG9Vc2U7XG4gIH1cblxuICBpbml0RXh0ZW5zaW9ucygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7XG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcbiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyksXG4gICAgICBPRVNfZWxlbWVudF9pbmRleF91aW50OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JyksXG4gICAgICBXRUJHTF9kcmF3X2J1ZmZlcnM6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxuICAgICAgV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKSxcbiAgICB9O1xuICB9XG5cbiAgdmFsaWRhdGVTZXR0aW5ncyhhcmdzKSB7XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlKSB7XG4gICAgICB0aGlzLnRleFNpemUgPSB1dGlscy5nZXRLZXJuZWxUZXh0dXJlU2l6ZSh7XG4gICAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgICAgcHJlY2lzaW9uOiB0aGlzLnByZWNpc2lvbixcbiAgICAgIH0sIHRoaXMub3V0cHV0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IGZlYXR1cmVzIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSA9PT0gdHJ1ZSAmJiAhZmVhdHVyZXMuaXNUZXh0dXJlRmxvYXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmxvYXQgdGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJyAmJiAhZmVhdHVyZXMuaXNGbG9hdFJlYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2luZ2xlIHByZWNpc2lvbiBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5ncmFwaGljYWwgJiYgdGhpcy5wcmVjaXNpb24gPT09IG51bGwgJiYgZmVhdHVyZXMuaXNUZXh0dXJlRmxvYXQpIHtcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gZmVhdHVyZXMuaXNGbG9hdFJlYWQgPyAnc2luZ2xlJyA6ICd1bnNpZ25lZCc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3ViS2VybmVscyAmJiB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoID4gMCAmJiAhdGhpcy5leHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgaW5zdGFudGlhdGUgZHJhdyBidWZmZXJzIGV4dGVuc2lvbicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID09PSBudWxsKSB7XG4gICAgICB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gIWZlYXR1cmVzLmlzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ICYmIGZlYXR1cmVzLmlzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUpIHtcbiAgICAgIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrT3V0cHV0KCk7XG5cbiAgICBpZiAoIXRoaXMub3V0cHV0IHx8IHRoaXMub3V0cHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0byBvdXRwdXQgb25seSBzdXBwb3J0ZWQgZm9yIGtlcm5lbHMgd2l0aCBvbmx5IG9uZSBpbnB1dCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhcmdUeXBlID0gdXRpbHMuZ2V0VmFyaWFibGVUeXBlKGFyZ3NbMF0sIHRoaXMuc3RyaWN0SW50ZWdlcnMpO1xuICAgICAgc3dpdGNoIChhcmdUeXBlKSB7XG4gICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICB0aGlzLm91dHB1dCA9IHV0aWxzLmdldERpbWVuc2lvbnMoYXJnVHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ051bWJlclRleHR1cmUnOlxuICAgICAgICBjYXNlICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDIpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcbiAgICAgICAgICB0aGlzLm91dHB1dCA9IGFyZ3NbMF0ub3V0cHV0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0byBvdXRwdXQgbm90IHN1cHBvcnRlZCBmb3IgaW5wdXQgdHlwZTogJyArIGFyZ1R5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgaWYgKHRoaXMub3V0cHV0Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dHB1dCBtdXN0IGhhdmUgMiBkaW1lbnNpb25zIG9uIGdyYXBoaWNhbCBtb2RlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3ByZWNpc2lvbicpIHtcbiAgICAgICAgdGhpcy5wcmVjaXNpb24gPSAndW5zaWduZWQnO1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCB1c2UgZ3JhcGhpY2FsIG1vZGUgYW5kIHNpbmdsZSBwcmVjaXNpb24gYXQgdGhlIHNhbWUgdGltZScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRleFNpemUgPSB1dGlscy5jbG9uZSh0aGlzLm91dHB1dCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gbnVsbCAmJiBmZWF0dXJlcy5pc1RleHR1cmVGbG9hdCkge1xuICAgICAgdGhpcy5wcmVjaXNpb24gPSAnc2luZ2xlJztcbiAgICB9XG5cbiAgICB0aGlzLnRleFNpemUgPSB1dGlscy5nZXRLZXJuZWxUZXh0dXJlU2l6ZSh7XG4gICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICBwcmVjaXNpb246IHRoaXMucHJlY2lzaW9uLFxuICAgIH0sIHRoaXMub3V0cHV0KTtcblxuICAgIHRoaXMuY2hlY2tUZXh0dXJlU2l6ZSgpO1xuICB9XG5cbiAgdXBkYXRlTWF4VGV4U2l6ZSgpIHtcbiAgICBjb25zdCB7IHRleFNpemUsIGNhbnZhcyB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5tYXhUZXhTaXplID09PSBudWxsKSB7XG4gICAgICBsZXQgY2FudmFzSW5kZXggPSBjYW52YXNlcy5pbmRleE9mKGNhbnZhcyk7XG4gICAgICBpZiAoY2FudmFzSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGNhbnZhc0luZGV4ID0gY2FudmFzZXMubGVuZ3RoO1xuICAgICAgICBjYW52YXNlcy5wdXNoKGNhbnZhcyk7XG4gICAgICAgIG1heFRleFNpemVzW2NhbnZhc0luZGV4XSA9IFt0ZXhTaXplWzBdLCB0ZXhTaXplWzFdXTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWF4VGV4U2l6ZSA9IG1heFRleFNpemVzW2NhbnZhc0luZGV4XTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4VGV4U2l6ZVswXSA8IHRleFNpemVbMF0pIHtcbiAgICAgIHRoaXMubWF4VGV4U2l6ZVswXSA9IHRleFNpemVbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLm1heFRleFNpemVbMV0gPCB0ZXhTaXplWzFdKSB7XG4gICAgICB0aGlzLm1heFRleFNpemVbMV0gPSB0ZXhTaXplWzFdO1xuICAgIH1cbiAgfVxuXG4gIHNldHVwQXJndW1lbnRzKGFyZ3MpIHtcbiAgICB0aGlzLmtlcm5lbEFyZ3VtZW50cyA9IFtdO1xuICAgIHRoaXMuYXJndW1lbnRUZXh0dXJlQ291bnQgPSAwO1xuICAgIGNvbnN0IG5lZWRzQXJndW1lbnRUeXBlcyA9IHRoaXMuYXJndW1lbnRUeXBlcyA9PT0gbnVsbDtcbiAgICBpZiAobmVlZHNBcmd1bWVudFR5cGVzKSB7XG4gICAgICB0aGlzLmFyZ3VtZW50VHlwZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5hcmd1bWVudFNpemVzID0gW107XG4gICAgdGhpcy5hcmd1bWVudEJpdFJhdGlvcyA9IFtdO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgZW5vdWdoIGFyZ3VtZW50cyBmb3Iga2VybmVsJyk7XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA+IHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndG9vIG1hbnkgYXJndW1lbnRzIGZvciBrZXJuZWwnKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGxldCB0ZXh0dXJlSW5kZXhlcyA9IDA7XG5cbiAgICBjb25zdCBvblJlcXVlc3RUZXh0dXJlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZSgpO1xuICAgIH07XG4gICAgY29uc3Qgb25SZXF1ZXN0SW5kZXggPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdGFudFRleHR1cmVDb3VudCArIHRleHR1cmVJbmRleGVzKys7XG4gICAgfTtcbiAgICBjb25zdCBvblVwZGF0ZVZhbHVlTWlzbWF0Y2ggPSAoY29uc3RydWN0b3IpID0+IHtcbiAgICAgIHRoaXMuc3dpdGNoS2VybmVscyh7XG4gICAgICAgIHR5cGU6ICdhcmd1bWVudE1pc21hdGNoJyxcbiAgICAgICAgbmVlZGVkOiBjb25zdHJ1Y3RvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvblJlcXVlc3RDb250ZXh0SGFuZGxlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudFRleHR1cmVDb3VudCArIHRoaXMuYXJndW1lbnRUZXh0dXJlQ291bnQrKztcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFyZ3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgY29uc3QgbmFtZSA9IHRoaXMuYXJndW1lbnROYW1lc1tpbmRleF07XG4gICAgICBsZXQgdHlwZTtcbiAgICAgIGlmIChuZWVkc0FyZ3VtZW50VHlwZXMpIHtcbiAgICAgICAgdHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZSh2YWx1ZSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICAgIHRoaXMuYXJndW1lbnRUeXBlcy5wdXNoKHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHRoaXMuYXJndW1lbnRUeXBlc1tpbmRleF07XG4gICAgICB9XG4gICAgICBjb25zdCBLZXJuZWxWYWx1ZSA9IHRoaXMuY29uc3RydWN0b3IubG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIHRoaXMuZHluYW1pY0FyZ3VtZW50cyA/ICdkeW5hbWljJyA6ICdzdGF0aWMnLCB0aGlzLnByZWNpc2lvbiwgYXJnc1tpbmRleF0pO1xuICAgICAgaWYgKEtlcm5lbFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RGYWxsYmFjayhhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtlcm5lbEFyZ3VtZW50ID0gbmV3IEtlcm5lbFZhbHVlKHZhbHVlLCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRhY3RpYzogdGhpcy50YWN0aWMsXG4gICAgICAgIG9yaWdpbjogJ3VzZXInLFxuICAgICAgICBjb250ZXh0OiBnbCxcbiAgICAgICAgY2hlY2tDb250ZXh0OiB0aGlzLmNoZWNrQ29udGV4dCxcbiAgICAgICAga2VybmVsOiB0aGlzLFxuICAgICAgICBzdHJpY3RJbnRlZ2VyczogdGhpcy5zdHJpY3RJbnRlZ2VycyxcbiAgICAgICAgb25SZXF1ZXN0VGV4dHVyZSxcbiAgICAgICAgb25SZXF1ZXN0SW5kZXgsXG4gICAgICAgIG9uVXBkYXRlVmFsdWVNaXNtYXRjaCxcbiAgICAgICAgb25SZXF1ZXN0Q29udGV4dEhhbmRsZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5rZXJuZWxBcmd1bWVudHMucHVzaChrZXJuZWxBcmd1bWVudCk7XG4gICAgICBrZXJuZWxBcmd1bWVudC5zZXR1cCgpO1xuICAgICAgdGhpcy5hcmd1bWVudFNpemVzLnB1c2goa2VybmVsQXJndW1lbnQudGV4dHVyZVNpemUpO1xuICAgICAgdGhpcy5hcmd1bWVudEJpdFJhdGlvc1tpbmRleF0gPSBrZXJuZWxBcmd1bWVudC5iaXRSYXRpbztcbiAgICB9XG4gIH1cblxuICBjcmVhdGVUZXh0dXJlKCkge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmNvbnRleHQuY3JlYXRlVGV4dHVyZSgpO1xuICAgIHRoaXMudGV4dHVyZUNhY2hlLnB1c2godGV4dHVyZSk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cblxuICBzZXR1cENvbnN0YW50cyhhcmdzKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB0aGlzLmtlcm5lbENvbnN0YW50cyA9IFtdO1xuICAgIHRoaXMuZm9yY2VVcGxvYWRLZXJuZWxDb25zdGFudHMgPSBbXTtcbiAgICBsZXQgbmVlZHNDb25zdGFudFR5cGVzID0gdGhpcy5jb25zdGFudFR5cGVzID09PSBudWxsO1xuICAgIGlmIChuZWVkc0NvbnN0YW50VHlwZXMpIHtcbiAgICAgIHRoaXMuY29uc3RhbnRUeXBlcyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmNvbnN0YW50Qml0UmF0aW9zID0ge307XG4gICAgbGV0IHRleHR1cmVJbmRleGVzID0gMDtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5jb25zdGFudHMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jb25zdGFudHNbbmFtZV07XG4gICAgICBsZXQgdHlwZTtcbiAgICAgIGlmIChuZWVkc0NvbnN0YW50VHlwZXMpIHtcbiAgICAgICAgdHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZSh2YWx1ZSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICAgIHRoaXMuY29uc3RhbnRUeXBlc1tuYW1lXSA9IHR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gdGhpcy5jb25zdGFudFR5cGVzW25hbWVdO1xuICAgICAgfVxuICAgICAgY29uc3QgS2VybmVsVmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLmxvb2t1cEtlcm5lbFZhbHVlVHlwZSh0eXBlLCAnc3RhdGljJywgdGhpcy5wcmVjaXNpb24sIHZhbHVlKTtcbiAgICAgIGlmIChLZXJuZWxWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RmFsbGJhY2soYXJncyk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXJuZWxWYWx1ZSA9IG5ldyBLZXJuZWxWYWx1ZSh2YWx1ZSwge1xuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlLFxuICAgICAgICB0YWN0aWM6IHRoaXMudGFjdGljLFxuICAgICAgICBvcmlnaW46ICdjb25zdGFudHMnLFxuICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgIGNoZWNrQ29udGV4dDogdGhpcy5jaGVja0NvbnRleHQsXG4gICAgICAgIGtlcm5lbDogdGhpcyxcbiAgICAgICAgc3RyaWN0SW50ZWdlcnM6IHRoaXMuc3RyaWN0SW50ZWdlcnMsXG4gICAgICAgIG9uUmVxdWVzdFRleHR1cmU6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdEluZGV4OiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRleHR1cmVJbmRleGVzKys7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdENvbnRleHRIYW5kbGU6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb25zdGFudEJpdFJhdGlvc1tuYW1lXSA9IGtlcm5lbFZhbHVlLmJpdFJhdGlvO1xuICAgICAgdGhpcy5rZXJuZWxDb25zdGFudHMucHVzaChrZXJuZWxWYWx1ZSk7XG4gICAgICBrZXJuZWxWYWx1ZS5zZXR1cCgpO1xuICAgICAgaWYgKGtlcm5lbFZhbHVlLmZvcmNlVXBsb2FkRWFjaFJ1bikge1xuICAgICAgICB0aGlzLmZvcmNlVXBsb2FkS2VybmVsQ29uc3RhbnRzLnB1c2goa2VybmVsVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIGlmICh0aGlzLmJ1aWx0KSByZXR1cm47XG4gICAgdGhpcy5pbml0RXh0ZW5zaW9ucygpO1xuICAgIHRoaXMudmFsaWRhdGVTZXR0aW5ncyhhcmd1bWVudHMpO1xuICAgIHRoaXMuc2V0dXBDb25zdGFudHMoYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5mYWxsYmFja1JlcXVlc3RlZCkgcmV0dXJuO1xuICAgIHRoaXMuc2V0dXBBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5mYWxsYmFja1JlcXVlc3RlZCkgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlTWF4VGV4U2l6ZSgpO1xuICAgIHRoaXMudHJhbnNsYXRlU291cmNlKCk7XG4gICAgY29uc3QgZmFpbHVyZVJlc3VsdCA9IHRoaXMucGlja1JlbmRlclN0cmF0ZWd5KGFyZ3VtZW50cyk7XG4gICAgaWYgKGZhaWx1cmVSZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWlsdXJlUmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCB7IHRleFNpemUsIGNvbnRleHQ6IGdsLCBjYW52YXMgfSA9IHRoaXM7XG4gICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgaWYgKHRoaXMucGlwZWxpbmUgJiYgdGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG4gICAgICBjYW52YXMud2lkdGggPSB0aGlzLm1heFRleFNpemVbMF07XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5tYXhUZXhTaXplWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG4gICAgICBjYW52YXMud2lkdGggPSB0aGlzLm1heFRleFNpemVbMF07XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5tYXhUZXhTaXplWzFdO1xuICAgIH1cbiAgICBjb25zdCB0aHJlYWREaW0gPSB0aGlzLnRocmVhZERpbSA9IEFycmF5LmZyb20odGhpcy5vdXRwdXQpO1xuICAgIHdoaWxlICh0aHJlYWREaW0ubGVuZ3RoIDwgMykge1xuICAgICAgdGhyZWFkRGltLnB1c2goMSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcGlsZWRWZXJ0ZXhTaGFkZXIgPSB0aGlzLmdldFZlcnRleFNoYWRlcihhcmd1bWVudHMpO1xuICAgIGNvbnN0IHZlcnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKHZlcnRTaGFkZXIsIGNvbXBpbGVkVmVydGV4U2hhZGVyKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHZlcnRTaGFkZXIpO1xuICAgIHRoaXMudmVydFNoYWRlciA9IHZlcnRTaGFkZXI7XG5cbiAgICBjb25zdCBjb21waWxlZEZyYWdtZW50U2hhZGVyID0gdGhpcy5nZXRGcmFnbWVudFNoYWRlcihhcmd1bWVudHMpO1xuICAgIGNvbnN0IGZyYWdTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ1NoYWRlciwgY29tcGlsZWRGcmFnbWVudFNoYWRlcik7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnU2hhZGVyKTtcbiAgICB0aGlzLmZyYWdTaGFkZXIgPSBmcmFnU2hhZGVyO1xuXG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdHTFNMIFNoYWRlciBPdXRwdXQ6Jyk7XG4gICAgICBjb25zb2xlLmxvZyhjb21waWxlZEZyYWdtZW50U2hhZGVyKTtcbiAgICB9XG5cbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY29tcGlsaW5nIHZlcnRleCBzaGFkZXI6ICcgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRTaGFkZXIpKTtcbiAgICB9XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ1NoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNvbXBpbGluZyBmcmFnbWVudCBzaGFkZXI6ICcgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdTaGFkZXIpKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5wcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ1NoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci53aWR0aCA9IHRleFNpemVbMF07XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5oZWlnaHQgPSB0ZXhTaXplWzFdO1xuICAgIHRoaXMucmF3VmFsdWVGcmFtZWJ1ZmZlcnMgPSB7fTtcblxuICAgIGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbLTEsIC0xLFxuICAgICAgMSwgLTEsIC0xLCAxLFxuICAgICAgMSwgMVxuICAgIF0pO1xuICAgIGNvbnN0IHRleENvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgMCwgMCxcbiAgICAgIDEsIDAsXG4gICAgICAwLCAxLFxuICAgICAgMSwgMVxuICAgIF0pO1xuXG4gICAgY29uc3QgdGV4Q29vcmRPZmZzZXQgPSB2ZXJ0aWNlcy5ieXRlTGVuZ3RoO1xuXG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICBidWZmZXIgPSB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMuYnl0ZUxlbmd0aCArIHRleENvb3Jkcy5ieXRlTGVuZ3RoLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgIH1cblxuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB2ZXJ0aWNlcyk7XG4gICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRleENvb3JkT2Zmc2V0LCB0ZXhDb29yZHMpO1xuXG4gICAgY29uc3QgYVBvc0xvYyA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2FQb3MnKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhUG9zTG9jKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFQb3NMb2MsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgY29uc3QgYVRleENvb3JkTG9jID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnYVRleENvb3JkJyk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYVRleENvb3JkTG9jKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFUZXhDb29yZExvYywgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCB0ZXhDb29yZE9mZnNldCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcblxuICAgIGxldCBpID0gMDtcbiAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgZm9yIChsZXQgcCBpbiB0aGlzLmNvbnN0YW50cykge1xuICAgICAgdGhpcy5rZXJuZWxDb25zdGFudHNbaSsrXS51cGRhdGVWYWx1ZSh0aGlzLmNvbnN0YW50c1twXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0dXBPdXRwdXRUZXh0dXJlKCk7XG4gICAgaWYgKFxuICAgICAgdGhpcy5zdWJLZXJuZWxzICE9PSBudWxsICYmXG4gICAgICB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgdGhpcy5fbWFwcGVkVGV4dHVyZVN3aXRjaGVkID0ge307XG4gICAgICB0aGlzLl9zZXR1cFN1Yk91dHB1dFRleHR1cmVzKCk7XG4gICAgfVxuICAgIHRoaXMuYnVpbGRTaWduYXR1cmUoYXJndW1lbnRzKTtcbiAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgfVxuXG4gIHRyYW5zbGF0ZVNvdXJjZSgpIHtcbiAgICBjb25zdCBmdW5jdGlvbkJ1aWxkZXIgPSBGdW5jdGlvbkJ1aWxkZXIuZnJvbUtlcm5lbCh0aGlzLCBXZWJHTEZ1bmN0aW9uTm9kZSwge1xuICAgICAgZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3k6IHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3lcbiAgICB9KTtcbiAgICB0aGlzLnRyYW5zbGF0ZWRTb3VyY2UgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0UHJvdG90eXBlU3RyaW5nKCdrZXJuZWwnKTtcbiAgICB0aGlzLnNldHVwUmV0dXJuVHlwZXMoZnVuY3Rpb25CdWlsZGVyKTtcbiAgfVxuXG4gIHNldHVwUmV0dXJuVHlwZXMoZnVuY3Rpb25CdWlsZGVyKSB7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNhbCAmJiAhdGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICB0aGlzLnJldHVyblR5cGUgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0S2VybmVsUmVzdWx0VHlwZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgJiYgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgICAgaWYgKCFzdWJLZXJuZWwucmV0dXJuVHlwZSkge1xuICAgICAgICAgIHN1Yktlcm5lbC5yZXR1cm5UeXBlID0gZnVuY3Rpb25CdWlsZGVyLmdldFN1Yktlcm5lbFJlc3VsdFR5cGUoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBydW4oKSB7XG4gICAgY29uc3QgeyBrZXJuZWxBcmd1bWVudHMsIHRleFNpemUsIGZvcmNlVXBsb2FkS2VybmVsQ29uc3RhbnRzLCBjb250ZXh0OiBnbCB9ID0gdGhpcztcblxuICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICBnbC5zY2lzc29yKDAsIDAsIHRleFNpemVbMF0sIHRleFNpemVbMV0pO1xuICAgIGlmICh0aGlzLmR5bmFtaWNPdXRwdXQpIHtcbiAgICAgIHRoaXMuc2V0VW5pZm9ybTNpdigndU91dHB1dERpbScsIG5ldyBJbnQzMkFycmF5KHRoaXMudGhyZWFkRGltKSk7XG4gICAgICB0aGlzLnNldFVuaWZvcm0yaXYoJ3VUZXhTaXplJywgdGV4U2l6ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRVbmlmb3JtMmYoJ3JhdGlvJywgdGV4U2l6ZVswXSAvIHRoaXMubWF4VGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSAvIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcmNlVXBsb2FkS2VybmVsQ29uc3RhbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb25zdGFudCA9IGZvcmNlVXBsb2FkS2VybmVsQ29uc3RhbnRzW2ldO1xuICAgICAgY29uc3RhbnQudXBkYXRlVmFsdWUodGhpcy5jb25zdGFudHNbY29uc3RhbnQubmFtZV0pO1xuICAgICAgaWYgKHRoaXMuc3dpdGNoaW5nS2VybmVscykgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbEFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAga2VybmVsQXJndW1lbnRzW2ldLnVwZGF0ZVZhbHVlKGFyZ3VtZW50c1tpXSk7XG4gICAgICBpZiAodGhpcy5zd2l0Y2hpbmdLZXJuZWxzKSByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGx1Z2lucykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy5wbHVnaW5zW2ldO1xuICAgICAgICBpZiAocGx1Z2luLm9uQmVmb3JlUnVuKSB7XG4gICAgICAgICAgcGx1Z2luLm9uQmVmb3JlUnVuKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICBpZiAodGhpcy5waXBlbGluZSkge1xuICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIGlmICh0aGlzLmltbXV0YWJsZSkge1xuICAgICAgICAgIHRoaXMuX3JlcGxhY2VPdXRwdXRUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gICAgICAgIHJldHVybiB0aGlzLmltbXV0YWJsZSA/IHRoaXMudGV4dHVyZS5jbG9uZSgpIDogdGhpcy50ZXh0dXJlO1xuICAgICAgfVxuICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgaWYgKHRoaXMuaW1tdXRhYmxlKSB7XG4gICAgICB0aGlzLl9yZXBsYWNlT3V0cHV0VGV4dHVyZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmltbXV0YWJsZSkge1xuICAgICAgICB0aGlzLl9yZXBsYWNlU3ViT3V0cHV0VGV4dHVyZXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd0J1ZmZlcnMoKTtcbiAgICB9XG5cbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgfVxuXG4gIGRyYXdCdWZmZXJzKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMuZHJhd0J1ZmZlcnNXRUJHTCh0aGlzLmRyYXdCdWZmZXJzTWFwKTtcbiAgfVxuXG4gIGdldEludGVybmFsRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuUkdCQTtcbiAgfVxuICBnZXRUZXh0dXJlRm9ybWF0KCkge1xuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgc3dpdGNoICh0aGlzLmdldEludGVybmFsRm9ybWF0KCkpIHtcbiAgICAgIGNhc2UgZ2wuUkdCQTpcbiAgICAgICAgcmV0dXJuIGdsLlJHQkE7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW50ZXJuYWwgZm9ybWF0Jyk7XG4gICAgfVxuICB9XG5cbiAgX3JlcGxhY2VPdXRwdXRUZXh0dXJlKCkge1xuICAgIGlmICh0aGlzLnRleHR1cmUuYmVmb3JlTXV0YXRlKCkgfHwgdGhpcy5fdGV4dHVyZVN3aXRjaGVkKSB7XG4gICAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlLnRleHR1cmUsIDApO1xuICAgICAgdGhpcy5fdGV4dHVyZVN3aXRjaGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgX3NldHVwT3V0cHV0VGV4dHVyZSgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCB0ZXhTaXplID0gdGhpcy50ZXhTaXplO1xuICAgIGlmICh0aGlzLnRleHR1cmUpIHtcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlLnRleHR1cmUsIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRUZXh0dXJlQ291bnQgKyB0aGlzLmFyZ3VtZW50VGV4dHVyZUNvdW50KTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0SW50ZXJuYWxGb3JtYXQoKTtcbiAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZm9ybWF0LCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICB9XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICB0aGlzLnRleHR1cmUgPSBuZXcgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3Ioe1xuICAgICAgdGV4dHVyZSxcbiAgICAgIHNpemU6IHRleFNpemUsXG4gICAgICBkaW1lbnNpb25zOiB0aGlzLnRocmVhZERpbSxcbiAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICBpbnRlcm5hbEZvcm1hdDogdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpLFxuICAgICAgdGV4dHVyZUZvcm1hdDogdGhpcy5nZXRUZXh0dXJlRm9ybWF0KCksXG4gICAgICBrZXJuZWw6IHRoaXMsXG4gICAgfSk7XG4gIH1cblxuICBfcmVwbGFjZVN1Yk91dHB1dFRleHR1cmVzKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXBwZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbWFwcGVkVGV4dHVyZSA9IHRoaXMubWFwcGVkVGV4dHVyZXNbaV07XG4gICAgICBpZiAobWFwcGVkVGV4dHVyZS5iZWZvcmVNdXRhdGUoKSB8fCB0aGlzLl9tYXBwZWRUZXh0dXJlU3dpdGNoZWRbaV0pIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEsIGdsLlRFWFRVUkVfMkQsIG1hcHBlZFRleHR1cmUudGV4dHVyZSwgMCk7XG4gICAgICAgIHRoaXMuX21hcHBlZFRleHR1cmVTd2l0Y2hlZFtpXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9zZXR1cFN1Yk91dHB1dFRleHR1cmVzKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgIGlmICh0aGlzLm1hcHBlZFRleHR1cmVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5tYXBwZWRUZXh0dXJlc1tpXS50ZXh0dXJlLCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZTtcbiAgICB0aGlzLmRyYXdCdWZmZXJzTWFwID0gW2dsLkNPTE9SX0FUVEFDSE1FTlQwXTtcbiAgICB0aGlzLm1hcHBlZFRleHR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIHRoaXMuZHJhd0J1ZmZlcnNNYXAucHVzaChnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKyAxKTtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50ICsgdGhpcy5hcmd1bWVudFRleHR1cmVDb3VudCArIGkpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICB9XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG5cbiAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXMucHVzaChuZXcgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3Ioe1xuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICBzaXplOiB0ZXhTaXplLFxuICAgICAgICBkaW1lbnNpb25zOiB0aGlzLnRocmVhZERpbSxcbiAgICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICBpbnRlcm5hbEZvcm1hdDogdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpLFxuICAgICAgICB0ZXh0dXJlRm9ybWF0OiB0aGlzLmdldFRleHR1cmVGb3JtYXQoKSxcbiAgICAgICAga2VybmVsOiB0aGlzLFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIHNldFVuaWZvcm0xZihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm0xZkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTFmQ2FjaGVbbmFtZV07XG4gICAgICBpZiAodmFsdWUgPT09IGNhY2hlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtMWZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtMWYobG9jLCB2YWx1ZSk7XG4gIH1cblxuICBzZXRVbmlmb3JtMWkobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtMWlDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm0xaUNhY2hlW25hbWVdO1xuICAgICAgaWYgKHZhbHVlID09PSBjYWNoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTFpQ2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTFpKGxvYywgdmFsdWUpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTJmKG5hbWUsIHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTJmQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtMmZDYWNoZVtuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWUxID09PSBjYWNoZVswXSAmJlxuICAgICAgICB2YWx1ZTIgPT09IGNhY2hlWzFdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm0yZkNhY2hlW25hbWVdID0gW3ZhbHVlMSwgdmFsdWUyXTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTJmKGxvYywgdmFsdWUxLCB2YWx1ZTIpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTJmdihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm0yZnZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm0yZnZDYWNoZVtuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWVbMF0gPT09IGNhY2hlWzBdICYmXG4gICAgICAgIHZhbHVlWzFdID09PSBjYWNoZVsxXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtMmZ2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTJmdihsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIHNldFVuaWZvcm0yaXYobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtMml2Q2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtMml2Q2FjaGVbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlWzBdID09PSBjYWNoZVswXSAmJlxuICAgICAgICB2YWx1ZVsxXSA9PT0gY2FjaGVbMV1cbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTJpdkNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm0yaXYobG9jLCB2YWx1ZSk7XG4gIH1cblxuICBzZXRVbmlmb3JtM2Z2KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTNmdkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTNmdkNhY2hlW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZVswXSA9PT0gY2FjaGVbMF0gJiZcbiAgICAgICAgdmFsdWVbMV0gPT09IGNhY2hlWzFdICYmXG4gICAgICAgIHZhbHVlWzJdID09PSBjYWNoZVsyXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtM2Z2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTNmdihsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIHNldFVuaWZvcm0zaXYobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtM2l2Q2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtM2l2Q2FjaGVbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlWzBdID09PSBjYWNoZVswXSAmJlxuICAgICAgICB2YWx1ZVsxXSA9PT0gY2FjaGVbMV0gJiZcbiAgICAgICAgdmFsdWVbMl0gPT09IGNhY2hlWzJdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm0zaXZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtM2l2KGxvYywgdmFsdWUpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTRmdihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm00ZnZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm00ZnZDYWNoZVtuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWVbMF0gPT09IGNhY2hlWzBdICYmXG4gICAgICAgIHZhbHVlWzFdID09PSBjYWNoZVsxXSAmJlxuICAgICAgICB2YWx1ZVsyXSA9PT0gY2FjaGVbMl0gJiZcbiAgICAgICAgdmFsdWVbM10gPT09IGNhY2hlWzNdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm00ZnZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtNGZ2KGxvYywgdmFsdWUpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTRpdihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm00aXZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm00aXZDYWNoZVtuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWVbMF0gPT09IGNhY2hlWzBdICYmXG4gICAgICAgIHZhbHVlWzFdID09PSBjYWNoZVsxXSAmJlxuICAgICAgICB2YWx1ZVsyXSA9PT0gY2FjaGVbMl0gJiZcbiAgICAgICAgdmFsdWVbM10gPT09IGNhY2hlWzNdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm00aXZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtNGl2KGxvYywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpIHtcbiAgICBpZiAodGhpcy5wcm9ncmFtVW5pZm9ybUxvY2F0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyYW1Vbmlmb3JtTG9jYXRpb25DYWNoZVtuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbkNhY2hlW25hbWVdID0gdGhpcy5jb250ZXh0LmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpO1xuICB9XG5cbiAgX2dldEZyYWdTaGFkZXJBcnRpZmFjdE1hcChhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhFQURFUjogdGhpcy5fZ2V0SGVhZGVyU3RyaW5nKCksXG4gICAgICBMT09QX01BWDogdGhpcy5fZ2V0TG9vcE1heFN0cmluZygpLFxuICAgICAgUExVR0lOUzogdGhpcy5fZ2V0UGx1Z2luc1N0cmluZygpLFxuICAgICAgQ09OU1RBTlRTOiB0aGlzLl9nZXRDb25zdGFudHNTdHJpbmcoKSxcbiAgICAgIERFQ09ERTMyX0VORElBTk5FU1M6IHRoaXMuX2dldERlY29kZTMyRW5kaWFubmVzc1N0cmluZygpLFxuICAgICAgRU5DT0RFMzJfRU5ESUFOTkVTUzogdGhpcy5fZ2V0RW5jb2RlMzJFbmRpYW5uZXNzU3RyaW5nKCksXG4gICAgICBESVZJREVfV0lUSF9JTlRFR0VSX0NIRUNLOiB0aGlzLl9nZXREaXZpZGVXaXRoSW50ZWdlckNoZWNrU3RyaW5nKCksXG4gICAgICBJTkpFQ1RFRF9OQVRJVkU6IHRoaXMuX2dldEluamVjdGVkTmF0aXZlKCksXG4gICAgICBNQUlOX0NPTlNUQU5UUzogdGhpcy5fZ2V0TWFpbkNvbnN0YW50c1N0cmluZygpLFxuICAgICAgTUFJTl9BUkdVTUVOVFM6IHRoaXMuX2dldE1haW5Bcmd1bWVudHNTdHJpbmcoYXJncyksXG4gICAgICBLRVJORUw6IHRoaXMuZ2V0S2VybmVsU3RyaW5nKCksXG4gICAgICBNQUlOX1JFU1VMVDogdGhpcy5nZXRNYWluUmVzdWx0U3RyaW5nKCksXG4gICAgICBGTE9BVF9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0RmxvYXRUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgICAgSU5UX1RBQ1RJQ19ERUNMQVJBVElPTjogdGhpcy5nZXRJbnRUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgICAgU0FNUExFUl8yRF9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0U2FtcGxlcjJEVGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICAgIFNBTVBMRVJfMkRfQVJSQVlfVEFDVElDX0RFQ0xBUkFUSU9OOiB0aGlzLmdldFNhbXBsZXIyREFycmF5VGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICB9O1xuICB9XG5cbiAgX2dldFZlcnRTaGFkZXJBcnRpZmFjdE1hcChhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEZMT0FUX1RBQ1RJQ19ERUNMQVJBVElPTjogdGhpcy5nZXRGbG9hdFRhY3RpY0RlY2xhcmF0aW9uKCksXG4gICAgICBJTlRfVEFDVElDX0RFQ0xBUkFUSU9OOiB0aGlzLmdldEludFRhY3RpY0RlY2xhcmF0aW9uKCksXG4gICAgICBTQU1QTEVSXzJEX1RBQ1RJQ19ERUNMQVJBVElPTjogdGhpcy5nZXRTYW1wbGVyMkRUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgICAgU0FNUExFUl8yRF9BUlJBWV9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0U2FtcGxlcjJEQXJyYXlUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgIH07XG4gIH1cblxuICBfZ2V0SGVhZGVyU3RyaW5nKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwgP1xuICAgICAgJyNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmVcXG4nIDpcbiAgICAgICcnXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRMb29wTWF4U3RyaW5nKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxvb3BNYXhJdGVyYXRpb25zID9cbiAgICAgIGAgJHtwYXJzZUludCh0aGlzLmxvb3BNYXhJdGVyYXRpb25zKX07XFxuYCA6XG4gICAgICAnIDEwMDA7XFxuJ1xuICAgICk7XG4gIH1cblxuICBfZ2V0UGx1Z2luc1N0cmluZygpIHtcbiAgICBpZiAoIXRoaXMucGx1Z2lucykgcmV0dXJuICdcXG4nO1xuICAgIHJldHVybiB0aGlzLnBsdWdpbnMubWFwKHBsdWdpbiA9PiBwbHVnaW4uc291cmNlICYmIHRoaXMuc291cmNlLm1hdGNoKHBsdWdpbi5mdW5jdGlvbk1hdGNoKSA/IHBsdWdpbi5zb3VyY2UgOiAnJykuam9pbignXFxuJyk7XG4gIH1cblxuICBfZ2V0Q29uc3RhbnRzU3RyaW5nKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHsgdGhyZWFkRGltLCB0ZXhTaXplIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLmR5bmFtaWNPdXRwdXQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAndW5pZm9ybSBpdmVjMyB1T3V0cHV0RGltJyxcbiAgICAgICAgJ3VuaWZvcm0gaXZlYzIgdVRleFNpemUnXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgYGl2ZWMzIHVPdXRwdXREaW0gPSBpdmVjMygke3RocmVhZERpbVswXX0sICR7dGhyZWFkRGltWzFdfSwgJHt0aHJlYWREaW1bMl19KWAsXG4gICAgICAgIGBpdmVjMiB1VGV4U2l6ZSA9IGl2ZWMyKCR7dGV4U2l6ZVswXX0sICR7dGV4U2l6ZVsxXX0pYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcocmVzdWx0KTtcbiAgfVxuXG4gIF9nZXRUZXh0dXJlQ29vcmRpbmF0ZSgpIHtcbiAgICBjb25zdCBzdWJLZXJuZWxzID0gdGhpcy5zdWJLZXJuZWxzO1xuICAgIGlmIChzdWJLZXJuZWxzID09PSBudWxsIHx8IHN1Yktlcm5lbHMubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnb3V0IHZlYzIgdlRleENvb3JkO1xcbic7XG4gICAgfVxuICB9XG5cbiAgX2dldERlY29kZTMyRW5kaWFubmVzc1N0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5lbmRpYW5uZXNzID09PSAnTEUnID9cbiAgICAgICcnIDpcbiAgICAgICcgIHRleGVsLnJnYmEgPSB0ZXhlbC5hYmdyO1xcbidcbiAgICApO1xuICB9XG5cbiAgX2dldEVuY29kZTMyRW5kaWFubmVzc1N0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5lbmRpYW5uZXNzID09PSAnTEUnID9cbiAgICAgICcnIDpcbiAgICAgICcgIHRleGVsLnJnYmEgPSB0ZXhlbC5hYmdyO1xcbidcbiAgICApO1xuICB9XG5cbiAgX2dldERpdmlkZVdpdGhJbnRlZ2VyQ2hlY2tTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgP1xuICAgICAgYGZsb2F0IGRpdldpdGhJbnRDaGVjayhmbG9hdCB4LCBmbG9hdCB5KSB7XG4gIGlmIChmbG9vcih4KSA9PSB4ICYmIGZsb29yKHkpID09IHkgJiYgaW50ZWdlck1vZCh4LCB5KSA9PSAwLjApIHtcbiAgICByZXR1cm4gZmxvYXQoaW50KHgpIC8gaW50KHkpKTtcbiAgfVxuICByZXR1cm4geCAvIHk7XG59XG5cbmZsb2F0IGludGVnZXJDb3JyZWN0aW9uTW9kdWxvKGZsb2F0IG51bWJlciwgZmxvYXQgZGl2aXNvcikge1xuICBpZiAobnVtYmVyIDwgMC4wKSB7XG4gICAgbnVtYmVyID0gYWJzKG51bWJlcik7XG4gICAgaWYgKGRpdmlzb3IgPCAwLjApIHtcbiAgICAgIGRpdmlzb3IgPSBhYnMoZGl2aXNvcik7XG4gICAgfVxuICAgIHJldHVybiAtKG51bWJlciAtIChkaXZpc29yICogZmxvb3IoZGl2V2l0aEludENoZWNrKG51bWJlciwgZGl2aXNvcikpKSk7XG4gIH1cbiAgaWYgKGRpdmlzb3IgPCAwLjApIHtcbiAgICBkaXZpc29yID0gYWJzKGRpdmlzb3IpO1xuICB9XG4gIHJldHVybiBudW1iZXIgLSAoZGl2aXNvciAqIGZsb29yKGRpdldpdGhJbnRDaGVjayhudW1iZXIsIGRpdmlzb3IpKSk7XG59YCA6XG4gICAgICAnJztcbiAgfVxuXG4gIF9nZXRNYWluQXJndW1lbnRzU3RyaW5nKGFyZ3MpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgY29uc3QgeyBhcmd1bWVudE5hbWVzIH0gPSB0aGlzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0cy5wdXNoKHRoaXMua2VybmVsQXJndW1lbnRzW2ldLmdldFNvdXJjZShhcmdzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzLmpvaW4oJycpO1xuICB9XG5cbiAgX2dldEluamVjdGVkTmF0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmluamVjdGVkTmF0aXZlIHx8ICcnO1xuICB9XG5cbiAgX2dldE1haW5Db25zdGFudHNTdHJpbmcoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgeyBjb25zdGFudHMgfSA9IHRoaXM7XG4gICAgaWYgKGNvbnN0YW50cykge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIXRoaXMuY29uc3RhbnRzLmhhc093blByb3BlcnR5KG5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5rZXJuZWxDb25zdGFudHNbaSsrXS5nZXRTb3VyY2UodGhpcy5jb25zdGFudHNbbmFtZV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgfVxuXG4gIGdldFJhd1ZhbHVlRnJhbWVidWZmZXIod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghdGhpcy5yYXdWYWx1ZUZyYW1lYnVmZmVyc1t3aWR0aF0pIHtcbiAgICAgIHRoaXMucmF3VmFsdWVGcmFtZWJ1ZmZlcnNbd2lkdGhdID0ge307XG4gICAgfVxuICAgIGlmICghdGhpcy5yYXdWYWx1ZUZyYW1lYnVmZmVyc1t3aWR0aF1baGVpZ2h0XSkge1xuICAgICAgY29uc3QgZnJhbWVidWZmZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIGZyYW1lYnVmZmVyLndpZHRoID0gd2lkdGg7XG4gICAgICBmcmFtZWJ1ZmZlci5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLnJhd1ZhbHVlRnJhbWVidWZmZXJzW3dpZHRoXVtoZWlnaHRdID0gZnJhbWVidWZmZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJhd1ZhbHVlRnJhbWVidWZmZXJzW3dpZHRoXVtoZWlnaHRdO1xuICB9XG5cbiAgZ2V0S2VybmVsUmVzdWx0RGVjbGFyYXRpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgcmV0dXJuICd2ZWMyIGtlcm5lbFJlc3VsdCc7XG4gICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICAgIHJldHVybiAndmVjMyBrZXJuZWxSZXN1bHQnO1xuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICByZXR1cm4gJ3ZlYzQga2VybmVsUmVzdWx0JztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgcmV0dXJuICdmbG9hdCBrZXJuZWxSZXN1bHQnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICAgICAgcmV0dXJuICdmbG9hdCBrZXJuZWxSZXN1bHQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIG91dHB1dCB0eXBlIFwiJHsgdGhpcy5yZXR1cm5UeXBlIH1cImApO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGdldEtlcm5lbFN0cmluZygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbdGhpcy5nZXRLZXJuZWxSZXN1bHREZWNsYXJhdGlvbigpXTtcbiAgICBjb25zdCB7IHN1Yktlcm5lbHMgfSA9IHRoaXM7XG4gICAgaWYgKHN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJLZXJuZWwgPSBzdWJLZXJuZWxzW2ldO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIHN1Yktlcm5lbC5yZXR1cm5UeXBlID09PSAnSW50ZWdlcicgP1xuICAgICAgICAgICAgICBgaW50IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gMGAgOlxuICAgICAgICAgICAgICBgZmxvYXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH0gPSAwLjBgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGB2ZWMyIHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWxzW2ldLm5hbWUgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYHZlYzMgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbHNbaV0ubmFtZSB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBgdmVjNCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsc1tpXS5uYW1lIH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpICsgdGhpcy50cmFuc2xhdGVkU291cmNlO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEdyYXBoaWNhbCgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZ2xfRnJhZ0NvbG9yID0gYWN0dWFsQ29sb3InLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFBhY2tlZFBpeGVscygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0S2VybmVsUGFja2VkUGl4ZWxzKCkgK1xuICAgICAgICAgIHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbFBhY2tlZFBpeGVscygpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWNrZWQgb3V0cHV0IG9ubHkgdXNhYmxlIHdpdGggTnVtYmVycywgXCIke3RoaXMucmV0dXJuVHlwZX1cIiBzcGVjaWZpZWRgKTtcbiAgICB9XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsUGFja2VkUGl4ZWxzKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICBgICBnbF9GcmFnRGF0YVswXSA9ICR7dGhpcy51c2VMZWdhY3lFbmNvZGVyID8gJ2xlZ2FjeUVuY29kZTMyJyA6ICdlbmNvZGUzMid9KGtlcm5lbFJlc3VsdClgXG4gICAgXSk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsUGFja2VkUGl4ZWxzKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XSA9ICR7dGhpcy51c2VMZWdhY3lFbmNvZGVyID8gJ2xlZ2FjeUVuY29kZTMyJyA6ICdlbmNvZGUzMid9KGZsb2F0KHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfSkpYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dID0gJHt0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPyAnbGVnYWN5RW5jb2RlMzInIDogJ2VuY29kZTMyJ30oc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcocmVzdWx0KTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRNZW1vcnlPcHRpbWl6ZWRGbG9hdHMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW1xuICAgICAgJyAgaW5kZXggKj0gNCcsXG4gICAgXTtcblxuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIGNvbnN0IGNoYW5uZWxzID0gWydyJywgJ2cnLCAnYicsICdhJ107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0gY2hhbm5lbHNbaV07XG4gICAgICAgICAgdGhpcy5nZXRNYWluUmVzdWx0S2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCk7XG4gICAgICAgICAgdGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCk7XG4gICAgICAgICAgaWYgKGkgKyAxIDwgY2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnICBpbmRleCArPSAxJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcHRpbWl6ZWQgb3V0cHV0IG9ubHkgdXNhYmxlIHdpdGggTnVtYmVycywgJHt0aGlzLnJldHVyblR5cGV9IHNwZWNpZmllZGApO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCkge1xuICAgIHJlc3VsdC5wdXNoKFxuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgIGAgIGdsX0ZyYWdEYXRhWzBdLiR7Y2hhbm5lbH0gPSBrZXJuZWxSZXN1bHRgXG4gICAgKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxNZW1vcnlPcHRpbWl6ZWRGbG9hdHMocmVzdWx0LCBjaGFubmVsKSB7XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XS4ke2NoYW5uZWx9ID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XS4ke2NoYW5uZWx9ID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxOdW1iZXJUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF1bMF0gPSBrZXJuZWxSZXN1bHQnLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgaWYgKHN1Yktlcm5lbC5yZXR1cm5UeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzBdID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9KWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTJUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF1bMF0gPSBrZXJuZWxSZXN1bHRbMF0nLFxuICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF1bMV0gPSBrZXJuZWxSZXN1bHRbMV0nLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkyVGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVswXWAsXG4gICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVsxXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsxXWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkzVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzBdID0ga2VybmVsUmVzdWx0WzBdJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzFdID0ga2VybmVsUmVzdWx0WzFdJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzJdID0ga2VybmVsUmVzdWx0WzJdJyxcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5M1RleHR1cmUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMF1gLFxuICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gLFxuICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMl0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMl1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5NFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBnbF9GcmFnRGF0YVswXSA9IGtlcm5lbFJlc3VsdCcsXG4gICAgXTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVswXWAsXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVswXWAsXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gLFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzJdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzJdYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMF1gLFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzFdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzFdYCxcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVsyXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsyXWAsXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bM10gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bM11gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVwbGFjZUFydGlmYWN0cyhzcmMsIG1hcCkge1xuICAgIHJldHVybiBzcmMucmVwbGFjZSgvWyBdKl9fKFtBLVpdK1swLTldKihbX10/W0EtWl0qWzAtOV0/KSopX187XFxuL2csIChtYXRjaCwgYXJ0aWZhY3QpID0+IHtcbiAgICAgIGlmIChtYXAuaGFzT3duUHJvcGVydHkoYXJ0aWZhY3QpKSB7XG4gICAgICAgIHJldHVybiBtYXBbYXJ0aWZhY3RdO1xuICAgICAgfVxuICAgICAgdGhyb3cgYHVuaGFuZGxlZCBhcnRpZmFjdCAke2FydGlmYWN0fWA7XG4gICAgfSk7XG4gIH1cblxuICBnZXRGcmFnbWVudFNoYWRlcihhcmdzKSB7XG4gICAgaWYgKHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlciA9IHRoaXMucmVwbGFjZUFydGlmYWN0cyh0aGlzLmNvbnN0cnVjdG9yLmZyYWdtZW50U2hhZGVyLCB0aGlzLl9nZXRGcmFnU2hhZGVyQXJ0aWZhY3RNYXAoYXJncykpO1xuICB9XG5cbiAgZ2V0VmVydGV4U2hhZGVyKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5jb21waWxlZFZlcnRleFNoYWRlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRWZXJ0ZXhTaGFkZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBpbGVkVmVydGV4U2hhZGVyID0gdGhpcy5yZXBsYWNlQXJ0aWZhY3RzKHRoaXMuY29uc3RydWN0b3IudmVydGV4U2hhZGVyLCB0aGlzLl9nZXRWZXJ0U2hhZGVyQXJ0aWZhY3RNYXAoYXJncykpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qgc2V0dXBDb250ZXh0U3RyaW5nID0gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgZ2wgPSBjb250ZXh0YCxcbiAgICBdKTtcbiAgICByZXR1cm4gZ2xLZXJuZWxTdHJpbmcodGhpcy5jb25zdHJ1Y3RvciwgYXJndW1lbnRzLCB0aGlzLCBzZXR1cENvbnRleHRTdHJpbmcpO1xuICB9XG5cbiAgZGVzdHJveShyZW1vdmVDYW52YXNSZWZlcmVuY2VzKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRleHQpIHJldHVybjtcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFtZWJ1ZmZlcikge1xuICAgICAgdGhpcy5jb250ZXh0LmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHdpZHRoIGluIHRoaXMucmF3VmFsdWVGcmFtZWJ1ZmZlcnMpIHtcbiAgICAgIGZvciAoY29uc3QgaGVpZ2h0IGluIHRoaXMucmF3VmFsdWVGcmFtZWJ1ZmZlcnNbd2lkdGhdKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLnJhd1ZhbHVlRnJhbWVidWZmZXJzW3dpZHRoXVtoZWlnaHRdKTtcbiAgICAgICAgZGVsZXRlIHRoaXMucmF3VmFsdWVGcmFtZWJ1ZmZlcnNbd2lkdGhdW2hlaWdodF07XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5yYXdWYWx1ZUZyYW1lYnVmZmVyc1t3aWR0aF07XG4gICAgfVxuICAgIGlmICh0aGlzLnZlcnRTaGFkZXIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0U2hhZGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJhZ1NoYWRlcikge1xuICAgICAgdGhpcy5jb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdTaGFkZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9ncmFtKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICB0aGlzLnRleHR1cmUuZGVsZXRlKCk7XG4gICAgICBjb25zdCB0ZXh0dXJlQ2FjaGVJbmRleCA9IHRoaXMudGV4dHVyZUNhY2hlLmluZGV4T2YodGhpcy50ZXh0dXJlLnRleHR1cmUpO1xuICAgICAgaWYgKHRleHR1cmVDYWNoZUluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGUuc3BsaWNlKHRleHR1cmVDYWNoZUluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcHBlZFRleHR1cmVzICYmIHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWFwcGVkVGV4dHVyZSA9IHRoaXMubWFwcGVkVGV4dHVyZXNbaV07XG4gICAgICAgIG1hcHBlZFRleHR1cmUuZGVsZXRlKCk7XG4gICAgICAgIGNvbnN0IHRleHR1cmVDYWNoZUluZGV4ID0gdGhpcy50ZXh0dXJlQ2FjaGUuaW5kZXhPZihtYXBwZWRUZXh0dXJlLnRleHR1cmUpO1xuICAgICAgICBpZiAodGV4dHVyZUNhY2hlSW5kZXggPiAtMSkge1xuICAgICAgICAgIHRoaXMudGV4dHVyZUNhY2hlLnNwbGljZSh0ZXh0dXJlQ2FjaGVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXMgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5rZXJuZWxBcmd1bWVudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5rZXJuZWxBcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5rZXJuZWxBcmd1bWVudHNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5rZXJuZWxDb25zdGFudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5rZXJuZWxDb25zdGFudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5rZXJuZWxDb25zdGFudHNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAodGhpcy50ZXh0dXJlQ2FjaGUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMudGV4dHVyZUNhY2hlLnBvcCgpO1xuICAgICAgdGhpcy5jb250ZXh0LmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgfVxuICAgIGlmIChyZW1vdmVDYW52YXNSZWZlcmVuY2VzKSB7XG4gICAgICBjb25zdCBpZHggPSBjYW52YXNlcy5pbmRleE9mKHRoaXMuY2FudmFzKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICBjYW52YXNlc1tpZHhdID0gbnVsbDtcbiAgICAgICAgbWF4VGV4U2l6ZXNbaWR4XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveUV4dGVuc2lvbnMoKTtcbiAgICBkZWxldGUgdGhpcy5jb250ZXh0O1xuICAgIGRlbGV0ZSB0aGlzLmNhbnZhcztcbiAgICBpZiAoIXRoaXMuZ3B1KSByZXR1cm47XG4gICAgY29uc3QgaSA9IHRoaXMuZ3B1Lmtlcm5lbHMuaW5kZXhPZih0aGlzKTtcbiAgICBpZiAoaSA9PT0gLTEpIHJldHVybjtcbiAgICB0aGlzLmdwdS5rZXJuZWxzLnNwbGljZShpLCAxKTtcbiAgfVxuXG4gIGRlc3Ryb3lFeHRlbnNpb25zKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdCA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLk9FU19lbGVtZW50X2luZGV4X3VpbnQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGRlc3Ryb3lDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBjb250ZXh0LmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG4gICAgaWYgKGV4dGVuc2lvbikge1xuICAgICAgZXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGpzb24gPSBzdXBlci50b0pTT04oKTtcbiAgICBqc29uLmZ1bmN0aW9uTm9kZXMgPSBGdW5jdGlvbkJ1aWxkZXIuZnJvbUtlcm5lbCh0aGlzLCBXZWJHTEZ1bmN0aW9uTm9kZSkudG9KU09OKCk7XG4gICAganNvbi5zZXR0aW5ncy50aHJlYWREaW0gPSB0aGlzLnRocmVhZERpbTtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxcbn07XG59LHtcIi4uLy4uL3BsdWdpbnMvbWF0aC1yYW5kb20tdW5pZm9ybWx5LWRpc3RyaWJ1dGVkXCI6MTEyLFwiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi9mdW5jdGlvbi1idWlsZGVyXCI6OSxcIi4uL2dsL2tlcm5lbFwiOjEzLFwiLi4vZ2wva2VybmVsLXN0cmluZ1wiOjEyLFwiLi9mcmFnbWVudC1zaGFkZXJcIjozNyxcIi4vZnVuY3Rpb24tbm9kZVwiOjM4LFwiLi9rZXJuZWwtdmFsdWUtbWFwc1wiOjM5LFwiLi92ZXJ0ZXgtc2hhZGVyXCI6NzF9XSw3MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB2ZXJ0ZXhTaGFkZXIgPSBgX19GTE9BVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fSU5UX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuX19TQU1QTEVSXzJEX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuXG5hdHRyaWJ1dGUgdmVjMiBhUG9zO1xuYXR0cmlidXRlIHZlYzIgYVRleENvb3JkO1xuXG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xudW5pZm9ybSB2ZWMyIHJhdGlvO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9Qb3NpdGlvbiA9IHZlYzQoKGFQb3MgKyB2ZWMyKDEpKSAqIHJhdGlvICsgdmVjMigtMSksIDAsIDEpO1xuICB2VGV4Q29vcmQgPSBhVGV4Q29vcmQ7XG59YDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZlcnRleFNoYWRlclxufTtcbn0se31dLDcyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IGZyYWdtZW50U2hhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xuX19IRUFERVJfXztcbl9fRkxPQVRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX0lOVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fU0FNUExFUl8yRF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fU0FNUExFUl8yRF9BUlJBWV9UQUNUSUNfREVDTEFSQVRJT05fXztcblxuY29uc3QgaW50IExPT1BfTUFYID0gX19MT09QX01BWF9fO1xuXG5fX1BMVUdJTlNfXztcbl9fQ09OU1RBTlRTX187XG5cbmluIHZlYzIgdlRleENvb3JkO1xuXG5mbG9hdCBhdGFuMihmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgaWYgKHYxID09IDAuMCB8fCB2MiA9PSAwLjApIHJldHVybiAwLjA7XG4gIHJldHVybiBhdGFuKHYxIC8gdjIpO1xufVxuXG5mbG9hdCBjYnJ0KGZsb2F0IHgpIHtcbiAgaWYgKHggPj0gMC4wKSB7XG4gICAgcmV0dXJuIHBvdyh4LCAxLjAgLyAzLjApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAtcG93KHgsIDEuMCAvIDMuMCk7XG4gIH1cbn1cblxuZmxvYXQgZXhwbTEoZmxvYXQgeCkge1xuICByZXR1cm4gcG93KCR7TWF0aC5FfSwgeCkgLSAxLjA7IFxufVxuXG5mbG9hdCBmcm91bmQoaGlnaHAgZmxvYXQgeCkge1xuICByZXR1cm4geDtcbn1cblxuZmxvYXQgaW11bChmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgcmV0dXJuIGZsb2F0KGludCh2MSkgKiBpbnQodjIpKTtcbn1cblxuZmxvYXQgbG9nMTAoZmxvYXQgeCkge1xuICByZXR1cm4gbG9nMih4KSAqICgxLjAgLyBsb2cyKDEwLjApKTtcbn1cblxuZmxvYXQgbG9nMXAoZmxvYXQgeCkge1xuICByZXR1cm4gbG9nKDEuMCArIHgpO1xufVxuXG5mbG9hdCBfcG93KGZsb2F0IHYxLCBmbG9hdCB2Mikge1xuICBpZiAodjIgPT0gMC4wKSByZXR1cm4gMS4wO1xuICByZXR1cm4gcG93KHYxLCB2Mik7XG59XG5cbmZsb2F0IF9yb3VuZChmbG9hdCB4KSB7XG4gIHJldHVybiBmbG9vcih4ICsgMC41KTtcbn1cblxuXG5jb25zdCBpbnQgQklUX0NPVU5UID0gMzI7XG5pbnQgbW9kaShpbnQgeCwgaW50IHkpIHtcbiAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcbn1cblxuaW50IGJpdHdpc2VPcihpbnQgYSwgaW50IGIpIHtcbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBuID0gMTtcbiAgXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoKG1vZGkoYSwgMikgPT0gMSkgfHwgKG1vZGkoYiwgMikgPT0gMSkpIHtcbiAgICAgIHJlc3VsdCArPSBuO1xuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgYiA9IGIgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgICBpZighKGEgPiAwIHx8IGIgPiAwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZVhPUihpbnQgYSwgaW50IGIpIHtcbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBuID0gMTtcbiAgXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoKG1vZGkoYSwgMikgPT0gMSkgIT0gKG1vZGkoYiwgMikgPT0gMSkpIHtcbiAgICAgIHJlc3VsdCArPSBuO1xuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgYiA9IGIgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgICBpZighKGEgPiAwIHx8IGIgPiAwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZUFuZChpbnQgYSwgaW50IGIpIHtcbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBuID0gMTtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmICgobW9kaShhLCAyKSA9PSAxKSAmJiAobW9kaShiLCAyKSA9PSAxKSkge1xuICAgICAgcmVzdWx0ICs9IG47XG4gICAgfVxuICAgIGEgPSBhIC8gMjtcbiAgICBiID0gYiAvIDI7XG4gICAgbiA9IG4gKiAyO1xuICAgIGlmKCEoYSA+IDAgJiYgYiA+IDApKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmludCBiaXR3aXNlTm90KGludCBhKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKG1vZGkoYSwgMikgPT0gMCkge1xuICAgICAgcmVzdWx0ICs9IG47ICAgIFxuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgbiA9IG4gKiAyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZVplcm9GaWxsTGVmdFNoaWZ0KGludCBuLCBpbnQgc2hpZnQpIHtcbiAgaW50IG1heEJ5dGVzID0gQklUX0NPVU5UO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKG1heEJ5dGVzID49IG4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXhCeXRlcyAqPSAyO1xuICB9XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoaSA+PSBzaGlmdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG4gKj0gMjtcbiAgfVxuXG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgYnl0ZVZhbCA9IDE7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoaSA+PSBtYXhCeXRlcykgYnJlYWs7XG4gICAgaWYgKG1vZGkobiwgMikgPiAwKSB7IHJlc3VsdCArPSBieXRlVmFsOyB9XG4gICAgbiA9IGludChuIC8gMik7XG4gICAgYnl0ZVZhbCAqPSAyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmludCBiaXR3aXNlU2lnbmVkUmlnaHRTaGlmdChpbnQgbnVtLCBpbnQgc2hpZnRzKSB7XG4gIHJldHVybiBpbnQoZmxvb3IoZmxvYXQobnVtKSAvIHBvdygyLjAsIGZsb2F0KHNoaWZ0cykpKSk7XG59XG5cbmludCBiaXR3aXNlWmVyb0ZpbGxSaWdodFNoaWZ0KGludCBuLCBpbnQgc2hpZnQpIHtcbiAgaW50IG1heEJ5dGVzID0gQklUX0NPVU5UO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKG1heEJ5dGVzID49IG4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXhCeXRlcyAqPSAyO1xuICB9XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoaSA+PSBzaGlmdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG4gLz0gMjtcbiAgfVxuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IGJ5dGVWYWwgPSAxO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gbWF4Qnl0ZXMpIGJyZWFrO1xuICAgIGlmIChtb2RpKG4sIDIpID4gMCkgeyByZXN1bHQgKz0gYnl0ZVZhbDsgfVxuICAgIG4gPSBpbnQobiAvIDIpO1xuICAgIGJ5dGVWYWwgKj0gMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52ZWMyIGludGVnZXJNb2QodmVjMiB4LCBmbG9hdCB5KSB7XG4gIHZlYzIgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG52ZWMzIGludGVnZXJNb2QodmVjMyB4LCBmbG9hdCB5KSB7XG4gIHZlYzMgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG52ZWM0IGludGVnZXJNb2QodmVjNCB4LCB2ZWM0IHkpIHtcbiAgdmVjNCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogc3RlcCgxLjAgLSBmbG9vcih5KSwgLXJlcyk7XG59XG5cbmZsb2F0IGludGVnZXJNb2QoZmxvYXQgeCwgZmxvYXQgeSkge1xuICBmbG9hdCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogKHJlcyA+IGZsb29yKHkpIC0gMS4wID8gMC4wIDogMS4wKTtcbn1cblxuaW50IGludGVnZXJNb2QoaW50IHgsIGludCB5KSB7XG4gIHJldHVybiB4IC0gKHkgKiBpbnQoeC95KSk7XG59XG5cbl9fRElWSURFX1dJVEhfSU5URUdFUl9DSEVDS19fO1xuXG4vLyBIZXJlIGJlIGRyYWdvbnMhXG4vLyBETyBOT1QgT1BUSU1JWkUgVEhJUyBDT0RFXG4vLyBZT1UgV0lMTCBCUkVBSyBTT01FVEhJTkcgT04gU09NRUJPRFlcXCdTIE1BQ0hJTkVcbi8vIExFQVZFIElUIEFTIElUIElTLCBMRVNUIFlPVSBXQVNURSBZT1VSIE9XTiBUSU1FXG5jb25zdCB2ZWMyIE1BR0lDX1ZFQyA9IHZlYzIoMS4wLCAtMjU2LjApO1xuY29uc3QgdmVjNCBTQ0FMRV9GQUNUT1IgPSB2ZWM0KDEuMCwgMjU2LjAsIDY1NTM2LjAsIDAuMCk7XG5jb25zdCB2ZWM0IFNDQUxFX0ZBQ1RPUl9JTlYgPSB2ZWM0KDEuMCwgMC4wMDM5MDYyNSwgMC4wMDAwMTUyNTg3ODkwNjI1LCAwLjApOyAvLyAxLCAxLzI1NiwgMS82NTUzNlxuZmxvYXQgZGVjb2RlMzIodmVjNCB0ZXhlbCkge1xuICBfX0RFQ09ERTMyX0VORElBTk5FU1NfXztcbiAgdGV4ZWwgKj0gMjU1LjA7XG4gIHZlYzIgZ3RlMTI4O1xuICBndGUxMjgueCA9IHRleGVsLmIgPj0gMTI4LjAgPyAxLjAgOiAwLjA7XG4gIGd0ZTEyOC55ID0gdGV4ZWwuYSA+PSAxMjguMCA/IDEuMCA6IDAuMDtcbiAgZmxvYXQgZXhwb25lbnQgPSAyLjAgKiB0ZXhlbC5hIC0gMTI3LjAgKyBkb3QoZ3RlMTI4LCBNQUdJQ19WRUMpO1xuICBmbG9hdCByZXMgPSBleHAyKHJvdW5kKGV4cG9uZW50KSk7XG4gIHRleGVsLmIgPSB0ZXhlbC5iIC0gMTI4LjAgKiBndGUxMjgueDtcbiAgcmVzID0gZG90KHRleGVsLCBTQ0FMRV9GQUNUT1IpICogZXhwMihyb3VuZChleHBvbmVudC0yMy4wKSkgKyByZXM7XG4gIHJlcyAqPSBndGUxMjgueSAqIC0yLjAgKyAxLjA7XG4gIHJldHVybiByZXM7XG59XG5cbmZsb2F0IGRlY29kZTE2KHZlYzQgdGV4ZWwsIGludCBpbmRleCkge1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICByZXR1cm4gdGV4ZWxbY2hhbm5lbCoyXSAqIDI1NS4wICsgdGV4ZWxbY2hhbm5lbCoyICsgMV0gKiA2NTI4MC4wO1xufVxuXG5mbG9hdCBkZWNvZGU4KHZlYzQgdGV4ZWwsIGludCBpbmRleCkge1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDQpO1xuICByZXR1cm4gdGV4ZWxbY2hhbm5lbF0gKiAyNTUuMDtcbn1cblxudmVjNCBsZWdhY3lFbmNvZGUzMihmbG9hdCBmKSB7XG4gIGZsb2F0IEYgPSBhYnMoZik7XG4gIGZsb2F0IHNpZ24gPSBmIDwgMC4wID8gMS4wIDogMC4wO1xuICBmbG9hdCBleHBvbmVudCA9IGZsb29yKGxvZzIoRikpO1xuICBmbG9hdCBtYW50aXNzYSA9IChleHAyKC1leHBvbmVudCkgKiBGKTtcbiAgLy8gZXhwb25lbnQgKz0gZmxvb3IobG9nMihtYW50aXNzYSkpO1xuICB2ZWM0IHRleGVsID0gdmVjNChGICogZXhwMigyMy4wLWV4cG9uZW50KSkgKiBTQ0FMRV9GQUNUT1JfSU5WO1xuICB0ZXhlbC5yZyA9IGludGVnZXJNb2QodGV4ZWwucmcsIDI1Ni4wKTtcbiAgdGV4ZWwuYiA9IGludGVnZXJNb2QodGV4ZWwuYiwgMTI4LjApO1xuICB0ZXhlbC5hID0gZXhwb25lbnQqMC41ICsgNjMuNTtcbiAgdGV4ZWwuYmEgKz0gdmVjMihpbnRlZ2VyTW9kKGV4cG9uZW50KzEyNy4wLCAyLjApLCBzaWduKSAqIDEyOC4wO1xuICB0ZXhlbCA9IGZsb29yKHRleGVsKTtcbiAgdGV4ZWwgKj0gMC4wMDM5MjE1Njk7IC8vIDEvMjU1XG4gIF9fRU5DT0RFMzJfRU5ESUFOTkVTU19fO1xuICByZXR1cm4gdGV4ZWw7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ncHVqcy9ncHUuanMvd2lraS9FbmNvZGVyLWRldGFpbHNcbnZlYzQgZW5jb2RlMzIoZmxvYXQgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IDAuMCkgcmV0dXJuIHZlYzQoMCwgMCwgMCwgMCk7XG5cbiAgZmxvYXQgZXhwb25lbnQ7XG4gIGZsb2F0IG1hbnRpc3NhO1xuICB2ZWM0ICByZXN1bHQ7XG4gIGZsb2F0IHNnbjtcblxuICBzZ24gPSBzdGVwKDAuMCwgLXZhbHVlKTtcbiAgdmFsdWUgPSBhYnModmFsdWUpO1xuXG4gIGV4cG9uZW50ID0gZmxvb3IobG9nMih2YWx1ZSkpO1xuXG4gIG1hbnRpc3NhID0gdmFsdWUqcG93KDIuMCwgLWV4cG9uZW50KS0xLjA7XG4gIGV4cG9uZW50ID0gZXhwb25lbnQrMTI3LjA7XG4gIHJlc3VsdCAgID0gdmVjNCgwLDAsMCwwKTtcblxuICByZXN1bHQuYSA9IGZsb29yKGV4cG9uZW50LzIuMCk7XG4gIGV4cG9uZW50ID0gZXhwb25lbnQgLSByZXN1bHQuYSoyLjA7XG4gIHJlc3VsdC5hID0gcmVzdWx0LmEgKyAxMjguMCpzZ247XG5cbiAgcmVzdWx0LmIgPSBmbG9vcihtYW50aXNzYSAqIDEyOC4wKTtcbiAgbWFudGlzc2EgPSBtYW50aXNzYSAtIHJlc3VsdC5iIC8gMTI4LjA7XG4gIHJlc3VsdC5iID0gcmVzdWx0LmIgKyBleHBvbmVudCoxMjguMDtcblxuICByZXN1bHQuZyA9IGZsb29yKG1hbnRpc3NhKjMyNzY4LjApO1xuICBtYW50aXNzYSA9IG1hbnRpc3NhIC0gcmVzdWx0LmcvMzI3NjguMDtcblxuICByZXN1bHQuciA9IGZsb29yKG1hbnRpc3NhKjgzODg2MDguMCk7XG4gIHJldHVybiByZXN1bHQvMjU1LjA7XG59XG4vLyBEcmFnb25zIGVuZCBoZXJlXG5cbmludCBpbmRleDtcbml2ZWMzIHRocmVhZElkO1xuXG5pdmVjMyBpbmRleFRvM0QoaW50IGlkeCwgaXZlYzMgdGV4RGltKSB7XG4gIGludCB6ID0gaW50KGlkeCAvICh0ZXhEaW0ueCAqIHRleERpbS55KSk7XG4gIGlkeCAtPSB6ICogaW50KHRleERpbS54ICogdGV4RGltLnkpO1xuICBpbnQgeSA9IGludChpZHggLyB0ZXhEaW0ueCk7XG4gIGludCB4ID0gaW50KGludGVnZXJNb2QoaWR4LCB0ZXhEaW0ueCkpO1xuICByZXR1cm4gaXZlYzMoeCwgeSwgeik7XG59XG5cbmZsb2F0IGdldDMyKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIHJldHVybiBkZWNvZGUzMih0ZXhlbCk7XG59XG5cbmZsb2F0IGdldDE2KHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgKHRleERpbS54ICogKHkgKyAodGV4RGltLnkgKiB6KSkpO1xuICBpbnQgdyA9IHRleFNpemUueCAqIDI7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUueCAqIDIsIHRleFNpemUueSkpO1xuICByZXR1cm4gZGVjb2RlMTYodGV4ZWwsIGluZGV4KTtcbn1cblxuZmxvYXQgZ2V0OChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArICh0ZXhEaW0ueCAqICh5ICsgKHRleERpbS55ICogeikpKTtcbiAgaW50IHcgPSB0ZXhTaXplLnggKiA0O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplLnggKiA0LCB0ZXhTaXplLnkpKTtcbiAgcmV0dXJuIGRlY29kZTgodGV4ZWwsIGluZGV4KTtcbn1cblxuZmxvYXQgZ2V0TWVtb3J5T3B0aW1pemVkMzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyAodGV4RGltLnggKiAoeSArICh0ZXhEaW0ueSAqIHopKSk7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgNCk7XG4gIGluZGV4ID0gaW5kZXggLyA0O1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgaW5kZXggPSBpbmRleCAvIDQ7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgcmV0dXJuIHRleGVsW2NoYW5uZWxdO1xufVxuXG52ZWM0IGdldEltYWdlMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHJldHVybiB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbn1cblxudmVjNCBnZXRJbWFnZTNEKHNhbXBsZXIyREFycmF5IHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHJldHVybiB0ZXh0dXJlKHRleCwgdmVjMyhzdCAvIHZlYzIodGV4U2l6ZSksIHopKTtcbn1cblxuZmxvYXQgZ2V0RmxvYXRGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gcmVzdWx0WzBdO1xufVxuXG52ZWMyIGdldFZlYzJGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gdmVjMihyZXN1bHRbMF0sIHJlc3VsdFsxXSk7XG59XG5cbnZlYzIgZ2V0TWVtb3J5T3B0aW1pemVkVmVjMihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICBpbmRleCA9IGluZGV4IC8gMjtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgaWYgKGNoYW5uZWwgPT0gMCkgcmV0dXJuIHZlYzIodGV4ZWwuciwgdGV4ZWwuZyk7XG4gIGlmIChjaGFubmVsID09IDEpIHJldHVybiB2ZWMyKHRleGVsLmIsIHRleGVsLmEpO1xuICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG59XG5cbnZlYzMgZ2V0VmVjM0Zyb21TYW1wbGVyMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIHZlYzQgcmVzdWx0ID0gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgeiwgeSwgeCk7XG4gIHJldHVybiB2ZWMzKHJlc3VsdFswXSwgcmVzdWx0WzFdLCByZXN1bHRbMl0pO1xufVxuXG52ZWMzIGdldE1lbW9yeU9wdGltaXplZFZlYzMoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBmaWVsZEluZGV4ID0gMyAqICh4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeikpO1xuICBpbnQgdmVjdG9ySW5kZXggPSBmaWVsZEluZGV4IC8gNDtcbiAgaW50IHZlY3Rvck9mZnNldCA9IGZpZWxkSW5kZXggLSB2ZWN0b3JJbmRleCAqIDQ7XG4gIGludCByZWFkWSA9IHZlY3RvckluZGV4IC8gdGV4U2l6ZS54O1xuICBpbnQgcmVhZFggPSB2ZWN0b3JJbmRleCAtIHJlYWRZICogdGV4U2l6ZS54O1xuICB2ZWM0IHRleDEgPSB0ZXh0dXJlKHRleCwgKHZlYzIocmVhZFgsIHJlYWRZKSArIDAuNSkgLyB2ZWMyKHRleFNpemUpKTtcblxuICBpZiAodmVjdG9yT2Zmc2V0ID09IDApIHtcbiAgICByZXR1cm4gdGV4MS54eXo7XG4gIH0gZWxzZSBpZiAodmVjdG9yT2Zmc2V0ID09IDEpIHtcbiAgICByZXR1cm4gdGV4MS55enc7XG4gIH0gZWxzZSB7XG4gICAgcmVhZFgrKztcbiAgICBpZiAocmVhZFggPj0gdGV4U2l6ZS54KSB7XG4gICAgICByZWFkWCA9IDA7XG4gICAgICByZWFkWSsrO1xuICAgIH1cbiAgICB2ZWM0IHRleDIgPSB0ZXh0dXJlKHRleCwgdmVjMihyZWFkWCwgcmVhZFkpIC8gdmVjMih0ZXhTaXplKSk7XG4gICAgaWYgKHZlY3Rvck9mZnNldCA9PSAyKSB7XG4gICAgICByZXR1cm4gdmVjMyh0ZXgxLnosIHRleDEudywgdGV4Mi54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZlYzModGV4MS53LCB0ZXgyLngsIHRleDIueSk7XG4gICAgfVxuICB9XG59XG5cbnZlYzQgZ2V0VmVjNEZyb21TYW1wbGVyMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIHJldHVybiBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbn1cblxudmVjNCBnZXRNZW1vcnlPcHRpbWl6ZWRWZWM0KHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgMik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIHJldHVybiB2ZWM0KHRleGVsLnIsIHRleGVsLmcsIHRleGVsLmIsIHRleGVsLmEpO1xufVxuXG52ZWM0IGFjdHVhbENvbG9yO1xudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiLCBmbG9hdCBhKSB7XG4gIGFjdHVhbENvbG9yID0gdmVjNChyLGcsYixhKTtcbn1cblxudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiKSB7XG4gIGNvbG9yKHIsZyxiLDEuMCk7XG59XG5cbmZsb2F0IG1vZHVsbyhmbG9hdCBudW1iZXIsIGZsb2F0IGRpdmlzb3IpIHtcbiAgaWYgKG51bWJlciA8IDAuMCkge1xuICAgIG51bWJlciA9IGFicyhudW1iZXIpO1xuICAgIGlmIChkaXZpc29yIDwgMC4wKSB7XG4gICAgICBkaXZpc29yID0gYWJzKGRpdmlzb3IpO1xuICAgIH1cbiAgICByZXR1cm4gLW1vZChudW1iZXIsIGRpdmlzb3IpO1xuICB9XG4gIGlmIChkaXZpc29yIDwgMC4wKSB7XG4gICAgZGl2aXNvciA9IGFicyhkaXZpc29yKTtcbiAgfVxuICByZXR1cm4gbW9kKG51bWJlciwgZGl2aXNvcik7XG59XG5cbl9fSU5KRUNURURfTkFUSVZFX187XG5fX01BSU5fQ09OU1RBTlRTX187XG5fX01BSU5fQVJHVU1FTlRTX187XG5fX0tFUk5FTF9fO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBpbmRleCA9IGludCh2VGV4Q29vcmQucyAqIGZsb2F0KHVUZXhTaXplLngpKSArIGludCh2VGV4Q29vcmQudCAqIGZsb2F0KHVUZXhTaXplLnkpKSAqIHVUZXhTaXplLng7XG4gIF9fTUFJTl9SRVNVTFRfXztcbn1gO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZnJhZ21lbnRTaGFkZXJcbn07XG59LHt9XSw3MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi4vd2ViLWdsL2Z1bmN0aW9uLW5vZGUnKTtcblxuY2xhc3MgV2ViR0wyRnVuY3Rpb25Ob2RlIGV4dGVuZHMgV2ViR0xGdW5jdGlvbk5vZGUge1xuXG4gIGFzdElkZW50aWZpZXJFeHByZXNzaW9uKGlkdE5vZGUsIHJldEFycikge1xuICAgIGlmIChpZHROb2RlLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcbiAgICAgICAgJ0lkZW50aWZpZXJFeHByZXNzaW9uIC0gbm90IGFuIElkZW50aWZpZXInLFxuICAgICAgICBpZHROb2RlXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoaWR0Tm9kZSk7XG5cbiAgICBjb25zdCBuYW1lID0gdXRpbHMuc2FuaXRpemVOYW1lKGlkdE5vZGUubmFtZSk7XG4gICAgaWYgKGlkdE5vZGUubmFtZSA9PT0gJ0luZmluaXR5Jykge1xuICAgICAgcmV0QXJyLnB1c2goJ2ludEJpdHNUb0Zsb2F0KDIxMzkwOTUwMzkpJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnQm9vbGVhbicpIHtcbiAgICAgIGlmICh0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgIHJldEFyci5wdXNoKGBib29sKHVzZXJfJHtuYW1lfSlgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7bmFtZX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHtuYW1lfWApO1xuICAgIH1cblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMkZ1bmN0aW9uTm9kZVxufTtcbn0se1wiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi93ZWItZ2wvZnVuY3Rpb24tbm9kZVwiOjM4fV0sNzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4gfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2Jvb2xlYW4nKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVGbG9hdCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZmxvYXQnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9pbnRlZ2VyJyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2h0bWwtaW1hZ2UnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2UnKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlLWFycmF5Jyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2UtYXJyYXknKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxWaWRlbyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvaHRtbC12aWRlbycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8gfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtaHRtbC12aWRlbycpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dCcpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtaW5wdXQnKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3Vuc2lnbmVkLWlucHV0Jyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtaW5wdXQnKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlJyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9udW1iZXItdGV4dHVyZScpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLW51bWJlci10ZXh0dXJlJyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5Jyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWknKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MWQtaScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWknKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MmQtaScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWknKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5M2QtaScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlQXJyYXkyIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9hcnJheTInKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVBcnJheTMgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2FycmF5MycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5NCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvYXJyYXk0Jyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1hcnJheScpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWFycmF5Jyk7XG5cbmNvbnN0IGtlcm5lbFZhbHVlTWFwcyA9IHtcbiAgdW5zaWduZWQ6IHtcbiAgICBkeW5hbWljOiB7XG4gICAgICAnQm9vbGVhbic6IFdlYkdMMktlcm5lbFZhbHVlQm9vbGVhbixcbiAgICAgICdJbnRlZ2VyJzogV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0Zsb2F0JzogV2ViR0wyS2VybmVsVmFsdWVGbG9hdCxcbiAgICAgICdBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXksXG4gICAgICAnQXJyYXkoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5MixcbiAgICAgICdBcnJheSgzKSc6IFdlYkdMMktlcm5lbFZhbHVlQXJyYXkzLFxuICAgICAgJ0FycmF5KDQpJzogV2ViR0wyS2VybmVsVmFsdWVBcnJheTQsXG4gICAgICAnQXJyYXkxRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDQpJzogZmFsc2UsXG4gICAgICAnSW5wdXQnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgxKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdPZmZzY3JlZW5DYW52YXMnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0ltYWdlQml0bWFwJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0ltYWdlRGF0YSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZUFycmF5LFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyxcbiAgICB9LFxuICAgIHN0YXRpYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnRmxvYXQnOiBXZWJHTDJLZXJuZWxWYWx1ZUZsb2F0LFxuICAgICAgJ0ludGVnZXInOiBXZWJHTDJLZXJuZWxWYWx1ZUludGVnZXIsXG4gICAgICAnQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXksXG4gICAgICAnQXJyYXkoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5MixcbiAgICAgICdBcnJheSgzKSc6IFdlYkdMMktlcm5lbFZhbHVlQXJyYXkzLFxuICAgICAgJ0FycmF5KDQpJzogV2ViR0wyS2VybmVsVmFsdWVBcnJheTQsXG4gICAgICAnQXJyYXkxRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDQpJzogZmFsc2UsXG4gICAgICAnSW5wdXQnOiBXZWJHTDJLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXQsXG4gICAgICAnTnVtYmVyVGV4dHVyZSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMSknOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgzKSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ09mZnNjcmVlbkNhbnZhcyc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0ltYWdlQml0bWFwJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSW1hZ2VEYXRhJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZUFycmF5LFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTFZpZGVvLFxuICAgIH1cbiAgfSxcbiAgc2luZ2xlOiB7XG4gICAgZHluYW1pYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnSW50ZWdlcic6IFdlYkdMMktlcm5lbFZhbHVlSW50ZWdlcixcbiAgICAgICdGbG9hdCc6IFdlYkdMMktlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheSxcbiAgICAgICdBcnJheSgyKSc6IFdlYkdMMktlcm5lbFZhbHVlQXJyYXkyLFxuICAgICAgJ0FycmF5KDMpJzogV2ViR0wyS2VybmVsVmFsdWVBcnJheTMsXG4gICAgICAnQXJyYXkoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5NCxcbiAgICAgICdBcnJheTFEKDIpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREksXG4gICAgICAnQXJyYXkxRCgzKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTJEKDIpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREksXG4gICAgICAnQXJyYXkyRCgzKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTNEKDIpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREksXG4gICAgICAnQXJyYXkzRCgzKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESSxcbiAgICAgICdJbnB1dCc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUlucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgxKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdPZmZzY3JlZW5DYW52YXMnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0ltYWdlQml0bWFwJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0ltYWdlRGF0YSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZUFycmF5LFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyxcbiAgICB9LFxuICAgIHN0YXRpYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnRmxvYXQnOiBXZWJHTDJLZXJuZWxWYWx1ZUZsb2F0LFxuICAgICAgJ0ludGVnZXInOiBXZWJHTDJLZXJuZWxWYWx1ZUludGVnZXIsXG4gICAgICAnQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0wyS2VybmVsVmFsdWVBcnJheTIsXG4gICAgICAnQXJyYXkoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5MyxcbiAgICAgICdBcnJheSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MkQoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5M0QoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0lucHV0JzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgxKSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogV2ViR0wyS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdPZmZzY3JlZW5DYW52YXMnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdJbWFnZUJpdG1hcCc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0ltYWdlRGF0YSc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZUFycmF5JzogV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2VBcnJheSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxWaWRlbyxcbiAgICB9XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBsb29rdXBLZXJuZWxWYWx1ZVR5cGUodHlwZSwgZHluYW1pYywgcHJlY2lzaW9uLCB2YWx1ZSkge1xuICBpZiAoIXR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUgbWlzc2luZycpO1xuICB9XG4gIGlmICghZHluYW1pYykge1xuICAgIHRocm93IG5ldyBFcnJvcignZHluYW1pYyBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKCFwcmVjaXNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWNpc2lvbiBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKHZhbHVlLnR5cGUpIHtcbiAgICB0eXBlID0gdmFsdWUudHlwZTtcbiAgfVxuICBjb25zdCB0eXBlcyA9IGtlcm5lbFZhbHVlTWFwc1twcmVjaXNpb25dW2R5bmFtaWNdO1xuICBpZiAodHlwZXNbdHlwZV0gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZXNbdHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBLZXJuZWxWYWx1ZSBmb3IgJHsgdHlwZSB9YCk7XG4gIH1cbiAgcmV0dXJuIHR5cGVzW3R5cGVdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga2VybmVsVmFsdWVNYXBzLFxuICBsb29rdXBLZXJuZWxWYWx1ZVR5cGVcbn07XG59LHtcIi4va2VybmVsLXZhbHVlL2FycmF5MlwiOjc1LFwiLi9rZXJuZWwtdmFsdWUvYXJyYXkzXCI6NzYsXCIuL2tlcm5lbC12YWx1ZS9hcnJheTRcIjo3NyxcIi4va2VybmVsLXZhbHVlL2Jvb2xlYW5cIjo3OCxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtaHRtbC1pbWFnZVwiOjgwLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlLWFycmF5XCI6NzksXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtdmlkZW9cIjo4MSxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZVwiOjgyLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1udW1iZXItdGV4dHVyZVwiOjgzLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXlcIjo4NCxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MWQtaVwiOjg1LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkyZC1pXCI6ODYsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTNkLWlcIjo4NyxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWlucHV0XCI6ODgsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWFycmF5XCI6ODksXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWlucHV0XCI6OTAsXCIuL2tlcm5lbC12YWx1ZS9mbG9hdFwiOjkxLFwiLi9rZXJuZWwtdmFsdWUvaHRtbC1pbWFnZVwiOjkzLFwiLi9rZXJuZWwtdmFsdWUvaHRtbC1pbWFnZS1hcnJheVwiOjkyLFwiLi9rZXJuZWwtdmFsdWUvaHRtbC12aWRlb1wiOjk0LFwiLi9rZXJuZWwtdmFsdWUvaW50ZWdlclwiOjk1LFwiLi9rZXJuZWwtdmFsdWUvbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZVwiOjk2LFwiLi9rZXJuZWwtdmFsdWUvbnVtYmVyLXRleHR1cmVcIjo5NyxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheVwiOjk4LFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MWQtaVwiOjk5LFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MmQtaVwiOjEwMCxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWlcIjoxMDEsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtaW5wdXRcIjoxMDIsXCIuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1hcnJheVwiOjEwMyxcIi4va2VybmVsLXZhbHVlL3Vuc2lnbmVkLWlucHV0XCI6MTA0fV0sNzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlQXJyYXkyIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2FycmF5MicpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5MiBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVBcnJheTIge31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlQXJyYXkyXG59O1xufSx7XCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2FycmF5MlwiOjQxfV0sNzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlQXJyYXkzIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2FycmF5MycpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5MyBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVBcnJheTMge31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlQXJyYXkzXG59O1xufSx7XCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2FycmF5M1wiOjQyfV0sNzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlQXJyYXk0IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2FycmF5NCcpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUFycmF5NCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVBcnJheTQge31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlQXJyYXk0XG59O1xufSx7XCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2FycmF5NFwiOjQzfV0sNzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbiB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9ib29sZWFuJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlQm9vbGVhbiBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVCb29sZWFuIHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW5cbn07XG59LHtcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvYm9vbGVhblwiOjQ0fV0sNzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2VBcnJheSB9ID0gcmVxdWlyZSgnLi9odG1sLWltYWdlLWFycmF5Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZUFycmF5IGV4dGVuZHMgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2VBcnJheSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyREFycmF5ICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKGltYWdlcykge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gaW1hZ2VzWzBdO1xuICAgIHRoaXMuY2hlY2tTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IFt3aWR0aCwgaGVpZ2h0LCBpbWFnZXMubGVuZ3RoXTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gW3dpZHRoLCBoZWlnaHRdO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUoaW1hZ2VzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9odG1sLWltYWdlLWFycmF5XCI6OTJ9XSw4MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2UnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2Uge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2Vcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2VcIjo0NX1dLDgxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9keW5hbWljLWh0bWwtaW1hZ2UnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvIGV4dGVuZHMgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW9cbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9keW5hbWljLWh0bWwtaW1hZ2VcIjo4MH1dLDgyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9keW5hbWljLW1lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmVcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9keW5hbWljLW1lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo0N31dLDgzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9keW5hbWljLW51bWJlci10ZXh0dXJlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1udW1iZXItdGV4dHVyZVwiOjQ4fV0sODQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5IGV4dGVuZHMgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IHV0aWxzLmdldERpbWVuc2lvbnModmFsdWUsIHRydWUpO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5XCI6OTh9XSw4NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wyL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkxZC1pJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJIGV4dGVuZHMgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wyL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkxZC1pXCI6OTl9XSw4NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wyL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyZC1pJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJIGV4dGVuZHMgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wyL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyZC1pXCI6MTAwfV0sODc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaVwiOjEwMX1dLDg4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dCcpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlSW5wdXQge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBsZXQgW3csIGgsIGRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdyB8fCAxLCBoIHx8IDEsIGQgfHwgMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlSW5wdXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWlucHV0XCI6MTAyfV0sODk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtYXJyYXknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWFycmF5XCI6NTR9XSw5MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXQgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1pbnB1dCcpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtaW5wdXRcIjo1NX1dLDkxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVGbG9hdCB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9mbG9hdCcpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUZsb2F0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUZsb2F0IHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUZsb2F0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZmxvYXRcIjo1Nn1dLDkyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvYXJyYXknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2VBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuY2hlY2tTaXplKHZhbHVlWzBdLndpZHRoLCB2YWx1ZVswXS5oZWlnaHQpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IFt2YWx1ZVswXS53aWR0aCwgdmFsdWVbMF0uaGVpZ2h0LCB2YWx1ZS5sZW5ndGhdO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSBbdmFsdWVbMF0ud2lkdGgsIHZhbHVlWzBdLmhlaWdodF07XG4gIH1cbiAgZGVmaW5lVGV4dHVyZSgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJEX0FSUkFZLCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkRfQVJSQVksIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkRBcnJheSAke3RoaXMuaWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbWFnZXMpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJEX0FSUkFZLCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuICAgIGdsLnRleEltYWdlM0QoXG4gICAgICBnbC5URVhUVVJFXzJEX0FSUkFZLFxuICAgICAgMCxcbiAgICAgIGdsLlJHQkEsXG4gICAgICBpbWFnZXNbMF0ud2lkdGgsXG4gICAgICBpbWFnZXNbMF0uaGVpZ2h0LFxuICAgICAgaW1hZ2VzLmxlbmd0aCxcbiAgICAgIDAsXG4gICAgICBnbC5SR0JBLFxuICAgICAgZ2wuVU5TSUdORURfQllURSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB4T2Zmc2V0ID0gMDtcbiAgICAgIGNvbnN0IHlPZmZzZXQgPSAwO1xuICAgICAgY29uc3QgaW1hZ2VEZXB0aCA9IDE7XG4gICAgICBnbC50ZXhTdWJJbWFnZTNEKFxuICAgICAgICBnbC5URVhUVVJFXzJEX0FSUkFZLFxuICAgICAgICAwLFxuICAgICAgICB4T2Zmc2V0LFxuICAgICAgICB5T2Zmc2V0LFxuICAgICAgICBpLFxuICAgICAgICBpbWFnZXNbaV0ud2lkdGgsXG4gICAgICAgIGltYWdlc1tpXS5oZWlnaHQsXG4gICAgICAgIGltYWdlRGVwdGgsXG4gICAgICAgIGdsLlJHQkEsXG4gICAgICAgIGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHRoaXMudXBsb2FkVmFsdWUgPSBpbWFnZXNbaV1cbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2VBcnJheVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2FycmF5XCI6NDB9XSw5MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2h0bWwtaW1hZ2UnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2Vcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlXCI6NTd9XSw5NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlSFRNTFZpZGVvIGV4dGVuZHMgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2Uge31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlSFRNTFZpZGVvXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaHRtbC1pbWFnZVwiOjkzfV0sOTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSW50ZWdlciB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9pbnRlZ2VyJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlSW50ZWdlciBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyIHtcbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgcmV0dXJuIGBjb25zdCAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGludCAke3RoaXMuaWR9ID0gJHsgcGFyc2VJbnQodmFsdWUpIH07XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaW50ICR7dGhpcy5pZH07XFxuYDtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUludGVnZXJcbn07XG59LHtcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvaW50ZWdlclwiOjYwfV0sOTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB7IGlkLCBzaXplSWQsIHRleHR1cmVTaXplLCBkaW1lbnNpb25zSWQsIGRpbWVuc2lvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7aWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7c2l6ZUlkfSA9IGl2ZWMyKCR7dGV4dHVyZVNpemVbMF19LCAke3RleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHtkaW1lbnNpb25zSWR9ID0gaXZlYzMoJHtkaW1lbnNpb25zWzBdfSwgJHtkaW1lbnNpb25zWzFdfSwgJHtkaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmVcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlXCI6NjF9XSw5NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB7IGlkLCBzaXplSWQsIHRleHR1cmVTaXplLCBkaW1lbnNpb25zSWQsIGRpbWVuc2lvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHtpZH1gLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHtzaXplSWR9ID0gaXZlYzIoJHt0ZXh0dXJlU2l6ZVswXX0sICR7dGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke2RpbWVuc2lvbnNJZH0gPSBpdmVjMygke2RpbWVuc2lvbnNbMF19LCAke2RpbWVuc2lvbnNbMV19LCAke2RpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL251bWJlci10ZXh0dXJlXCI6NjJ9XSw5ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuVG8odmFsdWUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEzMkYsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXlcIjo2M31dLDk5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkxZC1pJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkge1xuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5Ubyh2YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQTMyRiwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWlcIjo2NH1dLDEwMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MmQtaScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIHtcbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuVG8odmFsdWUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEzMkYsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyZC1pXCI6NjV9XSwxMDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB7XG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaVwiOjY2fV0sMTAyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtaW5wdXQnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKGlucHV0LnZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUlucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWlucHV0XCI6Njd9XSwxMDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvdW5zaWduZWQtYXJyYXknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1hcnJheVwiOjY4fV0sMTA0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3Vuc2lnbmVkLWlucHV0Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZElucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvdW5zaWduZWQtaW5wdXRcIjo2OX1dLDEwNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsIH0gPSByZXF1aXJlKCcuLi93ZWItZ2wva2VybmVsJyk7XG5jb25zdCB7IFdlYkdMMkZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi1ub2RlJyk7XG5jb25zdCB7IEZ1bmN0aW9uQnVpbGRlciB9ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tYnVpbGRlcicpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgZnJhZ21lbnRTaGFkZXIgfSA9IHJlcXVpcmUoJy4vZnJhZ21lbnQtc2hhZGVyJyk7XG5jb25zdCB7IHZlcnRleFNoYWRlciB9ID0gcmVxdWlyZSgnLi92ZXJ0ZXgtc2hhZGVyJyk7XG5jb25zdCB7IGxvb2t1cEtlcm5lbFZhbHVlVHlwZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUtbWFwcycpO1xuXG5sZXQgaXNTdXBwb3J0ZWQgPSBudWxsO1xubGV0IHRlc3RDYW52YXMgPSBudWxsO1xubGV0IHRlc3RDb250ZXh0ID0gbnVsbDtcbmxldCB0ZXN0RXh0ZW5zaW9ucyA9IG51bGw7XG5cbmxldCBmZWF0dXJlcyA9IG51bGw7XG5cbmNsYXNzIFdlYkdMMktlcm5lbCBleHRlbmRzIFdlYkdMS2VybmVsIHtcbiAgc3RhdGljIGdldCBpc1N1cHBvcnRlZCgpIHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgICB9XG4gICAgdGhpcy5zZXR1cEZlYXR1cmVDaGVja3MoKTtcbiAgICBpc1N1cHBvcnRlZCA9IHRoaXMuaXNDb250ZXh0TWF0Y2godGVzdENvbnRleHQpO1xuICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHN0YXRpYyBzZXR1cEZlYXR1cmVDaGVja3MoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRlc3RDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0ZXN0Q2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygwLCAwKTtcbiAgICB9XG4gICAgaWYgKCF0ZXN0Q2FudmFzKSByZXR1cm47XG4gICAgdGVzdENvbnRleHQgPSB0ZXN0Q2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicpO1xuICAgIGlmICghdGVzdENvbnRleHQgfHwgIXRlc3RDb250ZXh0LmdldEV4dGVuc2lvbikgcmV0dXJuO1xuICAgIHRlc3RFeHRlbnNpb25zID0ge1xuICAgICAgRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdDogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JyksXG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXI6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyksXG4gICAgfTtcbiAgICBmZWF0dXJlcyA9IHRoaXMuZ2V0RmVhdHVyZXMoKTtcbiAgfVxuXG4gIHN0YXRpYyBpc0NvbnRleHRNYXRjaChjb250ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGNvbnRleHQgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgZ2V0RmVhdHVyZXMoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLnRlc3RDb250ZXh0O1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgIGlzRmxvYXRSZWFkOiB0aGlzLmdldElzRmxvYXRSZWFkKCksXG4gICAgICBpc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlOiB0aGlzLmdldElzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUoKSxcbiAgICAgIGlzU3BlZWRUYWN0aWNTdXBwb3J0ZWQ6IHRoaXMuZ2V0SXNTcGVlZFRhY3RpY1N1cHBvcnRlZCgpLFxuICAgICAga2VybmVsTWFwOiB0cnVlLFxuICAgICAgaXNUZXh0dXJlRmxvYXQ6IHRydWUsXG4gICAgICBpc0RyYXdCdWZmZXJzOiB0cnVlLFxuICAgICAgY2hhbm5lbENvdW50OiB0aGlzLmdldENoYW5uZWxDb3VudCgpLFxuICAgICAgbWF4VGV4dHVyZVNpemU6IHRoaXMuZ2V0TWF4VGV4dHVyZVNpemUoKSxcbiAgICAgIGxvd0ludFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTE9XX0lOVCksXG4gICAgICBsb3dGbG9hdFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTE9XX0ZMT0FUKSxcbiAgICAgIG1lZGl1bUludFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0lOVCksXG4gICAgICBtZWRpdW1GbG9hdFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKSxcbiAgICAgIGhpZ2hJbnRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfSU5UKSxcbiAgICAgIGhpZ2hGbG9hdFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCksXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0SXNUZXh0dXJlRmxvYXQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdGF0aWMgZ2V0Q2hhbm5lbENvdW50KCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dC5nZXRQYXJhbWV0ZXIodGVzdENvbnRleHQuTUFYX0RSQVdfQlVGRkVSUyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0TWF4VGV4dHVyZVNpemUoKSB7XG4gICAgcmV0dXJuIHRlc3RDb250ZXh0LmdldFBhcmFtZXRlcih0ZXN0Q29udGV4dC5NQVhfVEVYVFVSRV9TSVpFKTtcbiAgfVxuXG4gIHN0YXRpYyBsb29rdXBLZXJuZWxWYWx1ZVR5cGUodHlwZSwgZHluYW1pYywgcHJlY2lzaW9uLCB2YWx1ZSkge1xuICAgIHJldHVybiBsb29rdXBLZXJuZWxWYWx1ZVR5cGUodHlwZSwgZHluYW1pYywgcHJlY2lzaW9uLCB2YWx1ZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDYW52YXMoKSB7XG4gICAgcmV0dXJuIHRlc3RDYW52YXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDb250ZXh0KCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgc3RhdGljIGdldCBmcmFnbWVudFNoYWRlcigpIHtcbiAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gIH1cbiAgc3RhdGljIGdldCB2ZXJ0ZXhTaGFkZXIoKSB7XG4gICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgfVxuXG4gIGluaXRDb250ZXh0KCkge1xuICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgYWxwaGE6IGZhbHNlLFxuICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgYW50aWFsaWFzOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIHNldHRpbmdzKTtcbiAgfVxuXG4gIGluaXRFeHRlbnNpb25zKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHtcbiAgICAgIEVYVF9jb2xvcl9idWZmZXJfZmxvYXQ6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKSxcbiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyksXG4gICAgfTtcbiAgfVxuXG4gIHZhbGlkYXRlU2V0dGluZ3MoYXJncykge1xuICAgIGlmICghdGhpcy52YWxpZGF0ZSkge1xuICAgICAgdGhpcy50ZXhTaXplID0gdXRpbHMuZ2V0S2VybmVsVGV4dHVyZVNpemUoe1xuICAgICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICAgIHByZWNpc2lvbjogdGhpcy5wcmVjaXNpb24sXG4gICAgICB9LCB0aGlzLm91dHB1dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBmZWF0dXJlcyB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnICYmICFmZWF0dXJlcy5pc0Zsb2F0UmVhZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbG9hdCB0ZXh0dXJlIG91dHB1dHMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmdyYXBoaWNhbCAmJiB0aGlzLnByZWNpc2lvbiA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5wcmVjaXNpb24gPSBmZWF0dXJlcy5pc0Zsb2F0UmVhZCA/ICdzaW5nbGUnIDogJ3Vuc2lnbmVkJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9ICFmZWF0dXJlcy5pc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSAmJiBmZWF0dXJlcy5pc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlKSB7XG4gICAgICB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja091dHB1dCgpO1xuXG4gICAgaWYgKCF0aGlzLm91dHB1dCB8fCB0aGlzLm91dHB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG8gb3V0cHV0IG9ubHkgc3VwcG9ydGVkIGZvciBrZXJuZWxzIHdpdGggb25seSBvbmUgaW5wdXQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXJnVHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZShhcmdzWzBdLCB0aGlzLnN0cmljdEludGVnZXJzKTtcbiAgICAgIHN3aXRjaCAoYXJnVHlwZSkge1xuICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgdGhpcy5vdXRwdXQgPSB1dGlscy5nZXREaW1lbnNpb25zKGFyZ1R5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdOdW1iZXJUZXh0dXJlJzpcbiAgICAgICAgY2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICAgICAgdGhpcy5vdXRwdXQgPSBhcmdzWzBdLm91dHB1dDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG8gb3V0cHV0IG5vdCBzdXBwb3J0ZWQgZm9yIGlucHV0IHR5cGU6ICcgKyBhcmdUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgIGlmICh0aGlzLm91dHB1dC5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdXRwdXQgbXVzdCBoYXZlIDIgZGltZW5zaW9ucyBvbiBncmFwaGljYWwgbW9kZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHVzZSBncmFwaGljYWwgbW9kZSBhbmQgc2luZ2xlIHByZWNpc2lvbiBhdCB0aGUgc2FtZSB0aW1lJyk7XG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gJ3Vuc2lnbmVkJztcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXhTaXplID0gdXRpbHMuY2xvbmUodGhpcy5vdXRwdXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZ3JhcGhpY2FsICYmIHRoaXMucHJlY2lzaW9uID09PSBudWxsICYmIGZlYXR1cmVzLmlzVGV4dHVyZUZsb2F0KSB7XG4gICAgICB0aGlzLnByZWNpc2lvbiA9ICdzaW5nbGUnO1xuICAgIH1cblxuICAgIHRoaXMudGV4U2l6ZSA9IHV0aWxzLmdldEtlcm5lbFRleHR1cmVTaXplKHtcbiAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgIHByZWNpc2lvbjogdGhpcy5wcmVjaXNpb24sXG4gICAgfSwgdGhpcy5vdXRwdXQpO1xuXG4gICAgdGhpcy5jaGVja1RleHR1cmVTaXplKCk7XG4gIH1cblxuICB0cmFuc2xhdGVTb3VyY2UoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25CdWlsZGVyID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgV2ViR0wyRnVuY3Rpb25Ob2RlLCB7XG4gICAgICBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeTogdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeVxuICAgIH0pO1xuICAgIHRoaXMudHJhbnNsYXRlZFNvdXJjZSA9IGZ1bmN0aW9uQnVpbGRlci5nZXRQcm90b3R5cGVTdHJpbmcoJ2tlcm5lbCcpO1xuICAgIHRoaXMuc2V0dXBSZXR1cm5UeXBlcyhmdW5jdGlvbkJ1aWxkZXIpO1xuICB9XG5cbiAgZHJhd0J1ZmZlcnMoKSB7XG4gICAgdGhpcy5jb250ZXh0LmRyYXdCdWZmZXJzKHRoaXMuZHJhd0J1ZmZlcnNNYXApO1xuICB9XG5cbiAgZ2V0VGV4dHVyZUZvcm1hdCgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAodGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpKSB7XG4gICAgICBjYXNlIGdsLlIzMkY6XG4gICAgICAgIHJldHVybiBnbC5SRUQ7XG4gICAgICBjYXNlIGdsLlJHMzJGOlxuICAgICAgICByZXR1cm4gZ2wuUkc7XG4gICAgICBjYXNlIGdsLlJHQkEzMkY6XG4gICAgICAgIHJldHVybiBnbC5SR0JBO1xuICAgICAgY2FzZSBnbC5SR0JBOlxuICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnRlcm5hbCBmb3JtYXQnKTtcbiAgICB9XG4gIH1cbiAgZ2V0SW50ZXJuYWxGb3JtYXQoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcblxuICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIGlmICh0aGlzLnBpcGVsaW5lKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBnbC5SR0JBMzJGO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdsLlIzMkY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgICAgICAgIHJldHVybiBnbC5SRzMyRjtcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzogXG4gICAgICAgICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgICAgICAgIHJldHVybiBnbC5SR0JBMzJGO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmhhbmRsZWQgcmV0dXJuIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdsLlJHQkEzMkY7XG4gICAgfVxuICAgIHJldHVybiBnbC5SR0JBO1xuICB9XG5cbiAgX3NldHVwT3V0cHV0VGV4dHVyZSgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZS50ZXh0dXJlLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGNvbnN0IHRleFNpemUgPSB0aGlzLnRleFNpemU7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRUZXh0dXJlQ291bnQgKyB0aGlzLmFyZ3VtZW50VGV4dHVyZUNvdW50KTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5SRVBFQVQpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLlJFUEVBVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldEludGVybmFsRm9ybWF0KCk7XG4gICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgZ2wudGV4U3RvcmFnZTJEKGdsLlRFWFRVUkVfMkQsIDEsIGZvcm1hdCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBmb3JtYXQsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgIH1cbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIHRoaXMudGV4dHVyZSA9IG5ldyB0aGlzLlRleHR1cmVDb25zdHJ1Y3Rvcih7XG4gICAgICB0ZXh0dXJlLFxuICAgICAgc2l6ZTogdGV4U2l6ZSxcbiAgICAgIGRpbWVuc2lvbnM6IHRoaXMudGhyZWFkRGltLFxuICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgIGludGVybmFsRm9ybWF0OiB0aGlzLmdldEludGVybmFsRm9ybWF0KCksXG4gICAgICB0ZXh0dXJlRm9ybWF0OiB0aGlzLmdldFRleHR1cmVGb3JtYXQoKSxcbiAgICAgIGtlcm5lbDogdGhpcyxcbiAgICB9KTtcbiAgfVxuXG4gIF9zZXR1cFN1Yk91dHB1dFRleHR1cmVzKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgIGlmICh0aGlzLm1hcHBlZFRleHR1cmVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5tYXBwZWRUZXh0dXJlc1tpXS50ZXh0dXJlLCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZTtcbiAgICB0aGlzLmRyYXdCdWZmZXJzTWFwID0gW2dsLkNPTE9SX0FUVEFDSE1FTlQwXTtcbiAgICB0aGlzLm1hcHBlZFRleHR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIHRoaXMuZHJhd0J1ZmZlcnNNYXAucHVzaChnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKyAxKTtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50ICsgdGhpcy5hcmd1bWVudFRleHR1cmVDb3VudCArIGkpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpO1xuICAgICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgICBnbC50ZXhTdG9yYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMSwgZm9ybWF0LCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICB9XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG5cbiAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXMucHVzaChuZXcgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3Ioe1xuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICBzaXplOiB0ZXhTaXplLFxuICAgICAgICBkaW1lbnNpb25zOiB0aGlzLnRocmVhZERpbSxcbiAgICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICBpbnRlcm5hbEZvcm1hdDogdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpLFxuICAgICAgICB0ZXh0dXJlRm9ybWF0OiB0aGlzLmdldFRleHR1cmVGb3JtYXQoKSxcbiAgICAgICAga2VybmVsOiB0aGlzLFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRIZWFkZXJTdHJpbmcoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgX2dldFRleHR1cmVDb29yZGluYXRlKCkge1xuICAgIGNvbnN0IHN1Yktlcm5lbHMgPSB0aGlzLnN1Yktlcm5lbHM7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4U2l6ZSwgdGhpcy50YWN0aWMpO1xuICAgIGlmIChzdWJLZXJuZWxzID09PSBudWxsIHx8IHN1Yktlcm5lbHMubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIGBpbiAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHZlYzIgdlRleENvb3JkO1xcbmA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgb3V0ICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gdmVjMiB2VGV4Q29vcmQ7XFxuYDtcbiAgICB9XG4gIH1cblxuICBfZ2V0TWFpbkFyZ3VtZW50c1N0cmluZyhhcmdzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgYXJndW1lbnROYW1lcyA9IHRoaXMuYXJndW1lbnROYW1lcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKHRoaXMua2VybmVsQXJndW1lbnRzW2ldLmdldFNvdXJjZShhcmdzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gIH1cblxuICBnZXRLZXJuZWxTdHJpbmcoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW3RoaXMuZ2V0S2VybmVsUmVzdWx0RGVjbGFyYXRpb24oKV07XG4gICAgY29uc3Qgc3ViS2VybmVscyA9IHRoaXMuc3ViS2VybmVscztcbiAgICBpZiAoc3ViS2VybmVscyAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICdsYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgdmVjNCBkYXRhMCdcbiAgICAgICk7XG4gICAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3ViS2VybmVsID0gc3ViS2VybmVsc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInID9cbiAgICAgICAgICAgICAgYGludCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IDBgIDpcbiAgICAgICAgICAgICAgYGZsb2F0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gMC4wYCxcbiAgICAgICAgICAgICAgYGxheW91dChsb2NhdGlvbiA9ICR7IGkgKyAxIH0pIG91dCB2ZWM0IGRhdGEkeyBpICsgMSB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBgdmVjMiBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsc1tpXS5uYW1lIH1gLFxuICAgICAgICAgICAgICBgbGF5b3V0KGxvY2F0aW9uID0gJHsgaSArIDEgfSkgb3V0IHZlYzQgZGF0YSR7IGkgKyAxIH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGB2ZWMzIHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWxzW2ldLm5hbWUgfWAsXG4gICAgICAgICAgICAgIGBsYXlvdXQobG9jYXRpb24gPSAkeyBpICsgMSB9KSBvdXQgdmVjNCBkYXRhJHsgaSArIDEgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYHZlYzQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbHNbaV0ubmFtZSB9YCxcbiAgICAgICAgICAgICAgYGxheW91dChsb2NhdGlvbiA9ICR7IGkgKyAxIH0pIG91dCB2ZWM0IGRhdGEkeyBpICsgMSB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAnb3V0IHZlYzQgZGF0YTAnXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCkgKyB0aGlzLnRyYW5zbGF0ZWRTb3VyY2U7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0R3JhcGhpY2FsKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBkYXRhMCA9IGFjdHVhbENvbG9yJyxcbiAgICBdKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRQYWNrZWRQaXhlbHMoKSB7XG4gICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbFBhY2tlZFBpeGVscygpICtcbiAgICAgICAgICB0aGlzLmdldE1haW5SZXN1bHRTdWJLZXJuZWxQYWNrZWRQaXhlbHMoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFja2VkIG91dHB1dCBvbmx5IHVzYWJsZSB3aXRoIE51bWJlcnMsIFwiJHt0aGlzLnJldHVyblR5cGV9XCIgc3BlY2lmaWVkYCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbFBhY2tlZFBpeGVscygpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgYCAgZGF0YTAgPSAke3RoaXMudXNlTGVnYWN5RW5jb2RlciA/ICdsZWdhY3lFbmNvZGUzMicgOiAnZW5jb2RlMzInfShrZXJuZWxSZXN1bHQpYFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbFBhY2tlZFBpeGVscygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICBpZiAoc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBkYXRhJHtpICsgMX0gPSAke3RoaXMudXNlTGVnYWN5RW5jb2RlciA/ICdsZWdhY3lFbmNvZGUzMicgOiAnZW5jb2RlMzInfShmbG9hdChzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX0pKWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGRhdGEke2kgKyAxfSA9ICR7dGhpcy51c2VMZWdhY3lFbmNvZGVyID8gJ2xlZ2FjeUVuY29kZTMyJyA6ICdlbmNvZGUzMid9KHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfSlgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCkge1xuICAgIHJlc3VsdC5wdXNoKFxuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgIGAgIGRhdGEwLiR7Y2hhbm5lbH0gPSBrZXJuZWxSZXN1bHRgXG4gICAgKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxNZW1vcnlPcHRpbWl6ZWRGbG9hdHMocmVzdWx0LCBjaGFubmVsKSB7XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGRhdGEke2kgKyAxfS4ke2NoYW5uZWx9ID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9KWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGRhdGEke2kgKyAxfS4ke2NoYW5uZWx9ID0gc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxOdW1iZXJUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZGF0YTBbMF0gPSBrZXJuZWxSZXN1bHQnLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgaWYgKHN1Yktlcm5lbC5yZXR1cm5UeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZGF0YSR7aSArIDF9WzBdID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9KWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGRhdGEke2kgKyAxfVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTJUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZGF0YTBbMF0gPSBrZXJuZWxSZXN1bHRbMF0nLFxuICAgICAgJyAgZGF0YTBbMV0gPSBrZXJuZWxSZXN1bHRbMV0nLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkyVGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgIGAgIGRhdGEke2kgKyAxfVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVswXWAsXG4gICAgICAgIGAgIGRhdGEke2kgKyAxfVsxXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVsxXWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkzVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGRhdGEwWzBdID0ga2VybmVsUmVzdWx0WzBdJyxcbiAgICAgICcgIGRhdGEwWzFdID0ga2VybmVsUmVzdWx0WzFdJyxcbiAgICAgICcgIGRhdGEwWzJdID0ga2VybmVsUmVzdWx0WzJdJyxcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5M1RleHR1cmUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBgICBkYXRhJHtpICsgMX1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bMF1gLFxuICAgICAgICBgICBkYXRhJHtpICsgMX1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bMV1gLFxuICAgICAgICBgICBkYXRhJHtpICsgMX1bMl0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bMl1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5NFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBkYXRhMCA9IGtlcm5lbFJlc3VsdCcsXG4gICAgXTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgYCAgZGF0YSR7aSArIDF9ID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGRlc3Ryb3lFeHRlbnNpb25zKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5FWFRfY29sb3JfYnVmZmVyX2Zsb2F0ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMuT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyID0gbnVsbDtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBqc29uID0gc3VwZXIudG9KU09OKCk7XG4gICAganNvbi5mdW5jdGlvbk5vZGVzID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgV2ViR0wyRnVuY3Rpb25Ob2RlKS50b0pTT04oKTtcbiAgICBqc29uLnNldHRpbmdzLnRocmVhZERpbSA9IHRoaXMudGhyZWFkRGltO1xuICAgIHJldHVybiBqc29uO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxcbn07XG59LHtcIi4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vZnVuY3Rpb24tYnVpbGRlclwiOjksXCIuLi93ZWItZ2wva2VybmVsXCI6NzAsXCIuL2ZyYWdtZW50LXNoYWRlclwiOjcyLFwiLi9mdW5jdGlvbi1ub2RlXCI6NzMsXCIuL2tlcm5lbC12YWx1ZS1tYXBzXCI6NzQsXCIuL3ZlcnRleC1zaGFkZXJcIjoxMDZ9XSwxMDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgdmVydGV4U2hhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xuX19GTE9BVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fSU5UX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuX19TQU1QTEVSXzJEX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuXG5pbiB2ZWMyIGFQb3M7XG5pbiB2ZWMyIGFUZXhDb29yZDtcblxub3V0IHZlYzIgdlRleENvb3JkO1xudW5pZm9ybSB2ZWMyIHJhdGlvO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9Qb3NpdGlvbiA9IHZlYzQoKGFQb3MgKyB2ZWMyKDEpKSAqIHJhdGlvICsgdmVjMigtMSksIDAsIDEpO1xuICB2VGV4Q29vcmQgPSBhVGV4Q29vcmQ7XG59YDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZlcnRleFNoYWRlclxufTtcbn0se31dLDEwNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBsaWIgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5jb25zdCBHUFUgPSBsaWIuR1BVO1xuZm9yIChjb25zdCBwIGluIGxpYikge1xuICBpZiAoIWxpYi5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gIGlmIChwID09PSAnR1BVJykgY29udGludWU7IFxuICBHUFVbcF0gPSBsaWJbcF07XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBiaW5kVG8od2luZG93KTtcbn1cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgYmluZFRvKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBiaW5kVG8odGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQuR1BVKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdHUFUnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEdQVTtcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpYjtcbn0se1wiLi9pbmRleFwiOjEwOX1dLDEwODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IGdwdU1vY2sgfSA9IHJlcXVpcmUoJ2dwdS1tb2NrLmpzJyk7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7IEtlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2tlcm5lbCcpO1xuY29uc3QgeyBDUFVLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9jcHUva2VybmVsJyk7XG5jb25zdCB7IEhlYWRsZXNzR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9oZWFkbGVzcy1nbC9rZXJuZWwnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWwnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wva2VybmVsJyk7XG5jb25zdCB7IGtlcm5lbFJ1blNob3J0Y3V0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC1ydW4tc2hvcnRjdXQnKTtcblxuXG5jb25zdCBrZXJuZWxPcmRlciA9IFtIZWFkbGVzc0dMS2VybmVsLCBXZWJHTDJLZXJuZWwsIFdlYkdMS2VybmVsXTtcblxuY29uc3Qga2VybmVsVHlwZXMgPSBbJ2dwdScsICdjcHUnXTtcblxuY29uc3QgaW50ZXJuYWxLZXJuZWxzID0ge1xuICAnaGVhZGxlc3NnbCc6IEhlYWRsZXNzR0xLZXJuZWwsXG4gICd3ZWJnbDInOiBXZWJHTDJLZXJuZWwsXG4gICd3ZWJnbCc6IFdlYkdMS2VybmVsLFxufTtcblxubGV0IHZhbGlkYXRlID0gdHJ1ZTtcblxuY2xhc3MgR1BVIHtcbiAgc3RhdGljIGRpc2FibGVWYWxpZGF0aW9uKCkge1xuICAgIHZhbGlkYXRlID0gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgZW5hYmxlVmFsaWRhdGlvbigpIHtcbiAgICB2YWxpZGF0ZSA9IHRydWU7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzR1BVU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBrZXJuZWxPcmRlci5zb21lKEtlcm5lbCA9PiBLZXJuZWwuaXNTdXBwb3J0ZWQpO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc0tlcm5lbE1hcFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4ga2VybmVsT3JkZXIuc29tZShLZXJuZWwgPT4gS2VybmVsLmlzU3VwcG9ydGVkICYmIEtlcm5lbC5mZWF0dXJlcy5rZXJuZWxNYXApO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB8fCB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzV2ViR0xTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIFdlYkdMS2VybmVsLmlzU3VwcG9ydGVkO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc1dlYkdMMlN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gV2ViR0wyS2VybmVsLmlzU3VwcG9ydGVkO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc0hlYWRsZXNzR0xTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIEhlYWRsZXNzR0xLZXJuZWwuaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzQ2FudmFzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc0dQVUhUTUxJbWFnZUFycmF5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBXZWJHTDJLZXJuZWwuaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzU2luZ2xlUHJlY2lzaW9uU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBrZXJuZWxPcmRlci5zb21lKEtlcm5lbCA9PiBLZXJuZWwuaXNTdXBwb3J0ZWQgJiYgS2VybmVsLmZlYXR1cmVzLmlzRmxvYXRSZWFkICYmIEtlcm5lbC5mZWF0dXJlcy5pc1RleHR1cmVGbG9hdCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgdGhpcy5jYW52YXMgPSBzZXR0aW5ncy5jYW52YXMgfHwgbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0IHx8IG51bGw7XG4gICAgdGhpcy5tb2RlID0gc2V0dGluZ3MubW9kZTtcbiAgICB0aGlzLktlcm5lbCA9IG51bGw7XG4gICAgdGhpcy5rZXJuZWxzID0gW107XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbiAgICB0aGlzLm5hdGl2ZUZ1bmN0aW9ucyA9IFtdO1xuICAgIHRoaXMuaW5qZWN0ZWROYXRpdmUgPSBudWxsO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdkZXYnKSByZXR1cm47XG4gICAgdGhpcy5jaG9vc2VLZXJuZWwoKTtcbiAgICBpZiAoc2V0dGluZ3MuZnVuY3Rpb25zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLmZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZEZ1bmN0aW9uKHNldHRpbmdzLmZ1bmN0aW9uc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBwIGluIHNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9ucykge1xuICAgICAgICBpZiAoIXNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IHMgPSBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnNbcF07XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgc291cmNlIH0gPSBzO1xuICAgICAgICB0aGlzLmFkZE5hdGl2ZUZ1bmN0aW9uKG5hbWUsIHNvdXJjZSwgcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2hvb3NlS2VybmVsKCkge1xuICAgIGlmICh0aGlzLktlcm5lbCkgcmV0dXJuO1xuXG4gICAgbGV0IEtlcm5lbCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbE9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEV4dGVybmFsS2VybmVsID0ga2VybmVsT3JkZXJbaV07XG4gICAgICAgIGlmIChFeHRlcm5hbEtlcm5lbC5pc0NvbnRleHRNYXRjaCh0aGlzLmNvbnRleHQpKSB7XG4gICAgICAgICAgaWYgKCFFeHRlcm5hbEtlcm5lbC5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgdHlwZSAke0V4dGVybmFsS2VybmVsLm5hbWV9IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgS2VybmVsID0gRXh0ZXJuYWxLZXJuZWw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChLZXJuZWwgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIENvbnRleHQnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSkge1xuICAgICAgaWYgKHRoaXMubW9kZSBpbiBpbnRlcm5hbEtlcm5lbHMpIHtcbiAgICAgICAgaWYgKCF2YWxpZGF0ZSB8fCBpbnRlcm5hbEtlcm5lbHNbdGhpcy5tb2RlXS5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgIEtlcm5lbCA9IGludGVybmFsS2VybmVsc1t0aGlzLm1vZGVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2dwdScpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChrZXJuZWxPcmRlcltpXS5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgS2VybmVsID0ga2VybmVsT3JkZXJbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSAnY3B1Jykge1xuICAgICAgICBLZXJuZWwgPSBDUFVLZXJuZWw7XG4gICAgICB9XG4gICAgICBpZiAoIUtlcm5lbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgcmVxdWVzdGVkIG1vZGUgb2YgXCIke3RoaXMubW9kZX1cIiBhbmQgaXMgbm90IHN1cHBvcnRlZGApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbE9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChrZXJuZWxPcmRlcltpXS5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgIEtlcm5lbCA9IGtlcm5lbE9yZGVyW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIUtlcm5lbCkge1xuICAgICAgICBLZXJuZWwgPSBDUFVLZXJuZWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm1vZGUpIHtcbiAgICAgIHRoaXMubW9kZSA9IEtlcm5lbC5tb2RlO1xuICAgIH1cbiAgICB0aGlzLktlcm5lbCA9IEtlcm5lbDtcbiAgfVxuXG4gIGNyZWF0ZUtlcm5lbChzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc291cmNlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcgJiYgIXV0aWxzLmlzRnVuY3Rpb24oc291cmNlKSAmJiB0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgcGFyYW1ldGVyIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3Qga2VybmVscyA9IHRoaXMua2VybmVscztcbiAgICBpZiAodGhpcy5tb2RlID09PSAnZGV2Jykge1xuICAgICAgY29uc3QgZGV2S2VybmVsID0gZ3B1TW9jayhzb3VyY2UsIHVwZ3JhZGVEZXByZWNhdGVkQ3JlYXRlS2VybmVsU2V0dGluZ3Moc2V0dGluZ3MpKTtcbiAgICAgIGtlcm5lbHMucHVzaChkZXZLZXJuZWwpO1xuICAgICAgcmV0dXJuIGRldktlcm5lbDtcbiAgICB9XG5cbiAgICBzb3VyY2UgPSB0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nID8gc291cmNlLnRvU3RyaW5nKCkgOiBzb3VyY2U7XG4gICAgY29uc3Qgc3dpdGNoYWJsZUtlcm5lbHMgPSB7fTtcbiAgICBjb25zdCBzZXR0aW5nc0NvcHkgPSB1cGdyYWRlRGVwcmVjYXRlZENyZWF0ZUtlcm5lbFNldHRpbmdzKHNldHRpbmdzKSB8fCB7fTtcbiAgICBpZiAoc2V0dGluZ3MgJiYgdHlwZW9mIHNldHRpbmdzLmFyZ3VtZW50VHlwZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBzZXR0aW5nc0NvcHkuYXJndW1lbnRUeXBlcyA9IE9iamVjdC5rZXlzKHNldHRpbmdzLmFyZ3VtZW50VHlwZXMpLm1hcChhcmd1bWVudE5hbWUgPT4gc2V0dGluZ3MuYXJndW1lbnRUeXBlc1thcmd1bWVudE5hbWVdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblJlcXVlc3RGYWxsYmFjayhhcmdzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhbGxpbmcgYmFjayB0byBDUFUnKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrS2VybmVsID0gbmV3IENQVUtlcm5lbChzb3VyY2UsIHtcbiAgICAgICAgYXJndW1lbnRUeXBlczoga2VybmVsUnVuLmFyZ3VtZW50VHlwZXMsXG4gICAgICAgIGNvbnN0YW50VHlwZXM6IGtlcm5lbFJ1bi5jb25zdGFudFR5cGVzLFxuICAgICAgICBncmFwaGljYWw6IGtlcm5lbFJ1bi5ncmFwaGljYWwsXG4gICAgICAgIGxvb3BNYXhJdGVyYXRpb25zOiBrZXJuZWxSdW4ubG9vcE1heEl0ZXJhdGlvbnMsXG4gICAgICAgIGNvbnN0YW50czoga2VybmVsUnVuLmNvbnN0YW50cyxcbiAgICAgICAgZHluYW1pY091dHB1dDoga2VybmVsUnVuLmR5bmFtaWNPdXRwdXQsXG4gICAgICAgIGR5bmFtaWNBcmd1bWVudDoga2VybmVsUnVuLmR5bmFtaWNBcmd1bWVudHMsXG4gICAgICAgIG91dHB1dDoga2VybmVsUnVuLm91dHB1dCxcbiAgICAgICAgcHJlY2lzaW9uOiBrZXJuZWxSdW4ucHJlY2lzaW9uLFxuICAgICAgICBwaXBlbGluZToga2VybmVsUnVuLnBpcGVsaW5lLFxuICAgICAgICBpbW11dGFibGU6IGtlcm5lbFJ1bi5pbW11dGFibGUsXG4gICAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IGtlcm5lbFJ1bi5vcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgICBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeToga2VybmVsUnVuLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5LFxuICAgICAgICBmdW5jdGlvbnM6IGtlcm5lbFJ1bi5mdW5jdGlvbnMsXG4gICAgICAgIG5hdGl2ZUZ1bmN0aW9uczoga2VybmVsUnVuLm5hdGl2ZUZ1bmN0aW9ucyxcbiAgICAgICAgaW5qZWN0ZWROYXRpdmU6IGtlcm5lbFJ1bi5pbmplY3RlZE5hdGl2ZSxcbiAgICAgICAgc3ViS2VybmVsczoga2VybmVsUnVuLnN1Yktlcm5lbHMsXG4gICAgICAgIHN0cmljdEludGVnZXJzOiBrZXJuZWxSdW4uc3RyaWN0SW50ZWdlcnMsXG4gICAgICAgIGRlYnVnOiBrZXJuZWxSdW4uZGVidWcsXG4gICAgICB9KTtcbiAgICAgIGZhbGxiYWNrS2VybmVsLmJ1aWxkLmFwcGx5KGZhbGxiYWNrS2VybmVsLCBhcmdzKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZhbGxiYWNrS2VybmVsLnJ1bi5hcHBseShmYWxsYmFja0tlcm5lbCwgYXJncyk7XG4gICAgICBrZXJuZWxSdW4ucmVwbGFjZUtlcm5lbChmYWxsYmFja0tlcm5lbCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUmVxdWVzdFN3aXRjaEtlcm5lbChyZWFzb25zLCBhcmdzLCBfa2VybmVsKSB7XG4gICAgICBpZiAoX2tlcm5lbC5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1N3aXRjaGluZyBrZXJuZWxzJyk7XG4gICAgICB9XG4gICAgICBsZXQgbmV3T3V0cHV0ID0gbnVsbDtcbiAgICAgIGlmIChfa2VybmVsLnNpZ25hdHVyZSAmJiAhc3dpdGNoYWJsZUtlcm5lbHNbX2tlcm5lbC5zaWduYXR1cmVdKSB7XG4gICAgICAgIHN3aXRjaGFibGVLZXJuZWxzW19rZXJuZWwuc2lnbmF0dXJlXSA9IF9rZXJuZWw7XG4gICAgICB9XG4gICAgICBpZiAoX2tlcm5lbC5keW5hbWljT3V0cHV0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSByZWFzb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgcmVhc29uID0gcmVhc29uc1tpXTtcbiAgICAgICAgICBpZiAocmVhc29uLnR5cGUgPT09ICdvdXRwdXRQcmVjaXNpb25NaXNtYXRjaCcpIHtcbiAgICAgICAgICAgIG5ld091dHB1dCA9IHJlYXNvbi5uZWVkZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IENvbnN0cnVjdG9yID0gX2tlcm5lbC5jb25zdHJ1Y3RvcjtcbiAgICAgIGNvbnN0IGFyZ3VtZW50VHlwZXMgPSBDb25zdHJ1Y3Rvci5nZXRBcmd1bWVudFR5cGVzKF9rZXJuZWwsIGFyZ3MpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gQ29uc3RydWN0b3IuZ2V0U2lnbmF0dXJlKF9rZXJuZWwsIGFyZ3VtZW50VHlwZXMpO1xuICAgICAgY29uc3QgZXhpc3RpbmdLZXJuZWwgPSBzd2l0Y2hhYmxlS2VybmVsc1tzaWduYXR1cmVdO1xuICAgICAgaWYgKGV4aXN0aW5nS2VybmVsKSB7XG4gICAgICAgIGV4aXN0aW5nS2VybmVsLm9uQWN0aXZhdGUoX2tlcm5lbCk7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0tlcm5lbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3S2VybmVsID0gc3dpdGNoYWJsZUtlcm5lbHNbc2lnbmF0dXJlXSA9IG5ldyBDb25zdHJ1Y3Rvcihzb3VyY2UsIHtcbiAgICAgICAgYXJndW1lbnRUeXBlcyxcbiAgICAgICAgY29uc3RhbnRUeXBlczogX2tlcm5lbC5jb25zdGFudFR5cGVzLFxuICAgICAgICBncmFwaGljYWw6IF9rZXJuZWwuZ3JhcGhpY2FsLFxuICAgICAgICBsb29wTWF4SXRlcmF0aW9uczogX2tlcm5lbC5sb29wTWF4SXRlcmF0aW9ucyxcbiAgICAgICAgY29uc3RhbnRzOiBfa2VybmVsLmNvbnN0YW50cyxcbiAgICAgICAgZHluYW1pY091dHB1dDogX2tlcm5lbC5keW5hbWljT3V0cHV0LFxuICAgICAgICBkeW5hbWljQXJndW1lbnQ6IF9rZXJuZWwuZHluYW1pY0FyZ3VtZW50cyxcbiAgICAgICAgY29udGV4dDogX2tlcm5lbC5jb250ZXh0LFxuICAgICAgICBjYW52YXM6IF9rZXJuZWwuY2FudmFzLFxuICAgICAgICBvdXRwdXQ6IG5ld091dHB1dCB8fCBfa2VybmVsLm91dHB1dCxcbiAgICAgICAgcHJlY2lzaW9uOiBfa2VybmVsLnByZWNpc2lvbixcbiAgICAgICAgcGlwZWxpbmU6IF9rZXJuZWwucGlwZWxpbmUsXG4gICAgICAgIGltbXV0YWJsZTogX2tlcm5lbC5pbW11dGFibGUsXG4gICAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IF9rZXJuZWwub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgICAgZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3k6IF9rZXJuZWwuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3ksXG4gICAgICAgIGZ1bmN0aW9uczogX2tlcm5lbC5mdW5jdGlvbnMsXG4gICAgICAgIG5hdGl2ZUZ1bmN0aW9uczogX2tlcm5lbC5uYXRpdmVGdW5jdGlvbnMsXG4gICAgICAgIGluamVjdGVkTmF0aXZlOiBfa2VybmVsLmluamVjdGVkTmF0aXZlLFxuICAgICAgICBzdWJLZXJuZWxzOiBfa2VybmVsLnN1Yktlcm5lbHMsXG4gICAgICAgIHN0cmljdEludGVnZXJzOiBfa2VybmVsLnN0cmljdEludGVnZXJzLFxuICAgICAgICBkZWJ1ZzogX2tlcm5lbC5kZWJ1ZyxcbiAgICAgICAgZ3B1OiBfa2VybmVsLmdwdSxcbiAgICAgICAgdmFsaWRhdGUsXG4gICAgICAgIHJldHVyblR5cGU6IF9rZXJuZWwucmV0dXJuVHlwZSxcbiAgICAgICAgdGFjdGljOiBfa2VybmVsLnRhY3RpYyxcbiAgICAgICAgb25SZXF1ZXN0RmFsbGJhY2ssXG4gICAgICAgIG9uUmVxdWVzdFN3aXRjaEtlcm5lbCxcbiAgICAgICAgdGV4dHVyZTogX2tlcm5lbC50ZXh0dXJlLFxuICAgICAgICBtYXBwZWRUZXh0dXJlczogX2tlcm5lbC5tYXBwZWRUZXh0dXJlcyxcbiAgICAgICAgZHJhd0J1ZmZlcnNNYXA6IF9rZXJuZWwuZHJhd0J1ZmZlcnNNYXAsXG4gICAgICB9KTtcbiAgICAgIG5ld0tlcm5lbC5idWlsZC5hcHBseShuZXdLZXJuZWwsIGFyZ3MpO1xuICAgICAga2VybmVsUnVuLnJlcGxhY2VLZXJuZWwobmV3S2VybmVsKTtcbiAgICAgIGtlcm5lbHMucHVzaChuZXdLZXJuZWwpO1xuICAgICAgcmV0dXJuIG5ld0tlcm5lbDtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkU2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXG4gICAgICBmdW5jdGlvbnM6IHRoaXMuZnVuY3Rpb25zLFxuICAgICAgbmF0aXZlRnVuY3Rpb25zOiB0aGlzLm5hdGl2ZUZ1bmN0aW9ucyxcbiAgICAgIGluamVjdGVkTmF0aXZlOiB0aGlzLmluamVjdGVkTmF0aXZlLFxuICAgICAgZ3B1OiB0aGlzLFxuICAgICAgdmFsaWRhdGUsXG4gICAgICBvblJlcXVlc3RGYWxsYmFjayxcbiAgICAgIG9uUmVxdWVzdFN3aXRjaEtlcm5lbFxuICAgIH0sIHNldHRpbmdzQ29weSk7XG5cbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgdGhpcy5LZXJuZWwoc291cmNlLCBtZXJnZWRTZXR0aW5ncyk7XG4gICAgY29uc3Qga2VybmVsUnVuID0ga2VybmVsUnVuU2hvcnRjdXQoa2VybmVsKTtcblxuICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzID0ga2VybmVsLmNhbnZhcztcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgdGhpcy5jb250ZXh0ID0ga2VybmVsLmNvbnRleHQ7XG4gICAgfVxuXG4gICAga2VybmVscy5wdXNoKGtlcm5lbCk7XG5cbiAgICByZXR1cm4ga2VybmVsUnVuO1xuICB9XG5cbiAgY3JlYXRlS2VybmVsTWFwKCkge1xuICAgIGxldCBmbjtcbiAgICBsZXQgc2V0dGluZ3M7XG4gICAgY29uc3QgYXJndW1lbnQyVHlwZSA9IHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDJdO1xuICAgIGlmIChhcmd1bWVudDJUeXBlID09PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50MlR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMl07XG4gICAgICBzZXR0aW5ncyA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tb2RlICE9PSAnZGV2Jykge1xuICAgICAgaWYgKCF0aGlzLktlcm5lbC5pc1N1cHBvcnRlZCB8fCAhdGhpcy5LZXJuZWwuZmVhdHVyZXMua2VybmVsTWFwKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgJiYga2VybmVsVHlwZXMuaW5kZXhPZih0aGlzLm1vZGUpIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihga2VybmVsTWFwIG5vdCBzdXBwb3J0ZWQgb24gJHt0aGlzLktlcm5lbC5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2V0dGluZ3NDb3B5ID0gdXBncmFkZURlcHJlY2F0ZWRDcmVhdGVLZXJuZWxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgaWYgKHNldHRpbmdzICYmIHR5cGVvZiBzZXR0aW5ncy5hcmd1bWVudFR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgc2V0dGluZ3NDb3B5LmFyZ3VtZW50VHlwZXMgPSBPYmplY3Qua2V5cyhzZXR0aW5ncy5hcmd1bWVudFR5cGVzKS5tYXAoYXJndW1lbnROYW1lID0+IHNldHRpbmdzLmFyZ3VtZW50VHlwZXNbYXJndW1lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgc2V0dGluZ3NDb3B5LnN1Yktlcm5lbHMgPSBbXTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGZ1bmN0aW9uc1tpXS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBuYW1lID0gdXRpbHMuZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZyhzb3VyY2UpO1xuICAgICAgICBzZXR0aW5nc0NvcHkuc3ViS2VybmVscy5wdXNoKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBwcm9wZXJ0eTogaSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldHRpbmdzQ29weS5zdWJLZXJuZWxzID0gW107XG4gICAgICBjb25zdCBmdW5jdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IgKGxldCBwIGluIGZ1bmN0aW9ucykge1xuICAgICAgICBpZiAoIWZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGZ1bmN0aW9uc1twXS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBuYW1lID0gdXRpbHMuZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZyhzb3VyY2UpO1xuICAgICAgICBzZXR0aW5nc0NvcHkuc3ViS2VybmVscy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBuYW1lIHx8IHAsXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHByb3BlcnR5OiBwLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlS2VybmVsKGZuLCBzZXR0aW5nc0NvcHkpO1xuICB9XG5cbiAgY29tYmluZUtlcm5lbHMoKSB7XG4gICAgY29uc3QgZmlyc3RLZXJuZWwgPSBhcmd1bWVudHNbMF07XG4gICAgY29uc3QgY29tYmluZWRLZXJuZWwgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChmaXJzdEtlcm5lbC5rZXJuZWwuY29uc3RydWN0b3IubW9kZSA9PT0gJ2NwdScpIHJldHVybiBjb21iaW5lZEtlcm5lbDtcbiAgICBjb25zdCBjYW52YXMgPSBhcmd1bWVudHNbMF0uY2FudmFzO1xuICAgIGNvbnN0IGNvbnRleHQgPSBhcmd1bWVudHNbMF0uY29udGV4dDtcbiAgICBjb25zdCBtYXggPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICBhcmd1bWVudHNbaV1cbiAgICAgICAgLnNldENhbnZhcyhjYW52YXMpXG4gICAgICAgIC5zZXRDb250ZXh0KGNvbnRleHQpXG4gICAgICAgIC5zZXRQaXBlbGluZSh0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gY29tYmluZWRLZXJuZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0ZXh0dXJlLnRvQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRleHR1cmUudG9BcnJheSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfTtcbiAgfVxuXG4gIHNldEZ1bmN0aW9ucyhmdW5jdGlvbnMpIHtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldE5hdGl2ZUZ1bmN0aW9ucyhuYXRpdmVGdW5jdGlvbnMpIHtcbiAgICB0aGlzLm5hdGl2ZUZ1bmN0aW9ucyA9IG5hdGl2ZUZ1bmN0aW9ucztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZEZ1bmN0aW9uKHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKHsgc291cmNlLCBzZXR0aW5ncyB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZE5hdGl2ZUZ1bmN0aW9uKG5hbWUsIHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICBpZiAodGhpcy5rZXJuZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgXCJhZGROYXRpdmVGdW5jdGlvblwiIGFmdGVyIFwiY3JlYXRlS2VybmVsc1wiIGhhcyBiZWVuIGNhbGxlZC4nKTtcbiAgICB9XG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMucHVzaChPYmplY3QuYXNzaWduKHsgbmFtZSwgc291cmNlIH0sIHNldHRpbmdzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpbmplY3ROYXRpdmUoc291cmNlKSB7XG4gICAgdGhpcy5pbmplY3RlZE5hdGl2ZSA9IHNvdXJjZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5rZXJuZWxzKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5rZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmtlcm5lbHNbaV0uZGVzdHJveSh0cnVlKTsgXG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBmaXJzdEtlcm5lbCA9IHRoaXMua2VybmVsc1swXTtcbiAgICAgICAgICBpZiAoZmlyc3RLZXJuZWwpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdEtlcm5lbC5rZXJuZWwpIHtcbiAgICAgICAgICAgICAgZmlyc3RLZXJuZWwgPSBmaXJzdEtlcm5lbC5rZXJuZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RLZXJuZWwuY29uc3RydWN0b3IuZGVzdHJveUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgZmlyc3RLZXJuZWwuY29uc3RydWN0b3IuZGVzdHJveUNvbnRleHQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSwgMCk7XG4gICAgfSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiB1cGdyYWRlRGVwcmVjYXRlZENyZWF0ZUtlcm5lbFNldHRpbmdzKHNldHRpbmdzKSB7XG4gIGlmICghc2V0dGluZ3MpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgdXBncmFkZWRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzKTtcblxuICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2Zsb2F0T3V0cHV0JykpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnc2V0dGluZycsICdmbG9hdE91dHB1dCcsICdwcmVjaXNpb24nKTtcbiAgICB1cGdyYWRlZFNldHRpbmdzLnByZWNpc2lvbiA9IHNldHRpbmdzLmZsb2F0T3V0cHV0ID8gJ3NpbmdsZScgOiAndW5zaWduZWQnO1xuICB9XG4gIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnb3V0cHV0VG9UZXh0dXJlJykpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnc2V0dGluZycsICdvdXRwdXRUb1RleHR1cmUnLCAncGlwZWxpbmUnKTtcbiAgICB1cGdyYWRlZFNldHRpbmdzLnBpcGVsaW5lID0gQm9vbGVhbihzZXR0aW5ncy5vdXRwdXRUb1RleHR1cmUpO1xuICB9XG4gIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnb3V0cHV0SW1tdXRhYmxlJykpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnc2V0dGluZycsICdvdXRwdXRJbW11dGFibGUnLCAnaW1tdXRhYmxlJyk7XG4gICAgdXBncmFkZWRTZXR0aW5ncy5pbW11dGFibGUgPSBCb29sZWFuKHNldHRpbmdzLm91dHB1dEltbXV0YWJsZSk7XG4gIH1cbiAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdmbG9hdFRleHR1cmVzJykpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnc2V0dGluZycsICdmbG9hdFRleHR1cmVzJywgJ29wdGltaXplRmxvYXRNZW1vcnknKTtcbiAgICB1cGdyYWRlZFNldHRpbmdzLm9wdGltaXplRmxvYXRNZW1vcnkgPSBCb29sZWFuKHNldHRpbmdzLmZsb2F0VGV4dHVyZXMpO1xuICB9XG4gIHJldHVybiB1cGdyYWRlZFNldHRpbmdzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR1BVLFxuICBrZXJuZWxPcmRlcixcbiAga2VybmVsVHlwZXNcbn07XG59LHtcIi4vYmFja2VuZC9jcHUva2VybmVsXCI6OCxcIi4vYmFja2VuZC9oZWFkbGVzcy1nbC9rZXJuZWxcIjozNCxcIi4vYmFja2VuZC9rZXJuZWxcIjozNixcIi4vYmFja2VuZC93ZWItZ2wva2VybmVsXCI6NzAsXCIuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWxcIjoxMDUsXCIuL2tlcm5lbC1ydW4tc2hvcnRjdXRcIjoxMTEsXCIuL3V0aWxzXCI6MTE0LFwiZ3B1LW1vY2suanNcIjo0fV0sMTA5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgR1BVIH0gPSByZXF1aXJlKCcuL2dwdScpO1xuY29uc3QgeyBhbGlhcyB9ID0gcmVxdWlyZSgnLi9hbGlhcycpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgeyBJbnB1dCwgaW5wdXQgfSA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcbmNvbnN0IHsgVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlJyk7XG5jb25zdCB7IEZ1bmN0aW9uQnVpbGRlciB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2Z1bmN0aW9uLWJ1aWxkZXInKTtcbmNvbnN0IHsgRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyBDUFVGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9jcHUvZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyBDUFVLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9jcHUva2VybmVsJyk7XG5cbmNvbnN0IHsgSGVhZGxlc3NHTEtlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2hlYWRsZXNzLWdsL2tlcm5lbCcpO1xuXG5jb25zdCB7IFdlYkdMRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsL2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wva2VybmVsJyk7XG5jb25zdCB7IGtlcm5lbFZhbHVlTWFwczogd2ViR0xLZXJuZWxWYWx1ZU1hcHMgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wva2VybmVsLXZhbHVlLW1hcHMnKTtcblxuY29uc3QgeyBXZWJHTDJGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wyL2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWwnKTtcbmNvbnN0IHsga2VybmVsVmFsdWVNYXBzOiB3ZWJHTDJLZXJuZWxWYWx1ZU1hcHMgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wyL2tlcm5lbC12YWx1ZS1tYXBzJyk7XG5cbmNvbnN0IHsgR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9nbC9rZXJuZWwnKTtcblxuY29uc3QgeyBLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9rZXJuZWwnKTtcblxuY29uc3QgeyBGdW5jdGlvblRyYWNlciB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2Z1bmN0aW9uLXRyYWNlcicpO1xuXG5jb25zdCBtYXRoUmFuZG9tID0gcmVxdWlyZSgnLi9wbHVnaW5zL21hdGgtcmFuZG9tLXVuaWZvcm1seS1kaXN0cmlidXRlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWxpYXMsXG4gIENQVUZ1bmN0aW9uTm9kZSxcbiAgQ1BVS2VybmVsLFxuICBHUFUsXG4gIEZ1bmN0aW9uQnVpbGRlcixcbiAgRnVuY3Rpb25Ob2RlLFxuICBIZWFkbGVzc0dMS2VybmVsLFxuICBJbnB1dCxcbiAgaW5wdXQsXG4gIFRleHR1cmUsXG4gIHV0aWxzLFxuXG4gIFdlYkdMMkZ1bmN0aW9uTm9kZSxcbiAgV2ViR0wyS2VybmVsLFxuICB3ZWJHTDJLZXJuZWxWYWx1ZU1hcHMsXG5cbiAgV2ViR0xGdW5jdGlvbk5vZGUsXG4gIFdlYkdMS2VybmVsLFxuICB3ZWJHTEtlcm5lbFZhbHVlTWFwcyxcblxuICBHTEtlcm5lbCxcbiAgS2VybmVsLFxuICBGdW5jdGlvblRyYWNlcixcblxuICBwbHVnaW5zOiB7XG4gICAgbWF0aFJhbmRvbVxuICB9XG59O1xufSx7XCIuL2FsaWFzXCI6NSxcIi4vYmFja2VuZC9jcHUvZnVuY3Rpb24tbm9kZVwiOjYsXCIuL2JhY2tlbmQvY3B1L2tlcm5lbFwiOjgsXCIuL2JhY2tlbmQvZnVuY3Rpb24tYnVpbGRlclwiOjksXCIuL2JhY2tlbmQvZnVuY3Rpb24tbm9kZVwiOjEwLFwiLi9iYWNrZW5kL2Z1bmN0aW9uLXRyYWNlclwiOjExLFwiLi9iYWNrZW5kL2dsL2tlcm5lbFwiOjEzLFwiLi9iYWNrZW5kL2hlYWRsZXNzLWdsL2tlcm5lbFwiOjM0LFwiLi9iYWNrZW5kL2tlcm5lbFwiOjM2LFwiLi9iYWNrZW5kL3dlYi1nbC9mdW5jdGlvbi1ub2RlXCI6MzgsXCIuL2JhY2tlbmQvd2ViLWdsL2tlcm5lbFwiOjcwLFwiLi9iYWNrZW5kL3dlYi1nbC9rZXJuZWwtdmFsdWUtbWFwc1wiOjM5LFwiLi9iYWNrZW5kL3dlYi1nbDIvZnVuY3Rpb24tbm9kZVwiOjczLFwiLi9iYWNrZW5kL3dlYi1nbDIva2VybmVsXCI6MTA1LFwiLi9iYWNrZW5kL3dlYi1nbDIva2VybmVsLXZhbHVlLW1hcHNcIjo3NCxcIi4vZ3B1XCI6MTA4LFwiLi9pbnB1dFwiOjExMCxcIi4vcGx1Z2lucy9tYXRoLXJhbmRvbS11bmlmb3JtbHktZGlzdHJpYnV0ZWRcIjoxMTIsXCIuL3RleHR1cmVcIjoxMTMsXCIuL3V0aWxzXCI6MTE0fV0sMTEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNsYXNzIElucHV0IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNpemUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2l6ZSkpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2l6ZSA9IG5ldyBJbnQzMkFycmF5KDMpO1xuICAgICAgaWYgKHNpemUueikge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXcgSW50MzJBcnJheShbc2l6ZS54LCBzaXplLnksIHNpemUuel0pO1xuICAgICAgfSBlbHNlIGlmIChzaXplLnkpIHtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3IEludDMyQXJyYXkoW3NpemUueCwgc2l6ZS55XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXcgSW50MzJBcnJheShbc2l6ZS54XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW3csIGgsIGRdID0gdGhpcy5zaXplO1xuICAgIGlmIChkKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggIT09ICh3ICogaCAqIGQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSAke3RoaXMudmFsdWUubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCAke3d9ICogJHtofSAqICR7ZH0gPSAkeyhoICogdyAqIGQpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoICE9PSAodyAqIGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSAke3RoaXMudmFsdWUubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCAke3d9ICogJHtofSA9ICR7KGggKiB3KX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoICE9PSB3KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSAke3RoaXMudmFsdWUubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCAke3d9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICB0b0FycmF5KCkge1xuICAgIGNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICBjb25zdCBbdywgaCwgZF0gPSB0aGlzLnNpemU7XG4gICAgaWYgKGQpIHtcbiAgICAgIHJldHVybiB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZDNERmxvYXQodGhpcy52YWx1ZS5zdWJhcnJheSA/IHRoaXMudmFsdWUgOiBuZXcgRmxvYXQzMkFycmF5KHRoaXMudmFsdWUpLCB3LCBoLCBkKTtcbiAgICB9IGVsc2UgaWYgKGgpIHtcbiAgICAgIHJldHVybiB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZDJERmxvYXQodGhpcy52YWx1ZS5zdWJhcnJheSA/IHRoaXMudmFsdWUgOiBuZXcgRmxvYXQzMkFycmF5KHRoaXMudmFsdWUpLCB3LCBoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlucHV0KHZhbHVlLCBzaXplKSB7XG4gIHJldHVybiBuZXcgSW5wdXQodmFsdWUsIHNpemUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSW5wdXQsXG4gIGlucHV0XG59O1xufSx7XCIuL3V0aWxzXCI6MTE0fV0sMTExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuZnVuY3Rpb24ga2VybmVsUnVuU2hvcnRjdXQoa2VybmVsKSB7XG4gIGxldCBydW4gPSBmdW5jdGlvbigpIHtcbiAgICBrZXJuZWwuYnVpbGQuYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICAgIHJ1biA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IHJlc3VsdCA9IGtlcm5lbC5ydW4uYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKGtlcm5lbC5zd2l0Y2hpbmdLZXJuZWxzKSB7XG4gICAgICAgIGNvbnN0IHJlYXNvbnMgPSBrZXJuZWwucmVzZXRTd2l0Y2hpbmdLZXJuZWxzKCk7XG4gICAgICAgIGNvbnN0IG5ld0tlcm5lbCA9IGtlcm5lbC5vblJlcXVlc3RTd2l0Y2hLZXJuZWwocmVhc29ucywgYXJndW1lbnRzLCBrZXJuZWwpO1xuICAgICAgICBzaG9ydGN1dC5rZXJuZWwgPSBrZXJuZWwgPSBuZXdLZXJuZWw7XG4gICAgICAgIHJlc3VsdCA9IG5ld0tlcm5lbC5ydW4uYXBwbHkobmV3S2VybmVsLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKGtlcm5lbC5yZW5kZXJLZXJuZWxzKSB7XG4gICAgICAgIHJldHVybiBrZXJuZWwucmVuZGVyS2VybmVscygpO1xuICAgICAgfSBlbHNlIGlmIChrZXJuZWwucmVuZGVyT3V0cHV0KSB7XG4gICAgICAgIHJldHVybiBrZXJuZWwucmVuZGVyT3V0cHV0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJ1bi5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gIH07XG4gIGNvbnN0IHNob3J0Y3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHJ1bi5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gIH07XG4gIHNob3J0Y3V0LmV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhY2NlcHQocnVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHNob3J0Y3V0LnJlcGxhY2VLZXJuZWwgPSBmdW5jdGlvbihyZXBsYWNlbWVudEtlcm5lbCkge1xuICAgIGtlcm5lbCA9IHJlcGxhY2VtZW50S2VybmVsO1xuICAgIGJpbmRLZXJuZWxUb1Nob3J0Y3V0KGtlcm5lbCwgc2hvcnRjdXQpO1xuICB9O1xuXG4gIGJpbmRLZXJuZWxUb1Nob3J0Y3V0KGtlcm5lbCwgc2hvcnRjdXQpO1xuICByZXR1cm4gc2hvcnRjdXQ7XG59XG5cbmZ1bmN0aW9uIGJpbmRLZXJuZWxUb1Nob3J0Y3V0KGtlcm5lbCwgc2hvcnRjdXQpIHtcbiAgaWYgKHNob3J0Y3V0Lmtlcm5lbCkge1xuICAgIHNob3J0Y3V0Lmtlcm5lbCA9IGtlcm5lbDtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvcGVydGllcyA9IHV0aWxzLmFsbFByb3BlcnRpZXNPZihrZXJuZWwpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgaWYgKHByb3BlcnR5WzBdID09PSAnXycgJiYgcHJvcGVydHlbMV0gPT09ICdfJykgY29udGludWU7XG4gICAgaWYgKHR5cGVvZiBrZXJuZWxbcHJvcGVydHldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAocHJvcGVydHkuc3Vic3RyaW5nKDAsIDMpID09PSAnYWRkJyB8fCBwcm9wZXJ0eS5zdWJzdHJpbmcoMCwgMykgPT09ICdzZXQnKSB7XG4gICAgICAgIHNob3J0Y3V0W3Byb3BlcnR5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNob3J0Y3V0Lmtlcm5lbFtwcm9wZXJ0eV0uYXBwbHkoc2hvcnRjdXQua2VybmVsLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiBzaG9ydGN1dDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3J0Y3V0W3Byb3BlcnR5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzaG9ydGN1dC5rZXJuZWxbcHJvcGVydHldLmFwcGx5KHNob3J0Y3V0Lmtlcm5lbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvcnRjdXQuX19kZWZpbmVHZXR0ZXJfXyhwcm9wZXJ0eSwgKCkgPT4gc2hvcnRjdXQua2VybmVsW3Byb3BlcnR5XSk7XG4gICAgICBzaG9ydGN1dC5fX2RlZmluZVNldHRlcl9fKHByb3BlcnR5LCAodmFsdWUpID0+IHtcbiAgICAgICAgc2hvcnRjdXQua2VybmVsW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHNob3J0Y3V0Lmtlcm5lbCA9IGtlcm5lbDtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrZXJuZWxSdW5TaG9ydGN1dFxufTtcbn0se1wiLi91dGlsc1wiOjExNH1dLDExMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBzb3VyY2UgPSBgLy8gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3LzR0MlNEaFxuLy9ub3RlOiB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQsIG5vcm1hbGl6ZWQgcmFuZCwgWzAsMV1cbmhpZ2hwIGZsb2F0IHJhbmRvbVNlZWRTaGlmdCA9IDEuMDtcbmhpZ2hwIGZsb2F0IHNsaWRlID0gMS4wO1xudW5pZm9ybSBoaWdocCBmbG9hdCByYW5kb21TZWVkMTtcbnVuaWZvcm0gaGlnaHAgZmxvYXQgcmFuZG9tU2VlZDI7XG5cbmhpZ2hwIGZsb2F0IG5yYW5kKGhpZ2hwIHZlYzIgbikge1xuICBoaWdocCBmbG9hdCByZXN1bHQgPSBmcmFjdChzaW4oZG90KChuLnh5ICsgMS4wKSAqIHZlYzIocmFuZG9tU2VlZDEgKiBzbGlkZSwgcmFuZG9tU2VlZDIgKiByYW5kb21TZWVkU2hpZnQpLCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMpO1xuICByYW5kb21TZWVkU2hpZnQgPSByZXN1bHQ7XG4gIGlmIChyYW5kb21TZWVkU2hpZnQgPiAwLjUpIHtcbiAgICBzbGlkZSArPSAwLjAwMDA5OyBcbiAgfSBlbHNlIHtcbiAgICBzbGlkZSArPSAwLjAwMDk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1gO1xuXG5jb25zdCBuYW1lID0gJ21hdGgtcmFuZG9tLXVuaWZvcm1seS1kaXN0cmlidXRlZCc7XG5cbmNvbnN0IGZ1bmN0aW9uTWF0Y2ggPSBgTWF0aC5yYW5kb20oKWA7XG5cbmNvbnN0IGZ1bmN0aW9uUmVwbGFjZSA9IGBucmFuZCh2VGV4Q29vcmQpYDtcblxuY29uc3QgZnVuY3Rpb25SZXR1cm5UeXBlID0gJ051bWJlcic7XG5jb25zdCBvbkJlZm9yZVJ1biA9IChrZXJuZWwpID0+IHtcbiAga2VybmVsLnNldFVuaWZvcm0xZigncmFuZG9tU2VlZDEnLCBNYXRoLnJhbmRvbSgpKTtcbiAga2VybmVsLnNldFVuaWZvcm0xZigncmFuZG9tU2VlZDInLCBNYXRoLnJhbmRvbSgpKTtcbn07XG5cbmNvbnN0IHBsdWdpbiA9IHtcbiAgbmFtZSxcbiAgb25CZWZvcmVSdW4sXG4gIGZ1bmN0aW9uTWF0Y2gsXG4gIGZ1bmN0aW9uUmVwbGFjZSxcbiAgZnVuY3Rpb25SZXR1cm5UeXBlLFxuICBzb3VyY2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGx1Z2luO1xufSx7fV0sMTEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNsYXNzIFRleHR1cmUge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRleHR1cmUsXG4gICAgICBzaXplLFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIG91dHB1dCxcbiAgICAgIGNvbnRleHQsXG4gICAgICB0eXBlID0gJ051bWJlclRleHR1cmUnLFxuICAgICAga2VybmVsLFxuICAgICAgaW50ZXJuYWxGb3JtYXQsXG4gICAgICB0ZXh0dXJlRm9ybWF0XG4gICAgfSA9IHNldHRpbmdzO1xuICAgIGlmICghb3V0cHV0KSB0aHJvdyBuZXcgRXJyb3IoJ3NldHRpbmdzIHByb3BlcnR5IFwib3V0cHV0XCIgcmVxdWlyZWQuJyk7XG4gICAgaWYgKCFjb250ZXh0KSB0aHJvdyBuZXcgRXJyb3IoJ3NldHRpbmdzIHByb3BlcnR5IFwiY29udGV4dFwiIHJlcXVpcmVkLicpO1xuICAgIGlmICghdGV4dHVyZSkgdGhyb3cgbmV3IEVycm9yKCdzZXR0aW5ncyBwcm9wZXJ0eSBcInRleHR1cmVcIiByZXF1aXJlZC4nKTtcbiAgICBpZiAoIWtlcm5lbCkgdGhyb3cgbmV3IEVycm9yKCdzZXR0aW5ncyBwcm9wZXJ0eSBcImtlcm5lbFwiIHJlcXVpcmVkLicpO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgaWYgKHRleHR1cmUuX3JlZnMpIHtcbiAgICAgIHRleHR1cmUuX3JlZnMrKztcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dHVyZS5fcmVmcyA9IDE7XG4gICAgfVxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMua2VybmVsID0ga2VybmVsO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fZGVsZXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBpbnRlcm5hbEZvcm1hdDtcbiAgICB0aGlzLnRleHR1cmVGb3JtYXQgPSB0ZXh0dXJlRm9ybWF0O1xuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBpbXBsZW1lbnRlZCBvbiAke3RoaXMuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm90IGltcGxlbWVudGVkIG9uICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICB9XG5cbiAgZGVsZXRlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm90IGltcGxlbWVudGVkIG9uICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgaW1wbGVtZW50ZWQgb24gJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRleHR1cmVcbn07XG59LHt9XSwxMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgYWNvcm4gPSByZXF1aXJlKCdhY29ybicpO1xuY29uc3QgeyBJbnB1dCB9ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xuY29uc3QgeyBUZXh0dXJlIH0gPSByZXF1aXJlKCcuL3RleHR1cmUnKTtcblxuY29uc3QgRlVOQ1RJT05fTkFNRSA9IC9mdW5jdGlvbiAoW14oXSopLztcbmNvbnN0IFNUUklQX0NPTU1FTlRTID0gLygoXFwvXFwvLiokKXwoXFwvXFwqW1xcc1xcU10qP1xcKlxcLykpL21nO1xuY29uc3QgQVJHVU1FTlRfTkFNRVMgPSAvKFteXFxzLF0rKS9nO1xuXG5jb25zdCB1dGlscyA9IHtcbiAgc3lzdGVtRW5kaWFubmVzcygpIHtcbiAgICByZXR1cm4gX3N5c3RlbUVuZGlhbm5lc3M7XG4gIH0sXG4gIGdldFN5c3RlbUVuZGlhbm5lc3MoKSB7XG4gICAgY29uc3QgYiA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgICBjb25zdCBhID0gbmV3IFVpbnQzMkFycmF5KGIpO1xuICAgIGNvbnN0IGMgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICBhWzBdID0gMHhkZWFkYmVlZjtcbiAgICBpZiAoY1swXSA9PT0gMHhlZikgcmV0dXJuICdMRSc7XG4gICAgaWYgKGNbMF0gPT09IDB4ZGUpIHJldHVybiAnQkUnO1xuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBlbmRpYW5uZXNzJyk7XG4gIH0sXG5cbiAgaXNGdW5jdGlvbihmdW5jT2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZihmdW5jT2JqKSA9PT0gJ2Z1bmN0aW9uJztcbiAgfSxcblxuICBpc0Z1bmN0aW9uU3RyaW5nKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAoZm5cbiAgICAgICAgLnNsaWNlKDAsICdmdW5jdGlvbicubGVuZ3RoKVxuICAgICAgICAudG9Mb3dlckNhc2UoKSA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBnZXRGdW5jdGlvbk5hbWVGcm9tU3RyaW5nKGZ1bmNTdHIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBGVU5DVElPTl9OQU1FLmV4ZWMoZnVuY1N0cik7XG4gICAgaWYgKCFyZXN1bHQgfHwgcmVzdWx0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdFsxXS50cmltKCk7XG4gIH0sXG5cbiAgZ2V0RnVuY3Rpb25Cb2R5RnJvbVN0cmluZyhmdW5jU3RyKSB7XG4gICAgcmV0dXJuIGZ1bmNTdHIuc3Vic3RyaW5nKGZ1bmNTdHIuaW5kZXhPZigneycpICsgMSwgZnVuY1N0ci5sYXN0SW5kZXhPZignfScpKTtcbiAgfSxcblxuICBnZXRBcmd1bWVudE5hbWVzRnJvbVN0cmluZyhmbikge1xuICAgIGNvbnN0IGZuU3RyID0gZm4ucmVwbGFjZShTVFJJUF9DT01NRU5UUywgJycpO1xuICAgIGxldCByZXN1bHQgPSBmblN0ci5zbGljZShmblN0ci5pbmRleE9mKCcoJykgKyAxLCBmblN0ci5pbmRleE9mKCcpJykpLm1hdGNoKEFSR1VNRU5UX05BTUVTKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBjbG9uZShvYmopIHtcbiAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iai5oYXNPd25Qcm9wZXJ0eSgnaXNBY3RpdmVDbG9uZScpKSByZXR1cm4gb2JqO1xuXG4gICAgY29uc3QgdGVtcCA9IG9iai5jb25zdHJ1Y3RvcigpOyBcblxuICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIG9iai5pc0FjdGl2ZUNsb25lID0gbnVsbDtcbiAgICAgICAgdGVtcFtrZXldID0gdXRpbHMuY2xvbmUob2JqW2tleV0pO1xuICAgICAgICBkZWxldGUgb2JqLmlzQWN0aXZlQ2xvbmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXA7XG4gIH0sXG5cbiAgaXNBcnJheShhcnJheSkge1xuICAgIHJldHVybiAhaXNOYU4oYXJyYXkubGVuZ3RoKTtcbiAgfSxcblxuICBnZXRWYXJpYWJsZVR5cGUodmFsdWUsIHN0cmljdEludGVnZXJzKSB7XG4gICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCAmJiB2YWx1ZVswXS5ub2RlTmFtZSA9PT0gJ0lNRycpIHtcbiAgICAgICAgcmV0dXJuICdIVE1MSW1hZ2VBcnJheSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ0FycmF5JztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgIHJldHVybiAnQm9vbGVhbic7XG4gICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgaWYgKHN0cmljdEludGVnZXJzICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0Zsb2F0JztcbiAgICAgIGNhc2UgVGV4dHVyZTpcbiAgICAgICAgcmV0dXJuIHZhbHVlLnR5cGU7XG4gICAgICBjYXNlIElucHV0OlxuICAgICAgICByZXR1cm4gJ0lucHV0JztcbiAgICB9XG4gICAgaWYgKCdub2RlTmFtZScgIGluIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHZhbHVlLm5vZGVOYW1lKSB7XG4gICAgICAgIGNhc2UgJ0lNRyc6XG4gICAgICAgICAgcmV0dXJuICdIVE1MSW1hZ2UnO1xuICAgICAgICBjYXNlICdDQU5WQVMnOlxuICAgICAgICAgIHJldHVybiAnSFRNTEltYWdlJztcbiAgICAgICAgY2FzZSAnVklERU8nOlxuICAgICAgICAgIHJldHVybiAnSFRNTFZpZGVvJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCd0eXBlJykpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50eXBlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIHJldHVybiAnT2Zmc2NyZWVuQ2FudmFzJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkge1xuICAgICAgcmV0dXJuICdJbWFnZUJpdG1hcCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgSW1hZ2VEYXRhICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xuICAgICAgcmV0dXJuICdJbWFnZURhdGEnO1xuICAgIH1cbiAgICByZXR1cm4gJ1Vua25vd24nO1xuICB9LFxuXG4gIGdldEtlcm5lbFRleHR1cmVTaXplKHNldHRpbmdzLCBkaW1lbnNpb25zKSB7XG4gICAgbGV0IFt3LCBoLCBkXSA9IGRpbWVuc2lvbnM7XG4gICAgbGV0IHRleGVsQ291bnQgPSAodyB8fCAxKSAqIChoIHx8IDEpICogKGQgfHwgMSk7XG5cbiAgICBpZiAoc2V0dGluZ3Mub3B0aW1pemVGbG9hdE1lbW9yeSAmJiBzZXR0aW5ncy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICB3ID0gdGV4ZWxDb3VudCA9IE1hdGguY2VpbCh0ZXhlbENvdW50IC8gNCk7XG4gICAgfVxuICAgIGlmIChoID4gMSAmJiB3ICogaCA9PT0gdGV4ZWxDb3VudCkge1xuICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KFt3LCBoXSk7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5jbG9zZXN0U3F1YXJlRGltZW5zaW9ucyh0ZXhlbENvdW50KTtcbiAgfSxcblxuICBjbG9zZXN0U3F1YXJlRGltZW5zaW9ucyhsZW5ndGgpIHtcbiAgICBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0KGxlbmd0aCk7XG4gICAgbGV0IGhpZ2ggPSBNYXRoLmNlaWwoc3FydCk7XG4gICAgbGV0IGxvdyA9IE1hdGguZmxvb3Ioc3FydCk7XG4gICAgd2hpbGUgKGhpZ2ggKiBsb3cgPCBsZW5ndGgpIHtcbiAgICAgIGhpZ2gtLTtcbiAgICAgIGxvdyA9IE1hdGguY2VpbChsZW5ndGggLyBoaWdoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KFtsb3csIE1hdGguY2VpbChsZW5ndGggLyBsb3cpXSk7XG4gIH0sXG5cbiAgZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZShkaW1lbnNpb25zLCBiaXRSYXRpbykge1xuICAgIGNvbnN0IHRvdGFsQXJlYSA9IHV0aWxzLnJvdW5kVG8oKGRpbWVuc2lvbnNbMF0gfHwgMSkgKiAoZGltZW5zaW9uc1sxXSB8fCAxKSAqIChkaW1lbnNpb25zWzJdIHx8IDEpICogKGRpbWVuc2lvbnNbM10gfHwgMSksIDQpO1xuICAgIGNvbnN0IHRleGVsQ291bnQgPSB0b3RhbEFyZWEgLyBiaXRSYXRpbztcbiAgICByZXR1cm4gdXRpbHMuY2xvc2VzdFNxdWFyZURpbWVuc2lvbnModGV4ZWxDb3VudCk7XG4gIH0sXG5cbiAgZ2V0TWVtb3J5T3B0aW1pemVkUGFja2VkVGV4dHVyZVNpemUoZGltZW5zaW9ucywgYml0UmF0aW8pIHtcbiAgICBjb25zdCBbdywgaCwgZF0gPSBkaW1lbnNpb25zO1xuICAgIGNvbnN0IHRvdGFsQXJlYSA9IHV0aWxzLnJvdW5kVG8oKHcgfHwgMSkgKiAoaCB8fCAxKSAqIChkIHx8IDEpLCA0KTtcbiAgICBjb25zdCB0ZXhlbENvdW50ID0gdG90YWxBcmVhIC8gKDQgLyBiaXRSYXRpbyk7XG4gICAgcmV0dXJuIHV0aWxzLmNsb3Nlc3RTcXVhcmVEaW1lbnNpb25zKHRleGVsQ291bnQpO1xuICB9LFxuXG4gIHJvdW5kVG8obiwgZCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKChuICsgZCAtIDEpIC8gZCkgKiBkO1xuICB9LFxuICBnZXREaW1lbnNpb25zKHgsIHBhZCkge1xuICAgIGxldCByZXQ7XG4gICAgaWYgKHV0aWxzLmlzQXJyYXkoeCkpIHtcbiAgICAgIGNvbnN0IGRpbSA9IFtdO1xuICAgICAgbGV0IHRlbXAgPSB4O1xuICAgICAgd2hpbGUgKHV0aWxzLmlzQXJyYXkodGVtcCkpIHtcbiAgICAgICAgZGltLnB1c2godGVtcC5sZW5ndGgpO1xuICAgICAgICB0ZW1wID0gdGVtcFswXTtcbiAgICAgIH1cbiAgICAgIHJldCA9IGRpbS5yZXZlcnNlKCk7XG4gICAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgcmV0ID0geC5vdXRwdXQ7XG4gICAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgSW5wdXQpIHtcbiAgICAgIHJldCA9IHguc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRpbWVuc2lvbnMgb2YgJHt4fWApO1xuICAgIH1cblxuICAgIGlmIChwYWQpIHtcbiAgICAgIHJldCA9IEFycmF5LmZyb20ocmV0KTtcbiAgICAgIHdoaWxlIChyZXQubGVuZ3RoIDwgMykge1xuICAgICAgICByZXQucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEludDMyQXJyYXkocmV0KTtcbiAgfSxcblxuICBmbGF0dGVuMmRBcnJheVRvKGFycmF5LCB0YXJnZXQpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGFycmF5Lmxlbmd0aDsgeSsrKSB7XG4gICAgICB0YXJnZXQuc2V0KGFycmF5W3ldLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGFycmF5W3ldLmxlbmd0aDtcbiAgICB9XG4gIH0sXG5cbiAgZmxhdHRlbjNkQXJyYXlUbyhhcnJheSwgdGFyZ2V0KSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBhcnJheS5sZW5ndGg7IHorKykge1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhcnJheVt6XS5sZW5ndGg7IHkrKykge1xuICAgICAgICB0YXJnZXQuc2V0KGFycmF5W3pdW3ldLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYXJyYXlbel1beV0ubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBmbGF0dGVuNGRBcnJheVRvKGFycmF5LCB0YXJnZXQpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IGFycmF5Lmxlbmd0aDsgbCsrKSB7XG4gICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IGFycmF5W2xdLmxlbmd0aDsgeisrKSB7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgYXJyYXlbbF1bel0ubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICB0YXJnZXQuc2V0KGFycmF5W2xdW3pdW3ldLCBvZmZzZXQpO1xuICAgICAgICAgIG9mZnNldCArPSBhcnJheVtsXVt6XVt5XS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZmxhdHRlblRvKGFycmF5LCB0YXJnZXQpIHtcbiAgICBpZiAodXRpbHMuaXNBcnJheShhcnJheVswXSkpIHtcbiAgICAgIGlmICh1dGlscy5pc0FycmF5KGFycmF5WzBdWzBdKSkge1xuICAgICAgICBpZiAodXRpbHMuaXNBcnJheShhcnJheVswXVswXVswXSkpIHtcbiAgICAgICAgICB1dGlscy5mbGF0dGVuNGRBcnJheVRvKGFycmF5LCB0YXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWxzLmZsYXR0ZW4zZEFycmF5VG8oYXJyYXksIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWxzLmZsYXR0ZW4yZEFycmF5VG8oYXJyYXksIHRhcmdldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5zZXQoYXJyYXkpO1xuICAgIH1cbiAgfSxcblxuICBzcGxpdEFycmF5KGFycmF5LCBwYXJ0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gcGFydCkge1xuICAgICAgcmVzdWx0LnB1c2gobmV3IGFycmF5LmNvbnN0cnVjdG9yKGFycmF5LmJ1ZmZlciwgaSAqIDQgKyBhcnJheS5ieXRlT2Zmc2V0LCBwYXJ0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgZ2V0QXN0U3RyaW5nKHNvdXJjZSwgYXN0KSB7XG4gICAgY29uc3QgbGluZXMgPSBBcnJheS5pc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vZyk7XG4gICAgY29uc3Qgc3RhcnQgPSBhc3QubG9jLnN0YXJ0O1xuICAgIGNvbnN0IGVuZCA9IGFzdC5sb2MuZW5kO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmIChzdGFydC5saW5lID09PSBlbmQubGluZSkge1xuICAgICAgcmVzdWx0LnB1c2gobGluZXNbc3RhcnQubGluZSAtIDFdLnN1YnN0cmluZyhzdGFydC5jb2x1bW4sIGVuZC5jb2x1bW4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gobGluZXNbc3RhcnQubGluZSAtIDFdLnNsaWNlKHN0YXJ0LmNvbHVtbikpO1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0LmxpbmU7IGkgPCBlbmQubGluZTsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmVzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGxpbmVzW2VuZC5saW5lIC0gMV0uc2xpY2UoMCwgZW5kLmNvbHVtbikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJ1xcbicpO1xuICB9LFxuXG4gIGFsbFByb3BlcnRpZXNPZihvYmopIHtcbiAgICBjb25zdCBwcm9wcyA9IFtdO1xuXG4gICAgZG8ge1xuICAgICAgcHJvcHMucHVzaC5hcHBseShwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKSk7XG4gICAgfSB3aGlsZSAob2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpO1xuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9LFxuXG4gIGxpbmVzVG9TdHJpbmcobGluZXMpIHtcbiAgICBpZiAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJztcXG4nKSArICc7XFxuJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdcXG4nO1xuICAgIH1cbiAgfSxcbiAgd2FybkRlcHJlY2F0ZWQodHlwZSwgb2xkTmFtZSwgbmV3TmFtZSkge1xuICAgIGlmIChuZXdOYW1lKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFlvdSBhcmUgdXNpbmcgYSBkZXByZWNhdGVkICR7IHR5cGUgfSBcIiR7IG9sZE5hbWUgfVwiLiBJdCBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIFwiJHsgbmV3TmFtZSB9XCIuIEZpeGluZywgYnV0IHBsZWFzZSB1cGdyYWRlIGFzIGl0IHdpbGwgc29vbiBiZSByZW1vdmVkLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oYFlvdSBhcmUgdXNpbmcgYSBkZXByZWNhdGVkICR7IHR5cGUgfSBcIiR7IG9sZE5hbWUgfVwiLiBJdCBoYXMgYmVlbiByZW1vdmVkLiBGaXhpbmcsIGJ1dCBwbGVhc2UgdXBncmFkZSBhcyBpdCB3aWxsIHNvb24gYmUgcmVtb3ZlZC5gKTtcbiAgICB9XG4gIH0sXG4gIGZsaXBQaXhlbHM6IChwaXhlbHMsIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMiB8IDA7IFxuICAgIGNvbnN0IGJ5dGVzUGVyUm93ID0gd2lkdGggKiA0O1xuICAgIGNvbnN0IHRlbXAgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiA0KTtcbiAgICBjb25zdCByZXN1bHQgPSBwaXhlbHMuc2xpY2UoMCk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoYWxmSGVpZ2h0OyArK3kpIHtcbiAgICAgIGNvbnN0IHRvcE9mZnNldCA9IHkgKiBieXRlc1BlclJvdztcbiAgICAgIGNvbnN0IGJvdHRvbU9mZnNldCA9IChoZWlnaHQgLSB5IC0gMSkgKiBieXRlc1BlclJvdztcblxuICAgICAgdGVtcC5zZXQocmVzdWx0LnN1YmFycmF5KHRvcE9mZnNldCwgdG9wT2Zmc2V0ICsgYnl0ZXNQZXJSb3cpKTtcblxuICAgICAgcmVzdWx0LmNvcHlXaXRoaW4odG9wT2Zmc2V0LCBib3R0b21PZmZzZXQsIGJvdHRvbU9mZnNldCArIGJ5dGVzUGVyUm93KTtcblxuICAgICAgcmVzdWx0LnNldCh0ZW1wLCBib3R0b21PZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBlcmVjdFBhY2tlZEZsb2F0OiAoYXJyYXksIHdpZHRoKSA9PiB7XG4gICAgcmV0dXJuIGFycmF5LnN1YmFycmF5KDAsIHdpZHRoKTtcbiAgfSxcbiAgZXJlY3QyRFBhY2tlZEZsb2F0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhTdGFydCA9IHkgKiB3aWR0aDtcbiAgICAgIGNvbnN0IHhFbmQgPSB4U3RhcnQgKyB3aWR0aDtcbiAgICAgIHlSZXN1bHRzW3ldID0gYXJyYXkuc3ViYXJyYXkoeFN0YXJ0LCB4RW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNEUGFja2VkRmxvYXQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCB4U3RhcnQgPSAoeiAqIGhlaWdodCAqIHdpZHRoKSArIHkgKiB3aWR0aDtcbiAgICAgICAgY29uc3QgeEVuZCA9IHhTdGFydCArIHdpZHRoO1xuICAgICAgICB5UmVzdWx0c1t5XSA9IGFycmF5LnN1YmFycmF5KHhTdGFydCwgeEVuZCk7XG4gICAgICB9XG4gICAgICB6UmVzdWx0c1t6XSA9IHlSZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4gelJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0TWVtb3J5T3B0aW1pemVkRmxvYXQ6IChhcnJheSwgd2lkdGgpID0+IHtcbiAgICByZXR1cm4gYXJyYXkuc3ViYXJyYXkoMCwgd2lkdGgpO1xuICB9LFxuICBlcmVjdE1lbW9yeU9wdGltaXplZDJERmxvYXQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHdpZHRoO1xuICAgICAgeVJlc3VsdHNbeV0gPSBhcnJheS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHdpZHRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdE1lbW9yeU9wdGltaXplZDNERmxvYXQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoeiAqIGhlaWdodCAqIHdpZHRoKSArICh5ICogd2lkdGgpO1xuICAgICAgICB5UmVzdWx0c1t5XSA9IGFycmF5LnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgd2lkdGgpO1xuICAgICAgfVxuICAgICAgelJlc3VsdHNbel0gPSB5UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHpSZXN1bHRzO1xuICB9LFxuICBlcmVjdEZsb2F0OiAoYXJyYXksIHdpZHRoKSA9PiB7XG4gICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICB4UmVzdWx0c1t4XSA9IGFycmF5W2ldO1xuICAgICAgaSArPSA0O1xuICAgIH1cbiAgICByZXR1cm4geFJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0MkRGbG9hdDogKGFycmF5LCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoKTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICB4UmVzdWx0c1t4XSA9IGFycmF5W2ldO1xuICAgICAgICBpICs9IDQ7XG4gICAgICB9XG4gICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4geVJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0M0RGbG9hdDogKGFycmF5LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCkgPT4ge1xuICAgIGNvbnN0IHpSZXN1bHRzID0gbmV3IEFycmF5KGRlcHRoKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBGbG9hdDMyQXJyYXkod2lkdGgpO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICB4UmVzdWx0c1t4XSA9IGFycmF5W2ldO1xuICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgICAgfVxuICAgICAgelJlc3VsdHNbel0gPSB5UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHpSZXN1bHRzO1xuICB9LFxuICBlcmVjdEFycmF5MjogKGFycmF5LCB3aWR0aCkgPT4ge1xuICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCwgeCArIDIpO1xuICAgIH1cbiAgICByZXR1cm4geFJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0MkRBcnJheTI6IChhcnJheSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgY29uc3QgWFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIFhSZXN1bHRzTWF4O1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBYUmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgMik7XG4gICAgICB9XG4gICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4geVJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0M0RBcnJheTI6IChhcnJheSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9ICh6ICogeFJlc3VsdHNNYXggKiBoZWlnaHQpICsgKHkgKiB4UmVzdWx0c01heCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHggKyBvZmZzZXQsIHggKyBvZmZzZXQgKyAyKTtcbiAgICAgICAgfVxuICAgICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgICAgfVxuICAgICAgelJlc3VsdHNbel0gPSB5UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHpSZXN1bHRzO1xuICB9LFxuICBlcmVjdEFycmF5MzogKGFycmF5LCB3aWR0aCkgPT4ge1xuICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCwgeCArIDMpO1xuICAgIH1cbiAgICByZXR1cm4geFJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0MkRBcnJheTM6IChhcnJheSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHhSZXN1bHRzTWF4ID0gd2lkdGggKiA0O1xuICAgIGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHhSZXN1bHRzTWF4O1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgMyk7XG4gICAgICB9XG4gICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4geVJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0M0RBcnJheTM6IChhcnJheSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9ICh6ICogeFJlc3VsdHNNYXggKiBoZWlnaHQpICsgKHkgKiB4UmVzdWx0c01heCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHggKyBvZmZzZXQsIHggKyBvZmZzZXQgKyAzKTtcbiAgICAgICAgfVxuICAgICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgICAgfVxuICAgICAgelJlc3VsdHNbel0gPSB5UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHpSZXN1bHRzO1xuICB9LFxuICBlcmVjdEFycmF5NDogKGFycmF5LCB3aWR0aCkgPT4ge1xuICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KGFycmF5KTtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCwgeCArIDQpO1xuICAgIH1cbiAgICByZXR1cm4geFJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0MkRBcnJheTQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHhSZXN1bHRzTWF4ID0gd2lkdGggKiA0O1xuICAgIGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0geSAqIHhSZXN1bHRzTWF4O1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgNCk7XG4gICAgICB9XG4gICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4geVJlc3VsdHM7XG4gIH0sXG4gIGVyZWN0M0RBcnJheTQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgZm9yIChsZXQgeiA9IDA7IHogPCBkZXB0aDsgeisrKSB7XG4gICAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9ICh6ICogeFJlc3VsdHNNYXggKiBoZWlnaHQpICsgKHkgKiB4UmVzdWx0c01heCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB4UmVzdWx0c01heDsgeCArPSA0KSB7XG4gICAgICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHggKyBvZmZzZXQsIHggKyBvZmZzZXQgKyA0KTtcbiAgICAgICAgfVxuICAgICAgICB5UmVzdWx0c1t5XSA9IHhSZXN1bHRzO1xuICAgICAgfVxuICAgICAgelJlc3VsdHNbel0gPSB5UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHpSZXN1bHRzO1xuICB9LFxuXG4gIGZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nOiAoc291cmNlLCBzZXR0aW5ncykgPT4ge1xuICAgIGNvbnN0IHsgZmluZERlcGVuZGVuY3ksIHRoaXNMb29rdXAsIGRvTm90RGVmaW5lIH0gPSBzZXR0aW5ncztcbiAgICBsZXQgZmxhdHRlbmVkID0gc2V0dGluZ3MuZmxhdHRlbmVkO1xuICAgIGlmICghZmxhdHRlbmVkKSB7XG4gICAgICBmbGF0dGVuZWQgPSBzZXR0aW5ncy5mbGF0dGVuZWQgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgYXN0ID0gYWNvcm4ucGFyc2Uoc291cmNlKTtcbiAgICBjb25zdCBmdW5jdGlvbkRlcGVuZGVuY2llcyA9IFtdO1xuICAgIGxldCBpbmRlbnQgPSAwO1xuXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhc3QpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChmbGF0dGVuKGFzdFtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzLmpvaW4oJycpO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChhc3QudHlwZSkge1xuICAgICAgICBjYXNlICdQcm9ncmFtJzpcbiAgICAgICAgICByZXR1cm4gZmxhdHRlbihhc3QuYm9keSkgKyAoYXN0LmJvZHlbMF0udHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRpb24nID8gJzsnIDogJycpO1xuICAgICAgICBjYXNlICdGdW5jdGlvbkRlY2xhcmF0aW9uJzpcbiAgICAgICAgICByZXR1cm4gYGZ1bmN0aW9uICR7YXN0LmlkLm5hbWV9KCR7YXN0LnBhcmFtcy5tYXAoZmxhdHRlbikuam9pbignLCAnKX0pICR7IGZsYXR0ZW4oYXN0LmJvZHkpIH1gO1xuICAgICAgICBjYXNlICdCbG9ja1N0YXRlbWVudCc6IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICBpbmRlbnQgKz0gMjtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmbGF0ID0gZmxhdHRlbihhc3QuYm9keVtpXSk7XG4gICAgICAgICAgICBpZiAoZmxhdCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCgnICcucmVwZWF0KGluZGVudCkgKyBmbGF0LCAnO1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRlbnQgLT0gMjtcbiAgICAgICAgICByZXR1cm4gYHtcXG4ke3Jlc3VsdC5qb2luKCcnKX19YDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSB1dGlscy5ub3JtYWxpemVEZWNsYXJhdGlvbnMoYXN0KVxuICAgICAgICAgICAgLm1hcChmbGF0dGVuKVxuICAgICAgICAgICAgLmZpbHRlcihyID0+IHIgIT09IG51bGwpO1xuICAgICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YXN0LmtpbmR9ICR7ZGVjbGFyYXRpb25zLmpvaW4oJywnKX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0b3InOlxuICAgICAgICAgICAgaWYgKGFzdC5pbml0Lm9iamVjdCAmJiBhc3QuaW5pdC5vYmplY3QudHlwZSA9PT0gJ1RoaXNFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICBjb25zdCBsb29rdXAgPSB0aGlzTG9va3VwKGFzdC5pbml0LnByb3BlcnR5Lm5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5pZC5uYW1lfSA9ICR7ZmxhdHRlbihhc3QuaW5pdCl9YDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5pZC5uYW1lfSA9ICR7ZmxhdHRlbihhc3QuaW5pdCl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzoge1xuICAgICAgICAgICAgICBpZiAoYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lID09PSAnc3ViYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2ZsYXR0ZW4oYXN0LmNhbGxlZS5vYmplY3QpfS4ke2ZsYXR0ZW4oYXN0LmNhbGxlZS5wcm9wZXJ0eSl9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGFzdC5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdnbCcgfHwgYXN0LmNhbGxlZS5vYmplY3QubmFtZSA9PT0gJ2NvbnRleHQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2ZsYXR0ZW4oYXN0LmNhbGxlZS5vYmplY3QpfS4ke2ZsYXR0ZW4oYXN0LmNhbGxlZS5wcm9wZXJ0eSl9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGFzdC5jYWxsZWUub2JqZWN0LnR5cGUgPT09ICdUaGlzRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkRlcGVuZGVuY2llcy5wdXNoKGZpbmREZXBlbmRlbmN5KCd0aGlzJywgYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5jYWxsZWUucHJvcGVydHkubmFtZX0oJHthc3QuYXJndW1lbnRzLm1hcCh2YWx1ZSA9PiBmbGF0dGVuKHZhbHVlKSkuam9pbignLCAnKX0pYDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhc3QuY2FsbGVlLm9iamVjdC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRTb3VyY2UgPSBmaW5kRGVwZW5kZW5jeShhc3QuY2FsbGVlLm9iamVjdC5uYW1lLCBhc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZFNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5jYWxsZWUub2JqZWN0Lm5hbWV9LiR7YXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlcGVuZGVuY2llcy5wdXNoKGZvdW5kU291cmNlKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHthc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWV9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFzdC5jYWxsZWUub2JqZWN0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5jYWxsZWUub2JqZWN0KX0uJHthc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWV9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGFzdC5jYWxsZWUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnUmV0dXJuU3RhdGVtZW50JzpcbiAgICAgICAgICAgICAgcmV0dXJuIGByZXR1cm4gJHtmbGF0dGVuKGFzdC5hcmd1bWVudCl9YDtcbiAgICAgICAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICByZXR1cm4gYCgke2ZsYXR0ZW4oYXN0LmxlZnQpfSR7YXN0Lm9wZXJhdG9yfSR7ZmxhdHRlbihhc3QucmlnaHQpfSlgO1xuICAgICAgICAgICAgY2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgaWYgKGFzdC5wcmVmaXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7YXN0Lm9wZXJhdG9yfSAke2ZsYXR0ZW4oYXN0LmFyZ3VtZW50KX1gO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5hcmd1bWVudCl9ICR7YXN0Lm9wZXJhdG9yfWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnRXhwcmVzc2lvblN0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2ZsYXR0ZW4oYXN0LmV4cHJlc3Npb24pfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAoJHtmbGF0dGVuKGFzdC5leHByZXNzaW9ucyl9KWA7XG4gICAgICAgICAgICAgIGNhc2UgJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCgke2FzdC5wYXJhbXMubWFwKGZsYXR0ZW4pLmpvaW4oJywgJyl9KSA9PiAke2ZsYXR0ZW4oYXN0LmJvZHkpfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ0xpdGVyYWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhc3QucmF3O1xuICAgICAgICAgICAgICBjYXNlICdJZGVudGlmaWVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0Lm5hbWU7XG4gICAgICAgICAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIGlmIChhc3Qub2JqZWN0LnR5cGUgPT09ICdUaGlzRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzTG9va3VwKGFzdC5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFzdC5jb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2ZsYXR0ZW4oYXN0Lm9iamVjdCl9WyR7ZmxhdHRlbihhc3QucHJvcGVydHkpfV1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbihhc3Qub2JqZWN0KSArICcuJyArIGZsYXR0ZW4oYXN0LnByb3BlcnR5KTtcbiAgICAgICAgICAgICAgY2FzZSAnVGhpc0V4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiAndGhpcyc7XG4gICAgICAgICAgICAgIGNhc2UgJ05ld0V4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBgbmV3ICR7ZmxhdHRlbihhc3QuY2FsbGVlKX0oJHthc3QuYXJndW1lbnRzLm1hcCh2YWx1ZSA9PiBmbGF0dGVuKHZhbHVlKSkuam9pbignLCAnKX0pYDtcbiAgICAgICAgICAgICAgY2FzZSAnRm9yU3RhdGVtZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYGZvciAoJHtmbGF0dGVuKGFzdC5pbml0KX07JHtmbGF0dGVuKGFzdC50ZXN0KX07JHtmbGF0dGVuKGFzdC51cGRhdGUpfSkgJHtmbGF0dGVuKGFzdC5ib2R5KX1gO1xuICAgICAgICAgICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2ZsYXR0ZW4oYXN0LmxlZnQpfSR7YXN0Lm9wZXJhdG9yfSR7ZmxhdHRlbihhc3QucmlnaHQpfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5hcmd1bWVudCl9JHthc3Qub3BlcmF0b3J9YDtcbiAgICAgICAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBgaWYgKCR7ZmxhdHRlbihhc3QudGVzdCl9KSAke2ZsYXR0ZW4oYXN0LmNvbnNlcXVlbnQpfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ1Rocm93U3RhdGVtZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYHRocm93ICR7ZmxhdHRlbihhc3QuYXJndW1lbnQpfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ09iamVjdFBhdHRlcm4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBhc3QucHJvcGVydGllcy5tYXAoZmxhdHRlbikuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgY2FzZSAnQXJyYXlQYXR0ZXJuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0LmVsZW1lbnRzLm1hcChmbGF0dGVuKS5qb2luKCcsICcpO1xuICAgICAgICAgICAgICBjYXNlICdEZWJ1Z2dlclN0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkZWJ1Z2dlcjsnO1xuICAgICAgICAgICAgICBjYXNlICdDb25kaXRpb25hbEV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC50ZXN0KX0/JHtmbGF0dGVuKGFzdC5jb25zZXF1ZW50KX06JHtmbGF0dGVuKGFzdC5hbHRlcm5hdGUpfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ1Byb3BlcnR5JzpcbiAgICAgICAgICAgICAgICBpZiAoYXN0LmtpbmQgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW4oYXN0LmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgYXN0LnR5cGUgb2YgJHsgYXN0LnR5cGUgfWApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBmbGF0dGVuKGFzdCk7XG4gICAgaWYgKGZ1bmN0aW9uRGVwZW5kZW5jaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZsYXR0ZW5lZEZ1bmN0aW9uRGVwZW5kZW5jaWVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9uRGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uRGVwZW5kZW5jeSA9IGZ1bmN0aW9uRGVwZW5kZW5jaWVzW2ldO1xuICAgICAgICBpZiAoIWZsYXR0ZW5lZFtmdW5jdGlvbkRlcGVuZGVuY3ldKSB7XG4gICAgICAgICAgZmxhdHRlbmVkW2Z1bmN0aW9uRGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uRGVwZW5kZW5jeSA/IGZsYXR0ZW5lZEZ1bmN0aW9uRGVwZW5kZW5jaWVzLnB1c2godXRpbHMuZmxhdHRlbkZ1bmN0aW9uVG9TdHJpbmcoZnVuY3Rpb25EZXBlbmRlbmN5LCBzZXR0aW5ncykgKyAnXFxuJykgOiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbGF0dGVuZWRGdW5jdGlvbkRlcGVuZGVuY2llcy5qb2luKCcnKSArIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBub3JtYWxpemVEZWNsYXJhdGlvbnM6IChhc3QpID0+IHtcbiAgICBpZiAoYXN0LnR5cGUgIT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdBc3QgaXMgbm90IG9mIHR5cGUgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCInKTtcbiAgICBjb25zdCBub3JtYWxpemVkRGVjbGFyYXRpb25zID0gW107XG4gICAgZm9yIChsZXQgZGVjbGFyYXRpb25JbmRleCA9IDA7IGRlY2xhcmF0aW9uSW5kZXggPCBhc3QuZGVjbGFyYXRpb25zLmxlbmd0aDsgZGVjbGFyYXRpb25JbmRleCsrKSB7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IGFzdC5kZWNsYXJhdGlvbnNbZGVjbGFyYXRpb25JbmRleF07XG4gICAgICBpZiAoZGVjbGFyYXRpb24uaWQgJiYgZGVjbGFyYXRpb24uaWQudHlwZSA9PT0gJ09iamVjdFBhdHRlcm4nICYmIGRlY2xhcmF0aW9uLmlkLnByb3BlcnRpZXMpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBkZWNsYXJhdGlvbi5pZDtcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHlJbmRleCA9IDA7IHByb3BlcnR5SW5kZXggPCBwcm9wZXJ0aWVzLmxlbmd0aDsgcHJvcGVydHlJbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW3Byb3BlcnR5SW5kZXhdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0eS52YWx1ZS50eXBlID09PSAnT2JqZWN0UGF0dGVybicgJiYgcHJvcGVydHkudmFsdWUucHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yIChsZXQgc3ViUHJvcGVydHlJbmRleCA9IDA7IHN1YlByb3BlcnR5SW5kZXggPCBwcm9wZXJ0eS52YWx1ZS5wcm9wZXJ0aWVzLmxlbmd0aDsgc3ViUHJvcGVydHlJbmRleCsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN1YlByb3BlcnR5ID0gcHJvcGVydHkudmFsdWUucHJvcGVydGllc1tzdWJQcm9wZXJ0eUluZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHN1YlByb3BlcnR5LnR5cGUgPT09ICdQcm9wZXJ0eScpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkRGVjbGFyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHN1YlByb3BlcnR5LmtleS5uYW1lXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgaW5pdDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGRlY2xhcmF0aW9uLmluaXQsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BlcnR5LmtleS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3ViUHJvcGVydHkua2V5Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHN0YXRlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5LnZhbHVlLnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgbm9ybWFsaXplZERlY2xhcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgIG5hbWU6IHByb3BlcnR5LnZhbHVlICYmIHByb3BlcnR5LnZhbHVlLm5hbWUgPyBwcm9wZXJ0eS52YWx1ZS5uYW1lIDogcHJvcGVydHkua2V5Lm5hbWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaW5pdDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IGRlY2xhcmF0aW9uLmluaXQsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BlcnR5LmtleS5uYW1lXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBzdGF0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkZWNsYXJhdGlvbi5pZCAmJiBkZWNsYXJhdGlvbi5pZC50eXBlID09PSAnQXJyYXlQYXR0ZXJuJyAmJiBkZWNsYXJhdGlvbi5pZC5lbGVtZW50cykge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnRzIH0gPSBkZWNsYXJhdGlvbi5pZDtcbiAgICAgICAgZm9yIChsZXQgZWxlbWVudEluZGV4ID0gMDsgZWxlbWVudEluZGV4IDwgZWxlbWVudHMubGVuZ3RoOyBlbGVtZW50SW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tlbGVtZW50SW5kZXhdO1xuICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgICAgbm9ybWFsaXplZERlY2xhcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgIG5hbWU6IGVsZW1lbnQubmFtZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgIG9iamVjdDogZGVjbGFyYXRpb24uaW5pdCxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eToge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ0xpdGVyYWwnLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGVsZW1lbnRJbmRleCxcbiAgICAgICAgICAgICAgICAgIHJhdzogZWxlbWVudEluZGV4LnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICBzdGFydDogZWxlbWVudC5zdGFydCxcbiAgICAgICAgICAgICAgICAgIGVuZDogZWxlbWVudC5lbmRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgc3RhdGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1hbGl6ZWREZWNsYXJhdGlvbnMucHVzaChkZWNsYXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkRGVjbGFyYXRpb25zO1xuICB9LFxuXG4gIHNwbGl0SFRNTEltYWdlVG9SR0I6IChncHUsIGltYWdlKSA9PiB7XG4gICAgY29uc3Qgcktlcm5lbCA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oYSkge1xuICAgICAgY29uc3QgcGl4ZWwgPSBhW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgcmV0dXJuIHBpeGVsLnIgKiAyNTU7XG4gICAgfSwge1xuICAgICAgb3V0cHV0OiBbaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodF0sXG4gICAgICBwcmVjaXNpb246ICd1bnNpZ25lZCcsXG4gICAgICBhcmd1bWVudFR5cGVzOiB7IGE6ICdIVE1MSW1hZ2UnIH0sXG4gICAgfSk7XG4gICAgY29uc3QgZ0tlcm5lbCA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oYSkge1xuICAgICAgY29uc3QgcGl4ZWwgPSBhW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgcmV0dXJuIHBpeGVsLmcgKiAyNTU7XG4gICAgfSwge1xuICAgICAgb3V0cHV0OiBbaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodF0sXG4gICAgICBwcmVjaXNpb246ICd1bnNpZ25lZCcsXG4gICAgICBhcmd1bWVudFR5cGVzOiB7IGE6ICdIVE1MSW1hZ2UnIH0sXG4gICAgfSk7XG4gICAgY29uc3QgYktlcm5lbCA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oYSkge1xuICAgICAgY29uc3QgcGl4ZWwgPSBhW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgcmV0dXJuIHBpeGVsLmIgKiAyNTU7XG4gICAgfSwge1xuICAgICAgb3V0cHV0OiBbaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodF0sXG4gICAgICBwcmVjaXNpb246ICd1bnNpZ25lZCcsXG4gICAgICBhcmd1bWVudFR5cGVzOiB7IGE6ICdIVE1MSW1hZ2UnIH0sXG4gICAgfSk7XG4gICAgY29uc3QgYUtlcm5lbCA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24oYSkge1xuICAgICAgY29uc3QgcGl4ZWwgPSBhW3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgcmV0dXJuIHBpeGVsLmEgKiAyNTU7XG4gICAgfSwge1xuICAgICAgb3V0cHV0OiBbaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodF0sXG4gICAgICBwcmVjaXNpb246ICd1bnNpZ25lZCcsXG4gICAgICBhcmd1bWVudFR5cGVzOiB7IGE6ICdIVE1MSW1hZ2UnIH0sXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gW1xuICAgICAgcktlcm5lbChpbWFnZSksXG4gICAgICBnS2VybmVsKGltYWdlKSxcbiAgICAgIGJLZXJuZWwoaW1hZ2UpLFxuICAgICAgYUtlcm5lbChpbWFnZSksXG4gICAgXTtcbiAgICByZXN1bHQucktlcm5lbCA9IHJLZXJuZWw7XG4gICAgcmVzdWx0LmdLZXJuZWwgPSBnS2VybmVsO1xuICAgIHJlc3VsdC5iS2VybmVsID0gYktlcm5lbDtcbiAgICByZXN1bHQuYUtlcm5lbCA9IGFLZXJuZWw7XG4gICAgcmVzdWx0LmdwdSA9IGdwdTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIHNwbGl0UkdCQVRvQ2FudmFzZXM6IChncHUsIHJnYmEsIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB2aXN1YWxLZXJuZWxSID0gZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbih2KSB7XG4gICAgICBjb25zdCBwaXhlbCA9IHZbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICB0aGlzLmNvbG9yKHBpeGVsLnIgLyAyNTUsIDAsIDAsIDI1NSk7XG4gICAgfSwge1xuICAgICAgb3V0cHV0OiBbd2lkdGgsIGhlaWdodF0sXG4gICAgICBncmFwaGljYWw6IHRydWUsXG4gICAgICBhcmd1bWVudFR5cGVzOiB7IHY6ICdBcnJheTJEKDQpJyB9XG4gICAgfSk7XG4gICAgdmlzdWFsS2VybmVsUihyZ2JhKTtcblxuICAgIGNvbnN0IHZpc3VhbEtlcm5lbEcgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKHYpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gdlt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHRoaXMuY29sb3IoMCwgcGl4ZWwuZyAvIDI1NSwgMCwgMjU1KTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgIGdyYXBoaWNhbDogdHJ1ZSxcbiAgICAgIGFyZ3VtZW50VHlwZXM6IHsgdjogJ0FycmF5MkQoNCknIH1cbiAgICB9KTtcbiAgICB2aXN1YWxLZXJuZWxHKHJnYmEpO1xuXG4gICAgY29uc3QgdmlzdWFsS2VybmVsQiA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24odikge1xuICAgICAgY29uc3QgcGl4ZWwgPSB2W3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgdGhpcy5jb2xvcigwLCAwLCBwaXhlbC5iIC8gMjU1LCAyNTUpO1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgZ3JhcGhpY2FsOiB0cnVlLFxuICAgICAgYXJndW1lbnRUeXBlczogeyB2OiAnQXJyYXkyRCg0KScgfVxuICAgIH0pO1xuICAgIHZpc3VhbEtlcm5lbEIocmdiYSk7XG5cbiAgICBjb25zdCB2aXN1YWxLZXJuZWxBID0gZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbih2KSB7XG4gICAgICBjb25zdCBwaXhlbCA9IHZbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICB0aGlzLmNvbG9yKDI1NSwgMjU1LCAyNTUsIHBpeGVsLmEgLyAyNTUpO1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgZ3JhcGhpY2FsOiB0cnVlLFxuICAgICAgYXJndW1lbnRUeXBlczogeyB2OiAnQXJyYXkyRCg0KScgfVxuICAgIH0pO1xuICAgIHZpc3VhbEtlcm5lbEEocmdiYSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIHZpc3VhbEtlcm5lbFIuY2FudmFzLFxuICAgICAgdmlzdWFsS2VybmVsRy5jYW52YXMsXG4gICAgICB2aXN1YWxLZXJuZWxCLmNhbnZhcyxcbiAgICAgIHZpc3VhbEtlcm5lbEEuY2FudmFzLFxuICAgIF07XG4gIH0sXG5cbiAgZ2V0TWluaWZ5U2FmZU5hbWU6IChmbikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhc3QgPSBhY29ybi5wYXJzZShgY29uc3QgdmFsdWUgPSAke2ZuLnRvU3RyaW5nKCl9YCk7XG4gICAgICBjb25zdCB7IGluaXQgfSA9IGFzdC5ib2R5WzBdLmRlY2xhcmF0aW9uc1swXTtcbiAgICAgIHJldHVybiBpbml0LmJvZHkubmFtZSB8fCBpbml0LmJvZHkuYm9keVswXS5hcmd1bWVudC5uYW1lO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGZ1bmN0aW9uIHR5cGUuICBQbGVhc2UgdXNlIGAoKSA9PiB5b3VyRnVuY3Rpb25WYXJpYWJsZUhlcmVgIG9yIGZ1bmN0aW9uKCkgeyByZXR1cm4geW91ckZ1bmN0aW9uVmFyaWFibGVIZXJlOyB9Jyk7XG4gICAgfVxuICB9LFxuICBzYW5pdGl6ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoZG9sbGFyU2lnbi50ZXN0KG5hbWUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRvbGxhclNpZ24sICdTX1MnKTtcbiAgICB9XG4gICAgaWYgKGRvdWJsZVVuZGVyc2NvcmUudGVzdChuYW1lKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkb3VibGVVbmRlcnNjb3JlLCAnVV9VJyk7XG4gICAgfSBlbHNlIGlmIChzaW5nbGVVbmRlcnNjb3JlLnRlc3QobmFtZSkpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uoc2luZ2xlVW5kZXJzY29yZSwgJ3VfdScpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbiAgfVxufTtcblxuY29uc3QgZG9sbGFyU2lnbiA9IC9cXCQvO1xuY29uc3QgZG91YmxlVW5kZXJzY29yZSA9IC9fXy87XG5jb25zdCBzaW5nbGVVbmRlcnNjb3JlID0gL18vO1xuXG5jb25zdCBfc3lzdGVtRW5kaWFubmVzcyA9IHV0aWxzLmdldFN5c3RlbUVuZGlhbm5lc3MoKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHV0aWxzXG59O1xuXG59LHtcIi4vaW5wdXRcIjoxMTAsXCIuL3RleHR1cmVcIjoxMTMsXCJhY29yblwiOjF9XX0se30sWzEwN10pKDEwNylcbn0pO1xuIiwiaW1wb3J0IHtcclxuICBJS2VybmVsRnVuY3Rpb25UaGlzLFxyXG4gIElLZXJuZWxSdW5TaG9ydGN1dCxcclxuICBJQ29uc3RhbnRzVGhpcyxcclxuICBHUFUsXHJcbiAgVGhyZWFkS2VybmVsVmFyaWFibGUsXHJcbiAgS2VybmVsLFxyXG4gIEZ1bmN0aW9uTm9kZSxcclxufSBmcm9tICdncHUuanMnXHJcblxyXG5pbnRlcmZhY2UgUmVkcmF3IHtcclxuICAoKTogdm9pZFxyXG4gIGNoYW5nZTogSUtlcm5lbFJ1blNob3J0Y3V0XHJcbn1cclxuXHJcbmludGVyZmFjZSBSZW5kZXJWYWx1ZXMge1xyXG4gIG1vdXNlWDogbnVtYmVyXHJcbiAgbW91c2VZOiBudW1iZXJcclxufVxyXG5cclxuaW50ZXJmYWNlIElLZXJuZWxGdW5jdGlvbiBleHRlbmRzIElLZXJuZWxGdW5jdGlvblRoaXMge1xyXG4gIG51bShhOiB1bmtub3duKTogbnVtYmVyXHJcbiAgZGlzdCh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUmVuZGVyZXIge1xyXG4gIHByaXZhdGUgcmVuZGVyU2V0dGluZ3M6IFJlbmRlclZhbHVlcyA9IHtcclxuICAgIG1vdXNlWDogMSxcclxuICAgIG1vdXNlWTogMSxcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBpc0RyYXdpbmc6IGJvb2xlYW4gPSBmYWxzZVxyXG4gIHB1YmxpYyByZWRyYXc6IFJlZHJhd1xyXG5cclxuICBwcm90ZWN0ZWQgYXN5bmMgY3JlYXRlUmVuZGVyZXIoZ3B1OiBHUFUsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgIGNvbnN0IHJlZHIgPSBncHVcclxuICAgICAgLmNyZWF0ZUtlcm5lbChmdW5jdGlvbiAobW91c2VYLCBtb3VzZVkpIHtcclxuICAgICAgICBmdW5jdGlvbiBudW0oYTogVGhyZWFkS2VybmVsVmFyaWFibGUpIHtcclxuICAgICAgICAgIHJldHVybiBhIGFzIG51bWJlclxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGlzdCh4OiBudW1iZXIsIHk6IG51bWJlcikge1xyXG4gICAgICAgICAgcmV0dXJuIHggKyB5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkc3QgPVxyXG4gICAgICAgICAgZGlzdCh0aGlzLnRocmVhZC54IC0gbnVtKG1vdXNlWCksIHRoaXMudGhyZWFkLnkgLSBudW0obW91c2VZKSkgL1xyXG4gICAgICAgICAgZGlzdCh0aGlzLm91dHB1dC54LCB0aGlzLm91dHB1dC55KVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICBNYXRoLnNxcnQoXHJcbiAgICAgICAgICAgICh0aGlzLnRocmVhZC54IC0gbnVtKG1vdXNlWCkpICpcclxuICAgICAgICAgICAgICAodGhpcy50aHJlYWQueCAtIChtb3VzZVggYXMgbnVtYmVyKSkgK1xyXG4gICAgICAgICAgICAgICh0aGlzLm91dHB1dC55IC0gdGhpcy50aHJlYWQueSAtIChtb3VzZVkgYXMgbnVtYmVyKSkgKlxyXG4gICAgICAgICAgICAgICAgKHRoaXMub3V0cHV0LnkgLSB0aGlzLnRocmVhZC55IC0gKG1vdXNlWSBhcyBudW1iZXIpKVxyXG4gICAgICAgICAgKSAvXHJcbiAgICAgICAgICBNYXRoLnNxcnQoXHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0LnggKiB0aGlzLm91dHB1dC54ICsgdGhpcy5vdXRwdXQueSAqIHRoaXMub3V0cHV0LnlcclxuICAgICAgICAgICkqL1xyXG4gICAgICAgIHRoaXMuY29sb3IoMC4zLCBNYXRoLm1heCgxIC0gMiAqIGRzdCwgMCksIE1hdGgubWF4KDEgLSAyICogZHN0LCAwKSwgMSlcclxuICAgICAgfSlcclxuICAgICAgLnNldE91dHB1dChbY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0XSlcclxuICAgICAgLnNldER5bmFtaWNPdXRwdXQodHJ1ZSlcclxuICAgICAgLnNldEdyYXBoaWNhbCh0cnVlKVxyXG5cclxuICAgIGxldCByZWRyYXcgPSAoKCkgPT4ge1xyXG4gICAgICByZWRyKHRoaXMucmVuZGVyU2V0dGluZ3MubW91c2VYLCB0aGlzLnJlbmRlclNldHRpbmdzLm1vdXNlWSlcclxuICAgIH0pIGFzIFJlZHJhd1xyXG4gICAgcmVkcmF3LmNoYW5nZSA9IHJlZHJcclxuICAgIHRoaXMucmVkcmF3ID0gcmVkcmF3XHJcbiAgICByZWRyYXcoKVxyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIHNldFZhcihuYW1lOiBrZXlvZiBSZW5kZXJWYWx1ZXMsIHZhbDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnJlbmRlclNldHRpbmdzW2Ake25hbWUgYXMga2V5b2YgUmVuZGVyVmFsdWVzfWBdID0gdmFsXHJcbiAgfVxyXG59XHJcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgeyBHUFUsIElLZXJuZWxSdW5TaG9ydGN1dCB9IGZyb20gJ2dwdS5qcydcclxuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICdAL3JlbmRlcmVyJ1xyXG5cclxuLy8gaW50ZXJmYWNlIFBoeXNpY3Mge31cclxuXHJcbmNsYXNzIERyYXdpbmdBcHAgZXh0ZW5kcyBSZW5kZXJlciB7XHJcbiAgcHJpdmF0ZSBncHU6IEdQVVxyXG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudFxyXG4gIC8vIHByaXZhdGUgY29udGV4dDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dFxyXG5cclxuICBwcml2YXRlIHByZXNzZWQ6IGJvb2xlYW4gPSBmYWxzZVxyXG4gIHByaXZhdGUgY2xpY2tYOiBudW1iZXJcclxuICBwcml2YXRlIGNsaWNrWTogbnVtYmVyXHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKVxyXG4gICAgbGV0IGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdXHJcbiAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcclxuICAgIGxldCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicpXHJcbiAgICBsZXQgZ3B1ID0gbmV3IEdQVSh7IGNhbnZhcywgY29udGV4dCB9KVxyXG5cclxuICAgIGJvZHkuc3R5bGUubWFyZ2luID0gJzBweCdcclxuICAgIGJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJ1xyXG4gICAgYm9keS5hcHBlbmRDaGlsZChjYW52YXMpXHJcblxyXG4gICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGhcclxuICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcclxuXHJcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhc1xyXG4gICAgLy8gdGhpcy5jb250ZXh0ID0gY29udGV4dFxyXG4gICAgdGhpcy5ncHUgPSBncHVcclxuXHJcbiAgICB0aGlzLmNyZWF0ZVVzZXJFdmVudHMoKVxyXG4gICAgdGhpcy5jcmVhdGVSZW5kZXJlcihncHUsIGNhbnZhcylcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlVXNlckV2ZW50cygpIHtcclxuICAgIGxldCBjYW52YXMgPSB0aGlzLmNhbnZhc1xyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZScsIHRoaXMuZm9jdXNFdmVudEhhbmRsZXIpXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyb3V0JywgKCkgPT4gKHRoaXMuaXNEcmF3aW5nID0gZmFsc2UpKVxyXG5cclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLnByZXNzRXZlbnRIYW5kbGVyKVxyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuZHJhZ0V2ZW50SGFuZGxlcilcclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5yZWxlYXNlRXZlbnRIYW5kbGVyKVxyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5jYW5jZWxFdmVudEhhbmRsZXIpXHJcblxyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLnByZXNzRXZlbnRIYW5kbGVyKVxyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuZHJhZ0V2ZW50SGFuZGxlcilcclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMucmVsZWFzZUV2ZW50SGFuZGxlcilcclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuY2FuY2VsRXZlbnRIYW5kbGVyKVxyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZUV2ZW50SGFuZGxlcilcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZm9jdXNFdmVudEhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZWRyYXcpXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlc2l6ZUV2ZW50SGFuZGxlciA9ICgpID0+IHtcclxuICAgIHRoaXMucmVkcmF3LmNoYW5nZS5zZXRPdXRwdXQoW3dpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHRdKVxyXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxyXG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlbGVhc2VFdmVudEhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjYW5jZWxFdmVudEhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBwcmVzc0V2ZW50SGFuZGxlciA9IChlOiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4ge1xyXG4gICAgbGV0IG1vdXNlWCA9IChlIGFzIFRvdWNoRXZlbnQpLmNoYW5nZWRUb3VjaGVzXHJcbiAgICAgID8gKGUgYXMgVG91Y2hFdmVudCkuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVhcclxuICAgICAgOiAoZSBhcyBNb3VzZUV2ZW50KS5wYWdlWFxyXG4gICAgbGV0IG1vdXNlWSA9IChlIGFzIFRvdWNoRXZlbnQpLmNoYW5nZWRUb3VjaGVzXHJcbiAgICAgID8gKGUgYXMgVG91Y2hFdmVudCkuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVlcclxuICAgICAgOiAoZSBhcyBNb3VzZUV2ZW50KS5wYWdlWVxyXG4gICAgbW91c2VYIC09IHRoaXMuY2FudmFzLm9mZnNldExlZnRcclxuICAgIG1vdXNlWSAtPSB0aGlzLmNhbnZhcy5vZmZzZXRUb3BcclxuXHJcbiAgICB0aGlzLnByZXNzZWQgPSB0cnVlXHJcbiAgICB0aGlzLmNsaWNrWCA9IG1vdXNlWFxyXG4gICAgdGhpcy5jbGlja1kgPSBtb3VzZVlcclxuICAgIHRoaXMuc2V0VmFyKCdtb3VzZVgnLCBtb3VzZVgpXHJcbiAgICB0aGlzLnNldFZhcignbW91c2VZJywgbW91c2VZKVxyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRyYWdFdmVudEhhbmRsZXIgPSAoZTogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHtcclxuICAgIGxldCBtb3VzZVggPSAoZSBhcyBUb3VjaEV2ZW50KS5jaGFuZ2VkVG91Y2hlc1xyXG4gICAgICA/IChlIGFzIFRvdWNoRXZlbnQpLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYXHJcbiAgICAgIDogKGUgYXMgTW91c2VFdmVudCkucGFnZVhcclxuICAgIGxldCBtb3VzZVkgPSAoZSBhcyBUb3VjaEV2ZW50KS5jaGFuZ2VkVG91Y2hlc1xyXG4gICAgICA/IChlIGFzIFRvdWNoRXZlbnQpLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZXHJcbiAgICAgIDogKGUgYXMgTW91c2VFdmVudCkucGFnZVlcclxuICAgIG1vdXNlWCAtPSB0aGlzLmNhbnZhcy5vZmZzZXRMZWZ0XHJcbiAgICBtb3VzZVkgLT0gdGhpcy5jYW52YXMub2Zmc2V0VG9wXHJcblxyXG4gICAgaWYgKHRoaXMucHJlc3NlZCkge1xyXG4gICAgICB0aGlzLmNsaWNrWCA9IG1vdXNlWFxyXG4gICAgICB0aGlzLmNsaWNrWSA9IG1vdXNlWVxyXG4gICAgICB0aGlzLnNldFZhcignbW91c2VYJywgbW91c2VYKVxyXG4gICAgICB0aGlzLnNldFZhcignbW91c2VZJywgbW91c2VZKVxyXG4gICAgfVxyXG4gICAgLy8gZ2FtZS5yZWRyYXcoKVxyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBnYW1lID0gbmV3IERyYXdpbmdBcHAoKVxyXG47KGZ1bmN0aW9uIGxvb3AoKSB7XHJcbiAgZ2FtZS5yZWRyYXcoKVxyXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKVxyXG59KSgpXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==